
OS_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000056fc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000c  00800060  000056fc  00005790  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000640  0080006c  0080006c  0000579c  2**0
                  ALLOC
  3 .stab         00007ca4  00000000  00000000  0000579c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004b72  00000000  00000000  0000d440  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec ef       	ldi	r30, 0xFC	; 252
      68:	f6 e5       	ldi	r31, 0x56	; 86
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 36       	cpi	r26, 0x6C	; 108
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	ac e6       	ldi	r26, 0x6C	; 108
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 3a       	cpi	r26, 0xAC	; 172
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 13 2b 	call	0x5626	; 0x5626 <main>
      8a:	0c 94 7c 2b 	jmp	0x56f8	; 0x56f8 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <pvPortMalloc+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <pvPortMalloc+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	9c 83       	std	Y+4, r25	; 0x04
      a0:	8b 83       	std	Y+3, r24	; 0x03
      a2:	1a 82       	std	Y+2, r1	; 0x02
      a4:	19 82       	std	Y+1, r1	; 0x01
      a6:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
      aa:	80 91 6e 00 	lds	r24, 0x006E
      ae:	90 91 6f 00 	lds	r25, 0x006F
      b2:	00 97       	sbiw	r24, 0x00	; 0
      b4:	31 f4       	brne	.+12     	; 0xc2 <pvPortMalloc+0x30>
      b6:	80 e7       	ldi	r24, 0x70	; 112
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	90 93 6f 00 	sts	0x006F, r25
      be:	80 93 6e 00 	sts	0x006E, r24
      c2:	8b 81       	ldd	r24, Y+3	; 0x03
      c4:	9c 81       	ldd	r25, Y+4	; 0x04
      c6:	00 97       	sbiw	r24, 0x00	; 0
      c8:	99 f1       	breq	.+102    	; 0x130 <pvPortMalloc+0x9e>
      ca:	80 91 6c 00 	lds	r24, 0x006C
      ce:	90 91 6d 00 	lds	r25, 0x006D
      d2:	2b 81       	ldd	r18, Y+3	; 0x03
      d4:	3c 81       	ldd	r19, Y+4	; 0x04
      d6:	82 0f       	add	r24, r18
      d8:	93 1f       	adc	r25, r19
      da:	25 e0       	ldi	r18, 0x05	; 5
      dc:	8b 3d       	cpi	r24, 0xDB	; 219
      de:	92 07       	cpc	r25, r18
      e0:	38 f5       	brcc	.+78     	; 0x130 <pvPortMalloc+0x9e>
      e2:	20 91 6c 00 	lds	r18, 0x006C
      e6:	30 91 6d 00 	lds	r19, 0x006D
      ea:	8b 81       	ldd	r24, Y+3	; 0x03
      ec:	9c 81       	ldd	r25, Y+4	; 0x04
      ee:	28 0f       	add	r18, r24
      f0:	39 1f       	adc	r19, r25
      f2:	80 91 6c 00 	lds	r24, 0x006C
      f6:	90 91 6d 00 	lds	r25, 0x006D
      fa:	82 17       	cp	r24, r18
      fc:	93 07       	cpc	r25, r19
      fe:	c0 f4       	brcc	.+48     	; 0x130 <pvPortMalloc+0x9e>
     100:	20 91 6e 00 	lds	r18, 0x006E
     104:	30 91 6f 00 	lds	r19, 0x006F
     108:	80 91 6c 00 	lds	r24, 0x006C
     10c:	90 91 6d 00 	lds	r25, 0x006D
     110:	82 0f       	add	r24, r18
     112:	93 1f       	adc	r25, r19
     114:	9a 83       	std	Y+2, r25	; 0x02
     116:	89 83       	std	Y+1, r24	; 0x01
     118:	20 91 6c 00 	lds	r18, 0x006C
     11c:	30 91 6d 00 	lds	r19, 0x006D
     120:	8b 81       	ldd	r24, Y+3	; 0x03
     122:	9c 81       	ldd	r25, Y+4	; 0x04
     124:	82 0f       	add	r24, r18
     126:	93 1f       	adc	r25, r19
     128:	90 93 6d 00 	sts	0x006D, r25
     12c:	80 93 6c 00 	sts	0x006C, r24
     130:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
     134:	89 81       	ldd	r24, Y+1	; 0x01
     136:	9a 81       	ldd	r25, Y+2	; 0x02
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	0f 90       	pop	r0
     140:	cf 91       	pop	r28
     142:	df 91       	pop	r29
     144:	08 95       	ret

00000146 <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     146:	df 93       	push	r29
     148:	cf 93       	push	r28
     14a:	00 d0       	rcall	.+0      	; 0x14c <vPortFree+0x6>
     14c:	cd b7       	in	r28, 0x3d	; 61
     14e:	de b7       	in	r29, 0x3e	; 62
     150:	9a 83       	std	Y+2, r25	; 0x02
     152:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     154:	0f 90       	pop	r0
     156:	0f 90       	pop	r0
     158:	cf 91       	pop	r28
     15a:	df 91       	pop	r29
     15c:	08 95       	ret

0000015e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     15e:	df 93       	push	r29
     160:	cf 93       	push	r28
     162:	cd b7       	in	r28, 0x3d	; 61
     164:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     166:	10 92 6d 00 	sts	0x006D, r1
     16a:	10 92 6c 00 	sts	0x006C, r1
}
     16e:	cf 91       	pop	r28
     170:	df 91       	pop	r29
     172:	08 95       	ret

00000174 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     174:	df 93       	push	r29
     176:	cf 93       	push	r28
     178:	cd b7       	in	r28, 0x3d	; 61
     17a:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     17c:	20 91 6c 00 	lds	r18, 0x006C
     180:	30 91 6d 00 	lds	r19, 0x006D
     184:	8b ed       	ldi	r24, 0xDB	; 219
     186:	95 e0       	ldi	r25, 0x05	; 5
     188:	82 1b       	sub	r24, r18
     18a:	93 0b       	sbc	r25, r19
}
     18c:	cf 91       	pop	r28
     18e:	df 91       	pop	r29
     190:	08 95       	ret

00000192 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     192:	df 93       	push	r29
     194:	cf 93       	push	r28
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
     19a:	28 97       	sbiw	r28, 0x08	; 8
     19c:	0f b6       	in	r0, 0x3f	; 63
     19e:	f8 94       	cli
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	0f be       	out	0x3f, r0	; 63
     1a4:	cd bf       	out	0x3d, r28	; 61
     1a6:	9c 83       	std	Y+4, r25	; 0x04
     1a8:	8b 83       	std	Y+3, r24	; 0x03
     1aa:	7e 83       	std	Y+6, r23	; 0x06
     1ac:	6d 83       	std	Y+5, r22	; 0x05
     1ae:	58 87       	std	Y+8, r21	; 0x08
     1b0:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     1b2:	eb 81       	ldd	r30, Y+3	; 0x03
     1b4:	fc 81       	ldd	r31, Y+4	; 0x04
     1b6:	81 e1       	ldi	r24, 0x11	; 17
     1b8:	80 83       	st	Z, r24
	pxTopOfStack--;
     1ba:	8b 81       	ldd	r24, Y+3	; 0x03
     1bc:	9c 81       	ldd	r25, Y+4	; 0x04
     1be:	01 97       	sbiw	r24, 0x01	; 1
     1c0:	9c 83       	std	Y+4, r25	; 0x04
     1c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     1c4:	eb 81       	ldd	r30, Y+3	; 0x03
     1c6:	fc 81       	ldd	r31, Y+4	; 0x04
     1c8:	82 e2       	ldi	r24, 0x22	; 34
     1ca:	80 83       	st	Z, r24
	pxTopOfStack--;
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	01 97       	sbiw	r24, 0x01	; 1
     1d2:	9c 83       	std	Y+4, r25	; 0x04
     1d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     1d6:	eb 81       	ldd	r30, Y+3	; 0x03
     1d8:	fc 81       	ldd	r31, Y+4	; 0x04
     1da:	83 e3       	ldi	r24, 0x33	; 51
     1dc:	80 83       	st	Z, r24
	pxTopOfStack--;
     1de:	8b 81       	ldd	r24, Y+3	; 0x03
     1e0:	9c 81       	ldd	r25, Y+4	; 0x04
     1e2:	01 97       	sbiw	r24, 0x01	; 1
     1e4:	9c 83       	std	Y+4, r25	; 0x04
     1e6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     1e8:	8d 81       	ldd	r24, Y+5	; 0x05
     1ea:	9e 81       	ldd	r25, Y+6	; 0x06
     1ec:	9a 83       	std	Y+2, r25	; 0x02
     1ee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     1f0:	89 81       	ldd	r24, Y+1	; 0x01
     1f2:	eb 81       	ldd	r30, Y+3	; 0x03
     1f4:	fc 81       	ldd	r31, Y+4	; 0x04
     1f6:	80 83       	st	Z, r24
	pxTopOfStack--;
     1f8:	8b 81       	ldd	r24, Y+3	; 0x03
     1fa:	9c 81       	ldd	r25, Y+4	; 0x04
     1fc:	01 97       	sbiw	r24, 0x01	; 1
     1fe:	9c 83       	std	Y+4, r25	; 0x04
     200:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     202:	89 81       	ldd	r24, Y+1	; 0x01
     204:	9a 81       	ldd	r25, Y+2	; 0x02
     206:	89 2f       	mov	r24, r25
     208:	99 27       	eor	r25, r25
     20a:	9a 83       	std	Y+2, r25	; 0x02
     20c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	eb 81       	ldd	r30, Y+3	; 0x03
     212:	fc 81       	ldd	r31, Y+4	; 0x04
     214:	80 83       	st	Z, r24
	pxTopOfStack--;
     216:	8b 81       	ldd	r24, Y+3	; 0x03
     218:	9c 81       	ldd	r25, Y+4	; 0x04
     21a:	01 97       	sbiw	r24, 0x01	; 1
     21c:	9c 83       	std	Y+4, r25	; 0x04
     21e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     220:	eb 81       	ldd	r30, Y+3	; 0x03
     222:	fc 81       	ldd	r31, Y+4	; 0x04
     224:	10 82       	st	Z, r1
	pxTopOfStack--;
     226:	8b 81       	ldd	r24, Y+3	; 0x03
     228:	9c 81       	ldd	r25, Y+4	; 0x04
     22a:	01 97       	sbiw	r24, 0x01	; 1
     22c:	9c 83       	std	Y+4, r25	; 0x04
     22e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     230:	eb 81       	ldd	r30, Y+3	; 0x03
     232:	fc 81       	ldd	r31, Y+4	; 0x04
     234:	80 e8       	ldi	r24, 0x80	; 128
     236:	80 83       	st	Z, r24
	pxTopOfStack--;
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	01 97       	sbiw	r24, 0x01	; 1
     23e:	9c 83       	std	Y+4, r25	; 0x04
     240:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     242:	eb 81       	ldd	r30, Y+3	; 0x03
     244:	fc 81       	ldd	r31, Y+4	; 0x04
     246:	10 82       	st	Z, r1
	pxTopOfStack--;
     248:	8b 81       	ldd	r24, Y+3	; 0x03
     24a:	9c 81       	ldd	r25, Y+4	; 0x04
     24c:	01 97       	sbiw	r24, 0x01	; 1
     24e:	9c 83       	std	Y+4, r25	; 0x04
     250:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     252:	eb 81       	ldd	r30, Y+3	; 0x03
     254:	fc 81       	ldd	r31, Y+4	; 0x04
     256:	82 e0       	ldi	r24, 0x02	; 2
     258:	80 83       	st	Z, r24
	pxTopOfStack--;
     25a:	8b 81       	ldd	r24, Y+3	; 0x03
     25c:	9c 81       	ldd	r25, Y+4	; 0x04
     25e:	01 97       	sbiw	r24, 0x01	; 1
     260:	9c 83       	std	Y+4, r25	; 0x04
     262:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     264:	eb 81       	ldd	r30, Y+3	; 0x03
     266:	fc 81       	ldd	r31, Y+4	; 0x04
     268:	83 e0       	ldi	r24, 0x03	; 3
     26a:	80 83       	st	Z, r24
	pxTopOfStack--;
     26c:	8b 81       	ldd	r24, Y+3	; 0x03
     26e:	9c 81       	ldd	r25, Y+4	; 0x04
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	9c 83       	std	Y+4, r25	; 0x04
     274:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     276:	eb 81       	ldd	r30, Y+3	; 0x03
     278:	fc 81       	ldd	r31, Y+4	; 0x04
     27a:	84 e0       	ldi	r24, 0x04	; 4
     27c:	80 83       	st	Z, r24
	pxTopOfStack--;
     27e:	8b 81       	ldd	r24, Y+3	; 0x03
     280:	9c 81       	ldd	r25, Y+4	; 0x04
     282:	01 97       	sbiw	r24, 0x01	; 1
     284:	9c 83       	std	Y+4, r25	; 0x04
     286:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     288:	eb 81       	ldd	r30, Y+3	; 0x03
     28a:	fc 81       	ldd	r31, Y+4	; 0x04
     28c:	85 e0       	ldi	r24, 0x05	; 5
     28e:	80 83       	st	Z, r24
	pxTopOfStack--;
     290:	8b 81       	ldd	r24, Y+3	; 0x03
     292:	9c 81       	ldd	r25, Y+4	; 0x04
     294:	01 97       	sbiw	r24, 0x01	; 1
     296:	9c 83       	std	Y+4, r25	; 0x04
     298:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     29a:	eb 81       	ldd	r30, Y+3	; 0x03
     29c:	fc 81       	ldd	r31, Y+4	; 0x04
     29e:	86 e0       	ldi	r24, 0x06	; 6
     2a0:	80 83       	st	Z, r24
	pxTopOfStack--;
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	01 97       	sbiw	r24, 0x01	; 1
     2a8:	9c 83       	std	Y+4, r25	; 0x04
     2aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     2ac:	eb 81       	ldd	r30, Y+3	; 0x03
     2ae:	fc 81       	ldd	r31, Y+4	; 0x04
     2b0:	87 e0       	ldi	r24, 0x07	; 7
     2b2:	80 83       	st	Z, r24
	pxTopOfStack--;
     2b4:	8b 81       	ldd	r24, Y+3	; 0x03
     2b6:	9c 81       	ldd	r25, Y+4	; 0x04
     2b8:	01 97       	sbiw	r24, 0x01	; 1
     2ba:	9c 83       	std	Y+4, r25	; 0x04
     2bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2be:	eb 81       	ldd	r30, Y+3	; 0x03
     2c0:	fc 81       	ldd	r31, Y+4	; 0x04
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	80 83       	st	Z, r24
	pxTopOfStack--;
     2c6:	8b 81       	ldd	r24, Y+3	; 0x03
     2c8:	9c 81       	ldd	r25, Y+4	; 0x04
     2ca:	01 97       	sbiw	r24, 0x01	; 1
     2cc:	9c 83       	std	Y+4, r25	; 0x04
     2ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     2d0:	eb 81       	ldd	r30, Y+3	; 0x03
     2d2:	fc 81       	ldd	r31, Y+4	; 0x04
     2d4:	89 e0       	ldi	r24, 0x09	; 9
     2d6:	80 83       	st	Z, r24
	pxTopOfStack--;
     2d8:	8b 81       	ldd	r24, Y+3	; 0x03
     2da:	9c 81       	ldd	r25, Y+4	; 0x04
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	9c 83       	std	Y+4, r25	; 0x04
     2e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     2e2:	eb 81       	ldd	r30, Y+3	; 0x03
     2e4:	fc 81       	ldd	r31, Y+4	; 0x04
     2e6:	80 e1       	ldi	r24, 0x10	; 16
     2e8:	80 83       	st	Z, r24
	pxTopOfStack--;
     2ea:	8b 81       	ldd	r24, Y+3	; 0x03
     2ec:	9c 81       	ldd	r25, Y+4	; 0x04
     2ee:	01 97       	sbiw	r24, 0x01	; 1
     2f0:	9c 83       	std	Y+4, r25	; 0x04
     2f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     2f4:	eb 81       	ldd	r30, Y+3	; 0x03
     2f6:	fc 81       	ldd	r31, Y+4	; 0x04
     2f8:	81 e1       	ldi	r24, 0x11	; 17
     2fa:	80 83       	st	Z, r24
	pxTopOfStack--;
     2fc:	8b 81       	ldd	r24, Y+3	; 0x03
     2fe:	9c 81       	ldd	r25, Y+4	; 0x04
     300:	01 97       	sbiw	r24, 0x01	; 1
     302:	9c 83       	std	Y+4, r25	; 0x04
     304:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     306:	eb 81       	ldd	r30, Y+3	; 0x03
     308:	fc 81       	ldd	r31, Y+4	; 0x04
     30a:	82 e1       	ldi	r24, 0x12	; 18
     30c:	80 83       	st	Z, r24
	pxTopOfStack--;
     30e:	8b 81       	ldd	r24, Y+3	; 0x03
     310:	9c 81       	ldd	r25, Y+4	; 0x04
     312:	01 97       	sbiw	r24, 0x01	; 1
     314:	9c 83       	std	Y+4, r25	; 0x04
     316:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     318:	eb 81       	ldd	r30, Y+3	; 0x03
     31a:	fc 81       	ldd	r31, Y+4	; 0x04
     31c:	83 e1       	ldi	r24, 0x13	; 19
     31e:	80 83       	st	Z, r24
	pxTopOfStack--;
     320:	8b 81       	ldd	r24, Y+3	; 0x03
     322:	9c 81       	ldd	r25, Y+4	; 0x04
     324:	01 97       	sbiw	r24, 0x01	; 1
     326:	9c 83       	std	Y+4, r25	; 0x04
     328:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     32a:	eb 81       	ldd	r30, Y+3	; 0x03
     32c:	fc 81       	ldd	r31, Y+4	; 0x04
     32e:	84 e1       	ldi	r24, 0x14	; 20
     330:	80 83       	st	Z, r24
	pxTopOfStack--;
     332:	8b 81       	ldd	r24, Y+3	; 0x03
     334:	9c 81       	ldd	r25, Y+4	; 0x04
     336:	01 97       	sbiw	r24, 0x01	; 1
     338:	9c 83       	std	Y+4, r25	; 0x04
     33a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     33c:	eb 81       	ldd	r30, Y+3	; 0x03
     33e:	fc 81       	ldd	r31, Y+4	; 0x04
     340:	85 e1       	ldi	r24, 0x15	; 21
     342:	80 83       	st	Z, r24
	pxTopOfStack--;
     344:	8b 81       	ldd	r24, Y+3	; 0x03
     346:	9c 81       	ldd	r25, Y+4	; 0x04
     348:	01 97       	sbiw	r24, 0x01	; 1
     34a:	9c 83       	std	Y+4, r25	; 0x04
     34c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     34e:	eb 81       	ldd	r30, Y+3	; 0x03
     350:	fc 81       	ldd	r31, Y+4	; 0x04
     352:	86 e1       	ldi	r24, 0x16	; 22
     354:	80 83       	st	Z, r24
	pxTopOfStack--;
     356:	8b 81       	ldd	r24, Y+3	; 0x03
     358:	9c 81       	ldd	r25, Y+4	; 0x04
     35a:	01 97       	sbiw	r24, 0x01	; 1
     35c:	9c 83       	std	Y+4, r25	; 0x04
     35e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     360:	eb 81       	ldd	r30, Y+3	; 0x03
     362:	fc 81       	ldd	r31, Y+4	; 0x04
     364:	87 e1       	ldi	r24, 0x17	; 23
     366:	80 83       	st	Z, r24
	pxTopOfStack--;
     368:	8b 81       	ldd	r24, Y+3	; 0x03
     36a:	9c 81       	ldd	r25, Y+4	; 0x04
     36c:	01 97       	sbiw	r24, 0x01	; 1
     36e:	9c 83       	std	Y+4, r25	; 0x04
     370:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     372:	eb 81       	ldd	r30, Y+3	; 0x03
     374:	fc 81       	ldd	r31, Y+4	; 0x04
     376:	88 e1       	ldi	r24, 0x18	; 24
     378:	80 83       	st	Z, r24
	pxTopOfStack--;
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
     37c:	9c 81       	ldd	r25, Y+4	; 0x04
     37e:	01 97       	sbiw	r24, 0x01	; 1
     380:	9c 83       	std	Y+4, r25	; 0x04
     382:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     384:	eb 81       	ldd	r30, Y+3	; 0x03
     386:	fc 81       	ldd	r31, Y+4	; 0x04
     388:	89 e1       	ldi	r24, 0x19	; 25
     38a:	80 83       	st	Z, r24
	pxTopOfStack--;
     38c:	8b 81       	ldd	r24, Y+3	; 0x03
     38e:	9c 81       	ldd	r25, Y+4	; 0x04
     390:	01 97       	sbiw	r24, 0x01	; 1
     392:	9c 83       	std	Y+4, r25	; 0x04
     394:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     396:	eb 81       	ldd	r30, Y+3	; 0x03
     398:	fc 81       	ldd	r31, Y+4	; 0x04
     39a:	80 e2       	ldi	r24, 0x20	; 32
     39c:	80 83       	st	Z, r24
	pxTopOfStack--;
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	9c 81       	ldd	r25, Y+4	; 0x04
     3a2:	01 97       	sbiw	r24, 0x01	; 1
     3a4:	9c 83       	std	Y+4, r25	; 0x04
     3a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3a8:	eb 81       	ldd	r30, Y+3	; 0x03
     3aa:	fc 81       	ldd	r31, Y+4	; 0x04
     3ac:	81 e2       	ldi	r24, 0x21	; 33
     3ae:	80 83       	st	Z, r24
	pxTopOfStack--;
     3b0:	8b 81       	ldd	r24, Y+3	; 0x03
     3b2:	9c 81       	ldd	r25, Y+4	; 0x04
     3b4:	01 97       	sbiw	r24, 0x01	; 1
     3b6:	9c 83       	std	Y+4, r25	; 0x04
     3b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3ba:	eb 81       	ldd	r30, Y+3	; 0x03
     3bc:	fc 81       	ldd	r31, Y+4	; 0x04
     3be:	82 e2       	ldi	r24, 0x22	; 34
     3c0:	80 83       	st	Z, r24
	pxTopOfStack--;
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	01 97       	sbiw	r24, 0x01	; 1
     3c8:	9c 83       	std	Y+4, r25	; 0x04
     3ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	83 e2       	ldi	r24, 0x23	; 35
     3d2:	80 83       	st	Z, r24
	pxTopOfStack--;
     3d4:	8b 81       	ldd	r24, Y+3	; 0x03
     3d6:	9c 81       	ldd	r25, Y+4	; 0x04
     3d8:	01 97       	sbiw	r24, 0x01	; 1
     3da:	9c 83       	std	Y+4, r25	; 0x04
     3dc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     3de:	8f 81       	ldd	r24, Y+7	; 0x07
     3e0:	98 85       	ldd	r25, Y+8	; 0x08
     3e2:	9a 83       	std	Y+2, r25	; 0x02
     3e4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3e6:	89 81       	ldd	r24, Y+1	; 0x01
     3e8:	eb 81       	ldd	r30, Y+3	; 0x03
     3ea:	fc 81       	ldd	r31, Y+4	; 0x04
     3ec:	80 83       	st	Z, r24
	pxTopOfStack--;
     3ee:	8b 81       	ldd	r24, Y+3	; 0x03
     3f0:	9c 81       	ldd	r25, Y+4	; 0x04
     3f2:	01 97       	sbiw	r24, 0x01	; 1
     3f4:	9c 83       	std	Y+4, r25	; 0x04
     3f6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     3f8:	89 81       	ldd	r24, Y+1	; 0x01
     3fa:	9a 81       	ldd	r25, Y+2	; 0x02
     3fc:	89 2f       	mov	r24, r25
     3fe:	99 27       	eor	r25, r25
     400:	9a 83       	std	Y+2, r25	; 0x02
     402:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     404:	89 81       	ldd	r24, Y+1	; 0x01
     406:	eb 81       	ldd	r30, Y+3	; 0x03
     408:	fc 81       	ldd	r31, Y+4	; 0x04
     40a:	80 83       	st	Z, r24
	pxTopOfStack--;
     40c:	8b 81       	ldd	r24, Y+3	; 0x03
     40e:	9c 81       	ldd	r25, Y+4	; 0x04
     410:	01 97       	sbiw	r24, 0x01	; 1
     412:	9c 83       	std	Y+4, r25	; 0x04
     414:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     416:	eb 81       	ldd	r30, Y+3	; 0x03
     418:	fc 81       	ldd	r31, Y+4	; 0x04
     41a:	86 e2       	ldi	r24, 0x26	; 38
     41c:	80 83       	st	Z, r24
	pxTopOfStack--;
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	9c 83       	std	Y+4, r25	; 0x04
     426:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     428:	eb 81       	ldd	r30, Y+3	; 0x03
     42a:	fc 81       	ldd	r31, Y+4	; 0x04
     42c:	87 e2       	ldi	r24, 0x27	; 39
     42e:	80 83       	st	Z, r24
	pxTopOfStack--;
     430:	8b 81       	ldd	r24, Y+3	; 0x03
     432:	9c 81       	ldd	r25, Y+4	; 0x04
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	9c 83       	std	Y+4, r25	; 0x04
     438:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     43a:	eb 81       	ldd	r30, Y+3	; 0x03
     43c:	fc 81       	ldd	r31, Y+4	; 0x04
     43e:	88 e2       	ldi	r24, 0x28	; 40
     440:	80 83       	st	Z, r24
	pxTopOfStack--;
     442:	8b 81       	ldd	r24, Y+3	; 0x03
     444:	9c 81       	ldd	r25, Y+4	; 0x04
     446:	01 97       	sbiw	r24, 0x01	; 1
     448:	9c 83       	std	Y+4, r25	; 0x04
     44a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     44c:	eb 81       	ldd	r30, Y+3	; 0x03
     44e:	fc 81       	ldd	r31, Y+4	; 0x04
     450:	89 e2       	ldi	r24, 0x29	; 41
     452:	80 83       	st	Z, r24
	pxTopOfStack--;
     454:	8b 81       	ldd	r24, Y+3	; 0x03
     456:	9c 81       	ldd	r25, Y+4	; 0x04
     458:	01 97       	sbiw	r24, 0x01	; 1
     45a:	9c 83       	std	Y+4, r25	; 0x04
     45c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     45e:	eb 81       	ldd	r30, Y+3	; 0x03
     460:	fc 81       	ldd	r31, Y+4	; 0x04
     462:	80 e3       	ldi	r24, 0x30	; 48
     464:	80 83       	st	Z, r24
	pxTopOfStack--;
     466:	8b 81       	ldd	r24, Y+3	; 0x03
     468:	9c 81       	ldd	r25, Y+4	; 0x04
     46a:	01 97       	sbiw	r24, 0x01	; 1
     46c:	9c 83       	std	Y+4, r25	; 0x04
     46e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     470:	eb 81       	ldd	r30, Y+3	; 0x03
     472:	fc 81       	ldd	r31, Y+4	; 0x04
     474:	81 e3       	ldi	r24, 0x31	; 49
     476:	80 83       	st	Z, r24
	pxTopOfStack--;
     478:	8b 81       	ldd	r24, Y+3	; 0x03
     47a:	9c 81       	ldd	r25, Y+4	; 0x04
     47c:	01 97       	sbiw	r24, 0x01	; 1
     47e:	9c 83       	std	Y+4, r25	; 0x04
     480:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     482:	8b 81       	ldd	r24, Y+3	; 0x03
     484:	9c 81       	ldd	r25, Y+4	; 0x04
}
     486:	28 96       	adiw	r28, 0x08	; 8
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	cf 91       	pop	r28
     494:	df 91       	pop	r29
     496:	08 95       	ret

00000498 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     498:	df 93       	push	r29
     49a:	cf 93       	push	r28
     49c:	cd b7       	in	r28, 0x3d	; 61
     49e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     4a0:	0e 94 3e 03 	call	0x67c	; 0x67c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4a4:	a0 91 4c 06 	lds	r26, 0x064C
     4a8:	b0 91 4d 06 	lds	r27, 0x064D
     4ac:	cd 91       	ld	r28, X+
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	dd 91       	ld	r29, X+
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	ff 91       	pop	r31
     4b6:	ef 91       	pop	r30
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	bf 91       	pop	r27
     4be:	af 91       	pop	r26
     4c0:	9f 91       	pop	r25
     4c2:	8f 91       	pop	r24
     4c4:	7f 91       	pop	r23
     4c6:	6f 91       	pop	r22
     4c8:	5f 91       	pop	r21
     4ca:	4f 91       	pop	r20
     4cc:	3f 91       	pop	r19
     4ce:	2f 91       	pop	r18
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	ff 90       	pop	r15
     4d6:	ef 90       	pop	r14
     4d8:	df 90       	pop	r13
     4da:	cf 90       	pop	r12
     4dc:	bf 90       	pop	r11
     4de:	af 90       	pop	r10
     4e0:	9f 90       	pop	r9
     4e2:	8f 90       	pop	r8
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	3f 90       	pop	r3
     4ee:	2f 90       	pop	r2
     4f0:	1f 90       	pop	r1
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     4fa:	81 e0       	ldi	r24, 0x01	; 1
}
     4fc:	cf 91       	pop	r28
     4fe:	df 91       	pop	r29
     500:	08 95       	ret

00000502 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     502:	df 93       	push	r29
     504:	cf 93       	push	r28
     506:	cd b7       	in	r28, 0x3d	; 61
     508:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     50a:	cf 91       	pop	r28
     50c:	df 91       	pop	r29
     50e:	08 95       	ret

00000510 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     510:	0f 92       	push	r0
     512:	0f b6       	in	r0, 0x3f	; 63
     514:	f8 94       	cli
     516:	0f 92       	push	r0
     518:	1f 92       	push	r1
     51a:	11 24       	eor	r1, r1
     51c:	2f 92       	push	r2
     51e:	3f 92       	push	r3
     520:	4f 92       	push	r4
     522:	5f 92       	push	r5
     524:	6f 92       	push	r6
     526:	7f 92       	push	r7
     528:	8f 92       	push	r8
     52a:	9f 92       	push	r9
     52c:	af 92       	push	r10
     52e:	bf 92       	push	r11
     530:	cf 92       	push	r12
     532:	df 92       	push	r13
     534:	ef 92       	push	r14
     536:	ff 92       	push	r15
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	2f 93       	push	r18
     53e:	3f 93       	push	r19
     540:	4f 93       	push	r20
     542:	5f 93       	push	r21
     544:	6f 93       	push	r22
     546:	7f 93       	push	r23
     548:	8f 93       	push	r24
     54a:	9f 93       	push	r25
     54c:	af 93       	push	r26
     54e:	bf 93       	push	r27
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	ef 93       	push	r30
     556:	ff 93       	push	r31
     558:	a0 91 4c 06 	lds	r26, 0x064C
     55c:	b0 91 4d 06 	lds	r27, 0x064D
     560:	0d b6       	in	r0, 0x3d	; 61
     562:	0d 92       	st	X+, r0
     564:	0e b6       	in	r0, 0x3e	; 62
     566:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     568:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     56c:	a0 91 4c 06 	lds	r26, 0x064C
     570:	b0 91 4d 06 	lds	r27, 0x064D
     574:	cd 91       	ld	r28, X+
     576:	cd bf       	out	0x3d, r28	; 61
     578:	dd 91       	ld	r29, X+
     57a:	de bf       	out	0x3e, r29	; 62
     57c:	ff 91       	pop	r31
     57e:	ef 91       	pop	r30
     580:	df 91       	pop	r29
     582:	cf 91       	pop	r28
     584:	bf 91       	pop	r27
     586:	af 91       	pop	r26
     588:	9f 91       	pop	r25
     58a:	8f 91       	pop	r24
     58c:	7f 91       	pop	r23
     58e:	6f 91       	pop	r22
     590:	5f 91       	pop	r21
     592:	4f 91       	pop	r20
     594:	3f 91       	pop	r19
     596:	2f 91       	pop	r18
     598:	1f 91       	pop	r17
     59a:	0f 91       	pop	r16
     59c:	ff 90       	pop	r15
     59e:	ef 90       	pop	r14
     5a0:	df 90       	pop	r13
     5a2:	cf 90       	pop	r12
     5a4:	bf 90       	pop	r11
     5a6:	af 90       	pop	r10
     5a8:	9f 90       	pop	r9
     5aa:	8f 90       	pop	r8
     5ac:	7f 90       	pop	r7
     5ae:	6f 90       	pop	r6
     5b0:	5f 90       	pop	r5
     5b2:	4f 90       	pop	r4
     5b4:	3f 90       	pop	r3
     5b6:	2f 90       	pop	r2
     5b8:	1f 90       	pop	r1
     5ba:	0f 90       	pop	r0
     5bc:	0f be       	out	0x3f, r0	; 63
     5be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5c0:	08 95       	ret

000005c2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	f8 94       	cli
     5c8:	0f 92       	push	r0
     5ca:	1f 92       	push	r1
     5cc:	11 24       	eor	r1, r1
     5ce:	2f 92       	push	r2
     5d0:	3f 92       	push	r3
     5d2:	4f 92       	push	r4
     5d4:	5f 92       	push	r5
     5d6:	6f 92       	push	r6
     5d8:	7f 92       	push	r7
     5da:	8f 92       	push	r8
     5dc:	9f 92       	push	r9
     5de:	af 92       	push	r10
     5e0:	bf 92       	push	r11
     5e2:	cf 92       	push	r12
     5e4:	df 92       	push	r13
     5e6:	ef 92       	push	r14
     5e8:	ff 92       	push	r15
     5ea:	0f 93       	push	r16
     5ec:	1f 93       	push	r17
     5ee:	2f 93       	push	r18
     5f0:	3f 93       	push	r19
     5f2:	4f 93       	push	r20
     5f4:	5f 93       	push	r21
     5f6:	6f 93       	push	r22
     5f8:	7f 93       	push	r23
     5fa:	8f 93       	push	r24
     5fc:	9f 93       	push	r25
     5fe:	af 93       	push	r26
     600:	bf 93       	push	r27
     602:	cf 93       	push	r28
     604:	df 93       	push	r29
     606:	ef 93       	push	r30
     608:	ff 93       	push	r31
     60a:	a0 91 4c 06 	lds	r26, 0x064C
     60e:	b0 91 4d 06 	lds	r27, 0x064D
     612:	0d b6       	in	r0, 0x3d	; 61
     614:	0d 92       	st	X+, r0
     616:	0e b6       	in	r0, 0x3e	; 62
     618:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     61a:	0e 94 b6 1c 	call	0x396c	; 0x396c <xTaskIncrementTick>
     61e:	88 23       	and	r24, r24
     620:	11 f0       	breq	.+4      	; 0x626 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     622:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     626:	a0 91 4c 06 	lds	r26, 0x064C
     62a:	b0 91 4d 06 	lds	r27, 0x064D
     62e:	cd 91       	ld	r28, X+
     630:	cd bf       	out	0x3d, r28	; 61
     632:	dd 91       	ld	r29, X+
     634:	de bf       	out	0x3e, r29	; 62
     636:	ff 91       	pop	r31
     638:	ef 91       	pop	r30
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	bf 91       	pop	r27
     640:	af 91       	pop	r26
     642:	9f 91       	pop	r25
     644:	8f 91       	pop	r24
     646:	7f 91       	pop	r23
     648:	6f 91       	pop	r22
     64a:	5f 91       	pop	r21
     64c:	4f 91       	pop	r20
     64e:	3f 91       	pop	r19
     650:	2f 91       	pop	r18
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	cf 90       	pop	r12
     65e:	bf 90       	pop	r11
     660:	af 90       	pop	r10
     662:	9f 90       	pop	r9
     664:	8f 90       	pop	r8
     666:	7f 90       	pop	r7
     668:	6f 90       	pop	r6
     66a:	5f 90       	pop	r5
     66c:	4f 90       	pop	r4
     66e:	3f 90       	pop	r3
     670:	2f 90       	pop	r2
     672:	1f 90       	pop	r1
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
     678:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67a:	08 95       	ret

0000067c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     67c:	df 93       	push	r29
     67e:	cf 93       	push	r28
     680:	00 d0       	rcall	.+0      	; 0x682 <prvSetupTimerInterrupt+0x6>
     682:	00 d0       	rcall	.+0      	; 0x684 <prvSetupTimerInterrupt+0x8>
     684:	00 d0       	rcall	.+0      	; 0x686 <prvSetupTimerInterrupt+0xa>
     686:	cd b7       	in	r28, 0x3d	; 61
     688:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     68a:	80 e8       	ldi	r24, 0x80	; 128
     68c:	9e e3       	ldi	r25, 0x3E	; 62
     68e:	a0 e0       	ldi	r26, 0x00	; 0
     690:	b0 e0       	ldi	r27, 0x00	; 0
     692:	8b 83       	std	Y+3, r24	; 0x03
     694:	9c 83       	std	Y+4, r25	; 0x04
     696:	ad 83       	std	Y+5, r26	; 0x05
     698:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     69a:	8b 81       	ldd	r24, Y+3	; 0x03
     69c:	9c 81       	ldd	r25, Y+4	; 0x04
     69e:	ad 81       	ldd	r26, Y+5	; 0x05
     6a0:	be 81       	ldd	r27, Y+6	; 0x06
     6a2:	68 94       	set
     6a4:	15 f8       	bld	r1, 5
     6a6:	b6 95       	lsr	r27
     6a8:	a7 95       	ror	r26
     6aa:	97 95       	ror	r25
     6ac:	87 95       	ror	r24
     6ae:	16 94       	lsr	r1
     6b0:	d1 f7       	brne	.-12     	; 0x6a6 <prvSetupTimerInterrupt+0x2a>
     6b2:	8b 83       	std	Y+3, r24	; 0x03
     6b4:	9c 83       	std	Y+4, r25	; 0x04
     6b6:	ad 83       	std	Y+5, r26	; 0x05
     6b8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     6ba:	8b 81       	ldd	r24, Y+3	; 0x03
     6bc:	9c 81       	ldd	r25, Y+4	; 0x04
     6be:	ad 81       	ldd	r26, Y+5	; 0x05
     6c0:	be 81       	ldd	r27, Y+6	; 0x06
     6c2:	01 97       	sbiw	r24, 0x01	; 1
     6c4:	a1 09       	sbc	r26, r1
     6c6:	b1 09       	sbc	r27, r1
     6c8:	8b 83       	std	Y+3, r24	; 0x03
     6ca:	9c 83       	std	Y+4, r25	; 0x04
     6cc:	ad 83       	std	Y+5, r26	; 0x05
     6ce:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6d0:	8b 81       	ldd	r24, Y+3	; 0x03
     6d2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     6d4:	8b 81       	ldd	r24, Y+3	; 0x03
     6d6:	9c 81       	ldd	r25, Y+4	; 0x04
     6d8:	ad 81       	ldd	r26, Y+5	; 0x05
     6da:	be 81       	ldd	r27, Y+6	; 0x06
     6dc:	89 2f       	mov	r24, r25
     6de:	9a 2f       	mov	r25, r26
     6e0:	ab 2f       	mov	r26, r27
     6e2:	bb 27       	eor	r27, r27
     6e4:	8b 83       	std	Y+3, r24	; 0x03
     6e6:	9c 83       	std	Y+4, r25	; 0x04
     6e8:	ad 83       	std	Y+5, r26	; 0x05
     6ea:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6ec:	8b 81       	ldd	r24, Y+3	; 0x03
     6ee:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     6f0:	eb e4       	ldi	r30, 0x4B	; 75
     6f2:	f0 e0       	ldi	r31, 0x00	; 0
     6f4:	8a 81       	ldd	r24, Y+2	; 0x02
     6f6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     6f8:	ea e4       	ldi	r30, 0x4A	; 74
     6fa:	f0 e0       	ldi	r31, 0x00	; 0
     6fc:	89 81       	ldd	r24, Y+1	; 0x01
     6fe:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     700:	8b e0       	ldi	r24, 0x0B	; 11
     702:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     704:	ee e4       	ldi	r30, 0x4E	; 78
     706:	f0 e0       	ldi	r31, 0x00	; 0
     708:	89 81       	ldd	r24, Y+1	; 0x01
     70a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     70c:	e9 e5       	ldi	r30, 0x59	; 89
     70e:	f0 e0       	ldi	r31, 0x00	; 0
     710:	80 81       	ld	r24, Z
     712:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     714:	89 81       	ldd	r24, Y+1	; 0x01
     716:	80 61       	ori	r24, 0x10	; 16
     718:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     71a:	e9 e5       	ldi	r30, 0x59	; 89
     71c:	f0 e0       	ldi	r31, 0x00	; 0
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	80 83       	st	Z, r24
}
     722:	26 96       	adiw	r28, 0x06	; 6
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	de bf       	out	0x3e, r29	; 62
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	cf 91       	pop	r28
     730:	df 91       	pop	r29
     732:	08 95       	ret

00000734 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     734:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti

0000073a <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
     73a:	df 93       	push	r29
     73c:	cf 93       	push	r28
     73e:	00 d0       	rcall	.+0      	; 0x740 <xEventGroupCreate+0x6>
     740:	cd b7       	in	r28, 0x3d	; 61
     742:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     744:	8b e0       	ldi	r24, 0x0B	; 11
     746:	90 e0       	ldi	r25, 0x00	; 0
     748:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     74c:	9a 83       	std	Y+2, r25	; 0x02
     74e:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
     750:	89 81       	ldd	r24, Y+1	; 0x01
     752:	9a 81       	ldd	r25, Y+2	; 0x02
     754:	00 97       	sbiw	r24, 0x00	; 0
     756:	49 f0       	breq	.+18     	; 0x76a <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
     758:	e9 81       	ldd	r30, Y+1	; 0x01
     75a:	fa 81       	ldd	r31, Y+2	; 0x02
     75c:	11 82       	std	Z+1, r1	; 0x01
     75e:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     760:	89 81       	ldd	r24, Y+1	; 0x01
     762:	9a 81       	ldd	r25, Y+2	; 0x02
     764:	02 96       	adiw	r24, 0x02	; 2
     766:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
     76a:	89 81       	ldd	r24, Y+1	; 0x01
     76c:	9a 81       	ldd	r25, Y+2	; 0x02
    }
     76e:	0f 90       	pop	r0
     770:	0f 90       	pop	r0
     772:	cf 91       	pop	r28
     774:	df 91       	pop	r29
     776:	08 95       	ret

00000778 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
     778:	df 93       	push	r29
     77a:	cf 93       	push	r28
     77c:	cd b7       	in	r28, 0x3d	; 61
     77e:	de b7       	in	r29, 0x3e	; 62
     780:	60 97       	sbiw	r28, 0x10	; 16
     782:	0f b6       	in	r0, 0x3f	; 63
     784:	f8 94       	cli
     786:	de bf       	out	0x3e, r29	; 62
     788:	0f be       	out	0x3f, r0	; 63
     78a:	cd bf       	out	0x3d, r28	; 61
     78c:	9a 87       	std	Y+10, r25	; 0x0a
     78e:	89 87       	std	Y+9, r24	; 0x09
     790:	7c 87       	std	Y+12, r23	; 0x0c
     792:	6b 87       	std	Y+11, r22	; 0x0b
     794:	5e 87       	std	Y+14, r21	; 0x0e
     796:	4d 87       	std	Y+13, r20	; 0x0d
     798:	38 8b       	std	Y+16, r19	; 0x10
     79a:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
     79c:	89 85       	ldd	r24, Y+9	; 0x09
     79e:	9a 85       	ldd	r25, Y+10	; 0x0a
     7a0:	9c 83       	std	Y+4, r25	; 0x04
     7a2:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
     7a4:	19 82       	std	Y+1, r1	; 0x01
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
     7a6:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
     7aa:	eb 81       	ldd	r30, Y+3	; 0x03
     7ac:	fc 81       	ldd	r31, Y+4	; 0x04
     7ae:	80 81       	ld	r24, Z
     7b0:	91 81       	ldd	r25, Z+1	; 0x01
     7b2:	98 87       	std	Y+8, r25	; 0x08
     7b4:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     7b6:	89 85       	ldd	r24, Y+9	; 0x09
     7b8:	9a 85       	ldd	r25, Y+10	; 0x0a
     7ba:	2b 85       	ldd	r18, Y+11	; 0x0b
     7bc:	3c 85       	ldd	r19, Y+12	; 0x0c
     7be:	b9 01       	movw	r22, r18
     7c0:	0e 94 93 05 	call	0xb26	; 0xb26 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     7c4:	2f 81       	ldd	r18, Y+7	; 0x07
     7c6:	38 85       	ldd	r19, Y+8	; 0x08
     7c8:	8b 85       	ldd	r24, Y+11	; 0x0b
     7ca:	9c 85       	ldd	r25, Y+12	; 0x0c
     7cc:	28 2b       	or	r18, r24
     7ce:	39 2b       	or	r19, r25
     7d0:	8d 85       	ldd	r24, Y+13	; 0x0d
     7d2:	9e 85       	ldd	r25, Y+14	; 0x0e
     7d4:	28 23       	and	r18, r24
     7d6:	39 23       	and	r19, r25
     7d8:	8d 85       	ldd	r24, Y+13	; 0x0d
     7da:	9e 85       	ldd	r25, Y+14	; 0x0e
     7dc:	28 17       	cp	r18, r24
     7de:	39 07       	cpc	r19, r25
     7e0:	c9 f4       	brne	.+50     	; 0x814 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     7e2:	2f 81       	ldd	r18, Y+7	; 0x07
     7e4:	38 85       	ldd	r19, Y+8	; 0x08
     7e6:	8b 85       	ldd	r24, Y+11	; 0x0b
     7e8:	9c 85       	ldd	r25, Y+12	; 0x0c
     7ea:	82 2b       	or	r24, r18
     7ec:	93 2b       	or	r25, r19
     7ee:	9e 83       	std	Y+6, r25	; 0x06
     7f0:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     7f2:	eb 81       	ldd	r30, Y+3	; 0x03
     7f4:	fc 81       	ldd	r31, Y+4	; 0x04
     7f6:	20 81       	ld	r18, Z
     7f8:	31 81       	ldd	r19, Z+1	; 0x01
     7fa:	8d 85       	ldd	r24, Y+13	; 0x0d
     7fc:	9e 85       	ldd	r25, Y+14	; 0x0e
     7fe:	80 95       	com	r24
     800:	90 95       	com	r25
     802:	82 23       	and	r24, r18
     804:	93 23       	and	r25, r19
     806:	eb 81       	ldd	r30, Y+3	; 0x03
     808:	fc 81       	ldd	r31, Y+4	; 0x04
     80a:	91 83       	std	Z+1, r25	; 0x01
     80c:	80 83       	st	Z, r24

            xTicksToWait = 0;
     80e:	18 8a       	std	Y+16, r1	; 0x10
     810:	1f 86       	std	Y+15, r1	; 0x0f
     812:	1e c0       	rjmp	.+60     	; 0x850 <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
     814:	8f 85       	ldd	r24, Y+15	; 0x0f
     816:	98 89       	ldd	r25, Y+16	; 0x10
     818:	00 97       	sbiw	r24, 0x00	; 0
     81a:	91 f0       	breq	.+36     	; 0x840 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     81c:	8b 81       	ldd	r24, Y+3	; 0x03
     81e:	9c 81       	ldd	r25, Y+4	; 0x04
     820:	bc 01       	movw	r22, r24
     822:	6e 5f       	subi	r22, 0xFE	; 254
     824:	7f 4f       	sbci	r23, 0xFF	; 255
     826:	8d 85       	ldd	r24, Y+13	; 0x0d
     828:	9e 85       	ldd	r25, Y+14	; 0x0e
     82a:	9c 01       	movw	r18, r24
     82c:	35 60       	ori	r19, 0x05	; 5
     82e:	4f 85       	ldd	r20, Y+15	; 0x0f
     830:	58 89       	ldd	r21, Y+16	; 0x10
     832:	cb 01       	movw	r24, r22
     834:	b9 01       	movw	r22, r18
     836:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
     83a:	1e 82       	std	Y+6, r1	; 0x06
     83c:	1d 82       	std	Y+5, r1	; 0x05
     83e:	08 c0       	rjmp	.+16     	; 0x850 <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     840:	eb 81       	ldd	r30, Y+3	; 0x03
     842:	fc 81       	ldd	r31, Y+4	; 0x04
     844:	80 81       	ld	r24, Z
     846:	91 81       	ldd	r25, Z+1	; 0x01
     848:	9e 83       	std	Y+6, r25	; 0x06
     84a:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
     84c:	81 e0       	ldi	r24, 0x01	; 1
     84e:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     850:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
     854:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
     856:	8f 85       	ldd	r24, Y+15	; 0x0f
     858:	98 89       	ldd	r25, Y+16	; 0x10
     85a:	00 97       	sbiw	r24, 0x00	; 0
     85c:	09 f4       	brne	.+2      	; 0x860 <__stack+0x1>
     85e:	3a c0       	rjmp	.+116    	; 0x8d4 <__stack+0x75>
    {
        if( xAlreadyYielded == pdFALSE )
     860:	8a 81       	ldd	r24, Y+2	; 0x02
     862:	88 23       	and	r24, r24
     864:	11 f4       	brne	.+4      	; 0x86a <__stack+0xb>
        {
            portYIELD_WITHIN_API();
     866:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     86a:	0e 94 01 23 	call	0x4602	; 0x4602 <uxTaskResetEventItemValue>
     86e:	9e 83       	std	Y+6, r25	; 0x06
     870:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     872:	8d 81       	ldd	r24, Y+5	; 0x05
     874:	9e 81       	ldd	r25, Y+6	; 0x06
     876:	80 70       	andi	r24, 0x00	; 0
     878:	92 70       	andi	r25, 0x02	; 2
     87a:	00 97       	sbiw	r24, 0x00	; 0
     87c:	31 f5       	brne	.+76     	; 0x8ca <__stack+0x6b>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
     87e:	0f b6       	in	r0, 0x3f	; 63
     880:	f8 94       	cli
     882:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
     884:	eb 81       	ldd	r30, Y+3	; 0x03
     886:	fc 81       	ldd	r31, Y+4	; 0x04
     888:	80 81       	ld	r24, Z
     88a:	91 81       	ldd	r25, Z+1	; 0x01
     88c:	9e 83       	std	Y+6, r25	; 0x06
     88e:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     890:	2d 81       	ldd	r18, Y+5	; 0x05
     892:	3e 81       	ldd	r19, Y+6	; 0x06
     894:	8d 85       	ldd	r24, Y+13	; 0x0d
     896:	9e 85       	ldd	r25, Y+14	; 0x0e
     898:	28 23       	and	r18, r24
     89a:	39 23       	and	r19, r25
     89c:	8d 85       	ldd	r24, Y+13	; 0x0d
     89e:	9e 85       	ldd	r25, Y+14	; 0x0e
     8a0:	28 17       	cp	r18, r24
     8a2:	39 07       	cpc	r19, r25
     8a4:	71 f4       	brne	.+28     	; 0x8c2 <__stack+0x63>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     8a6:	eb 81       	ldd	r30, Y+3	; 0x03
     8a8:	fc 81       	ldd	r31, Y+4	; 0x04
     8aa:	20 81       	ld	r18, Z
     8ac:	31 81       	ldd	r19, Z+1	; 0x01
     8ae:	8d 85       	ldd	r24, Y+13	; 0x0d
     8b0:	9e 85       	ldd	r25, Y+14	; 0x0e
     8b2:	80 95       	com	r24
     8b4:	90 95       	com	r25
     8b6:	82 23       	and	r24, r18
     8b8:	93 23       	and	r25, r19
     8ba:	eb 81       	ldd	r30, Y+3	; 0x03
     8bc:	fc 81       	ldd	r31, Y+4	; 0x04
     8be:	91 83       	std	Z+1, r25	; 0x01
     8c0:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
     8c2:	0f 90       	pop	r0
     8c4:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
     8c6:	81 e0       	ldi	r24, 0x01	; 1
     8c8:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     8ca:	8d 81       	ldd	r24, Y+5	; 0x05
     8cc:	9e 81       	ldd	r25, Y+6	; 0x06
     8ce:	90 70       	andi	r25, 0x00	; 0
     8d0:	9e 83       	std	Y+6, r25	; 0x06
     8d2:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
     8d4:	8d 81       	ldd	r24, Y+5	; 0x05
     8d6:	9e 81       	ldd	r25, Y+6	; 0x06
}
     8d8:	60 96       	adiw	r28, 0x10	; 16
     8da:	0f b6       	in	r0, 0x3f	; 63
     8dc:	f8 94       	cli
     8de:	de bf       	out	0x3e, r29	; 62
     8e0:	0f be       	out	0x3f, r0	; 63
     8e2:	cd bf       	out	0x3d, r28	; 61
     8e4:	cf 91       	pop	r28
     8e6:	df 91       	pop	r29
     8e8:	08 95       	ret

000008ea <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
     8ea:	0f 93       	push	r16
     8ec:	1f 93       	push	r17
     8ee:	df 93       	push	r29
     8f0:	cf 93       	push	r28
     8f2:	cd b7       	in	r28, 0x3d	; 61
     8f4:	de b7       	in	r29, 0x3e	; 62
     8f6:	63 97       	sbiw	r28, 0x13	; 19
     8f8:	0f b6       	in	r0, 0x3f	; 63
     8fa:	f8 94       	cli
     8fc:	de bf       	out	0x3e, r29	; 62
     8fe:	0f be       	out	0x3f, r0	; 63
     900:	cd bf       	out	0x3d, r28	; 61
     902:	9d 87       	std	Y+13, r25	; 0x0d
     904:	8c 87       	std	Y+12, r24	; 0x0c
     906:	7f 87       	std	Y+15, r23	; 0x0f
     908:	6e 87       	std	Y+14, r22	; 0x0e
     90a:	48 8b       	std	Y+16, r20	; 0x10
     90c:	29 8b       	std	Y+17, r18	; 0x11
     90e:	1b 8b       	std	Y+19, r17	; 0x13
     910:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
     912:	8c 85       	ldd	r24, Y+12	; 0x0c
     914:	9d 85       	ldd	r25, Y+13	; 0x0d
     916:	9b 87       	std	Y+11, r25	; 0x0b
     918:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
     91a:	1f 82       	std	Y+7, r1	; 0x07
     91c:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
     91e:	1b 82       	std	Y+3, r1	; 0x03
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
     920:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     924:	ea 85       	ldd	r30, Y+10	; 0x0a
     926:	fb 85       	ldd	r31, Y+11	; 0x0b
     928:	80 81       	ld	r24, Z
     92a:	91 81       	ldd	r25, Z+1	; 0x01
     92c:	9a 83       	std	Y+2, r25	; 0x02
     92e:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     930:	89 81       	ldd	r24, Y+1	; 0x01
     932:	9a 81       	ldd	r25, Y+2	; 0x02
     934:	2e 85       	ldd	r18, Y+14	; 0x0e
     936:	3f 85       	ldd	r19, Y+15	; 0x0f
     938:	b9 01       	movw	r22, r18
     93a:	49 89       	ldd	r20, Y+17	; 0x11
     93c:	0e 94 b0 06 	call	0xd60	; 0xd60 <prvTestWaitCondition>
     940:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
     942:	8d 81       	ldd	r24, Y+5	; 0x05
     944:	88 23       	and	r24, r24
     946:	c1 f0       	breq	.+48     	; 0x978 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
     948:	89 81       	ldd	r24, Y+1	; 0x01
     94a:	9a 81       	ldd	r25, Y+2	; 0x02
     94c:	99 87       	std	Y+9, r25	; 0x09
     94e:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
     950:	1b 8a       	std	Y+19, r1	; 0x13
     952:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
     954:	88 89       	ldd	r24, Y+16	; 0x10
     956:	88 23       	and	r24, r24
     958:	e9 f1       	breq	.+122    	; 0x9d4 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     95a:	ea 85       	ldd	r30, Y+10	; 0x0a
     95c:	fb 85       	ldd	r31, Y+11	; 0x0b
     95e:	20 81       	ld	r18, Z
     960:	31 81       	ldd	r19, Z+1	; 0x01
     962:	8e 85       	ldd	r24, Y+14	; 0x0e
     964:	9f 85       	ldd	r25, Y+15	; 0x0f
     966:	80 95       	com	r24
     968:	90 95       	com	r25
     96a:	82 23       	and	r24, r18
     96c:	93 23       	and	r25, r19
     96e:	ea 85       	ldd	r30, Y+10	; 0x0a
     970:	fb 85       	ldd	r31, Y+11	; 0x0b
     972:	91 83       	std	Z+1, r25	; 0x01
     974:	80 83       	st	Z, r24
     976:	2e c0       	rjmp	.+92     	; 0x9d4 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
     978:	8a 89       	ldd	r24, Y+18	; 0x12
     97a:	9b 89       	ldd	r25, Y+19	; 0x13
     97c:	00 97       	sbiw	r24, 0x00	; 0
     97e:	39 f4       	brne	.+14     	; 0x98e <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
     980:	89 81       	ldd	r24, Y+1	; 0x01
     982:	9a 81       	ldd	r25, Y+2	; 0x02
     984:	99 87       	std	Y+9, r25	; 0x09
     986:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
     988:	81 e0       	ldi	r24, 0x01	; 1
     98a:	8b 83       	std	Y+3, r24	; 0x03
     98c:	23 c0       	rjmp	.+70     	; 0x9d4 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
     98e:	88 89       	ldd	r24, Y+16	; 0x10
     990:	88 23       	and	r24, r24
     992:	29 f0       	breq	.+10     	; 0x99e <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     994:	8e 81       	ldd	r24, Y+6	; 0x06
     996:	9f 81       	ldd	r25, Y+7	; 0x07
     998:	91 60       	ori	r25, 0x01	; 1
     99a:	9f 83       	std	Y+7, r25	; 0x07
     99c:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
     99e:	89 89       	ldd	r24, Y+17	; 0x11
     9a0:	88 23       	and	r24, r24
     9a2:	29 f0       	breq	.+10     	; 0x9ae <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
     9a4:	8e 81       	ldd	r24, Y+6	; 0x06
     9a6:	9f 81       	ldd	r25, Y+7	; 0x07
     9a8:	94 60       	ori	r25, 0x04	; 4
     9aa:	9f 83       	std	Y+7, r25	; 0x07
     9ac:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     9ae:	8a 85       	ldd	r24, Y+10	; 0x0a
     9b0:	9b 85       	ldd	r25, Y+11	; 0x0b
     9b2:	bc 01       	movw	r22, r24
     9b4:	6e 5f       	subi	r22, 0xFE	; 254
     9b6:	7f 4f       	sbci	r23, 0xFF	; 255
     9b8:	2e 85       	ldd	r18, Y+14	; 0x0e
     9ba:	3f 85       	ldd	r19, Y+15	; 0x0f
     9bc:	8e 81       	ldd	r24, Y+6	; 0x06
     9be:	9f 81       	ldd	r25, Y+7	; 0x07
     9c0:	28 2b       	or	r18, r24
     9c2:	39 2b       	or	r19, r25
     9c4:	4a 89       	ldd	r20, Y+18	; 0x12
     9c6:	5b 89       	ldd	r21, Y+19	; 0x13
     9c8:	cb 01       	movw	r24, r22
     9ca:	b9 01       	movw	r22, r18
     9cc:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
     9d0:	19 86       	std	Y+9, r1	; 0x09
     9d2:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     9d4:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
     9d8:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
     9da:	8a 89       	ldd	r24, Y+18	; 0x12
     9dc:	9b 89       	ldd	r25, Y+19	; 0x13
     9de:	00 97       	sbiw	r24, 0x00	; 0
     9e0:	09 f4       	brne	.+2      	; 0x9e4 <xEventGroupWaitBits+0xfa>
     9e2:	3c c0       	rjmp	.+120    	; 0xa5c <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
     9e4:	8c 81       	ldd	r24, Y+4	; 0x04
     9e6:	88 23       	and	r24, r24
     9e8:	11 f4       	brne	.+4      	; 0x9ee <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
     9ea:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     9ee:	0e 94 01 23 	call	0x4602	; 0x4602 <uxTaskResetEventItemValue>
     9f2:	99 87       	std	Y+9, r25	; 0x09
     9f4:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     9f6:	88 85       	ldd	r24, Y+8	; 0x08
     9f8:	99 85       	ldd	r25, Y+9	; 0x09
     9fa:	80 70       	andi	r24, 0x00	; 0
     9fc:	92 70       	andi	r25, 0x02	; 2
     9fe:	00 97       	sbiw	r24, 0x00	; 0
     a00:	41 f5       	brne	.+80     	; 0xa52 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
     a02:	0f b6       	in	r0, 0x3f	; 63
     a04:	f8 94       	cli
     a06:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     a08:	ea 85       	ldd	r30, Y+10	; 0x0a
     a0a:	fb 85       	ldd	r31, Y+11	; 0x0b
     a0c:	80 81       	ld	r24, Z
     a0e:	91 81       	ldd	r25, Z+1	; 0x01
     a10:	99 87       	std	Y+9, r25	; 0x09
     a12:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     a14:	88 85       	ldd	r24, Y+8	; 0x08
     a16:	99 85       	ldd	r25, Y+9	; 0x09
     a18:	2e 85       	ldd	r18, Y+14	; 0x0e
     a1a:	3f 85       	ldd	r19, Y+15	; 0x0f
     a1c:	b9 01       	movw	r22, r18
     a1e:	49 89       	ldd	r20, Y+17	; 0x11
     a20:	0e 94 b0 06 	call	0xd60	; 0xd60 <prvTestWaitCondition>
     a24:	88 23       	and	r24, r24
     a26:	89 f0       	breq	.+34     	; 0xa4a <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
     a28:	88 89       	ldd	r24, Y+16	; 0x10
     a2a:	88 23       	and	r24, r24
     a2c:	71 f0       	breq	.+28     	; 0xa4a <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     a2e:	ea 85       	ldd	r30, Y+10	; 0x0a
     a30:	fb 85       	ldd	r31, Y+11	; 0x0b
     a32:	20 81       	ld	r18, Z
     a34:	31 81       	ldd	r19, Z+1	; 0x01
     a36:	8e 85       	ldd	r24, Y+14	; 0x0e
     a38:	9f 85       	ldd	r25, Y+15	; 0x0f
     a3a:	80 95       	com	r24
     a3c:	90 95       	com	r25
     a3e:	82 23       	and	r24, r18
     a40:	93 23       	and	r25, r19
     a42:	ea 85       	ldd	r30, Y+10	; 0x0a
     a44:	fb 85       	ldd	r31, Y+11	; 0x0b
     a46:	91 83       	std	Z+1, r25	; 0x01
     a48:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
     a4a:	81 e0       	ldi	r24, 0x01	; 1
     a4c:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
     a4e:	0f 90       	pop	r0
     a50:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     a52:	88 85       	ldd	r24, Y+8	; 0x08
     a54:	99 85       	ldd	r25, Y+9	; 0x09
     a56:	90 70       	andi	r25, 0x00	; 0
     a58:	99 87       	std	Y+9, r25	; 0x09
     a5a:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
     a5c:	88 85       	ldd	r24, Y+8	; 0x08
     a5e:	99 85       	ldd	r25, Y+9	; 0x09
}
     a60:	63 96       	adiw	r28, 0x13	; 19
     a62:	0f b6       	in	r0, 0x3f	; 63
     a64:	f8 94       	cli
     a66:	de bf       	out	0x3e, r29	; 62
     a68:	0f be       	out	0x3f, r0	; 63
     a6a:	cd bf       	out	0x3d, r28	; 61
     a6c:	cf 91       	pop	r28
     a6e:	df 91       	pop	r29
     a70:	1f 91       	pop	r17
     a72:	0f 91       	pop	r16
     a74:	08 95       	ret

00000a76 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
     a76:	df 93       	push	r29
     a78:	cf 93       	push	r28
     a7a:	cd b7       	in	r28, 0x3d	; 61
     a7c:	de b7       	in	r29, 0x3e	; 62
     a7e:	28 97       	sbiw	r28, 0x08	; 8
     a80:	0f b6       	in	r0, 0x3f	; 63
     a82:	f8 94       	cli
     a84:	de bf       	out	0x3e, r29	; 62
     a86:	0f be       	out	0x3f, r0	; 63
     a88:	cd bf       	out	0x3d, r28	; 61
     a8a:	9e 83       	std	Y+6, r25	; 0x06
     a8c:	8d 83       	std	Y+5, r24	; 0x05
     a8e:	78 87       	std	Y+8, r23	; 0x08
     a90:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
     a92:	8d 81       	ldd	r24, Y+5	; 0x05
     a94:	9e 81       	ldd	r25, Y+6	; 0x06
     a96:	9c 83       	std	Y+4, r25	; 0x04
     a98:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
     a9a:	0f b6       	in	r0, 0x3f	; 63
     a9c:	f8 94       	cli
     a9e:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
     aa0:	eb 81       	ldd	r30, Y+3	; 0x03
     aa2:	fc 81       	ldd	r31, Y+4	; 0x04
     aa4:	80 81       	ld	r24, Z
     aa6:	91 81       	ldd	r25, Z+1	; 0x01
     aa8:	9a 83       	std	Y+2, r25	; 0x02
     aaa:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
     aac:	eb 81       	ldd	r30, Y+3	; 0x03
     aae:	fc 81       	ldd	r31, Y+4	; 0x04
     ab0:	20 81       	ld	r18, Z
     ab2:	31 81       	ldd	r19, Z+1	; 0x01
     ab4:	8f 81       	ldd	r24, Y+7	; 0x07
     ab6:	98 85       	ldd	r25, Y+8	; 0x08
     ab8:	80 95       	com	r24
     aba:	90 95       	com	r25
     abc:	82 23       	and	r24, r18
     abe:	93 23       	and	r25, r19
     ac0:	eb 81       	ldd	r30, Y+3	; 0x03
     ac2:	fc 81       	ldd	r31, Y+4	; 0x04
     ac4:	91 83       	std	Z+1, r25	; 0x01
     ac6:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
     ac8:	0f 90       	pop	r0
     aca:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
     acc:	89 81       	ldd	r24, Y+1	; 0x01
     ace:	9a 81       	ldd	r25, Y+2	; 0x02
}
     ad0:	28 96       	adiw	r28, 0x08	; 8
     ad2:	0f b6       	in	r0, 0x3f	; 63
     ad4:	f8 94       	cli
     ad6:	de bf       	out	0x3e, r29	; 62
     ad8:	0f be       	out	0x3f, r0	; 63
     ada:	cd bf       	out	0x3d, r28	; 61
     adc:	cf 91       	pop	r28
     ade:	df 91       	pop	r29
     ae0:	08 95       	ret

00000ae2 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     ae2:	df 93       	push	r29
     ae4:	cf 93       	push	r28
     ae6:	cd b7       	in	r28, 0x3d	; 61
     ae8:	de b7       	in	r29, 0x3e	; 62
     aea:	27 97       	sbiw	r28, 0x07	; 7
     aec:	0f b6       	in	r0, 0x3f	; 63
     aee:	f8 94       	cli
     af0:	de bf       	out	0x3e, r29	; 62
     af2:	0f be       	out	0x3f, r0	; 63
     af4:	cd bf       	out	0x3d, r28	; 61
     af6:	9f 83       	std	Y+7, r25	; 0x07
     af8:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
     afa:	8e 81       	ldd	r24, Y+6	; 0x06
     afc:	9f 81       	ldd	r25, Y+7	; 0x07
     afe:	9c 83       	std	Y+4, r25	; 0x04
     b00:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     b02:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
     b04:	eb 81       	ldd	r30, Y+3	; 0x03
     b06:	fc 81       	ldd	r31, Y+4	; 0x04
     b08:	80 81       	ld	r24, Z
     b0a:	91 81       	ldd	r25, Z+1	; 0x01
     b0c:	9a 83       	std	Y+2, r25	; 0x02
     b0e:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
     b10:	89 81       	ldd	r24, Y+1	; 0x01
     b12:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     b14:	27 96       	adiw	r28, 0x07	; 7
     b16:	0f b6       	in	r0, 0x3f	; 63
     b18:	f8 94       	cli
     b1a:	de bf       	out	0x3e, r29	; 62
     b1c:	0f be       	out	0x3f, r0	; 63
     b1e:	cd bf       	out	0x3d, r28	; 61
     b20:	cf 91       	pop	r28
     b22:	df 91       	pop	r29
     b24:	08 95       	ret

00000b26 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
     b26:	df 93       	push	r29
     b28:	cf 93       	push	r28
     b2a:	cd b7       	in	r28, 0x3d	; 61
     b2c:	de b7       	in	r29, 0x3e	; 62
     b2e:	65 97       	sbiw	r28, 0x15	; 21
     b30:	0f b6       	in	r0, 0x3f	; 63
     b32:	f8 94       	cli
     b34:	de bf       	out	0x3e, r29	; 62
     b36:	0f be       	out	0x3f, r0	; 63
     b38:	cd bf       	out	0x3d, r28	; 61
     b3a:	9b 8b       	std	Y+19, r25	; 0x13
     b3c:	8a 8b       	std	Y+18, r24	; 0x12
     b3e:	7d 8b       	std	Y+21, r23	; 0x15
     b40:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem;
    ListItem_t * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     b42:	19 86       	std	Y+9, r1	; 0x09
     b44:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
     b46:	8a 89       	ldd	r24, Y+18	; 0x12
     b48:	9b 89       	ldd	r25, Y+19	; 0x13
     b4a:	9b 83       	std	Y+3, r25	; 0x03
     b4c:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
     b4e:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
     b50:	8a 81       	ldd	r24, Y+2	; 0x02
     b52:	9b 81       	ldd	r25, Y+3	; 0x03
     b54:	02 96       	adiw	r24, 0x02	; 2
     b56:	9b 87       	std	Y+11, r25	; 0x0b
     b58:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b5a:	8a 85       	ldd	r24, Y+10	; 0x0a
     b5c:	9b 85       	ldd	r25, Y+11	; 0x0b
     b5e:	03 96       	adiw	r24, 0x03	; 3
     b60:	9d 87       	std	Y+13, r25	; 0x0d
     b62:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
     b64:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
     b68:	ea 85       	ldd	r30, Y+10	; 0x0a
     b6a:	fb 85       	ldd	r31, Y+11	; 0x0b
     b6c:	85 81       	ldd	r24, Z+5	; 0x05
     b6e:	96 81       	ldd	r25, Z+6	; 0x06
     b70:	99 8b       	std	Y+17, r25	; 0x11
     b72:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
     b74:	ea 81       	ldd	r30, Y+2	; 0x02
     b76:	fb 81       	ldd	r31, Y+3	; 0x03
     b78:	20 81       	ld	r18, Z
     b7a:	31 81       	ldd	r19, Z+1	; 0x01
     b7c:	8c 89       	ldd	r24, Y+20	; 0x14
     b7e:	9d 89       	ldd	r25, Y+21	; 0x15
     b80:	82 2b       	or	r24, r18
     b82:	93 2b       	or	r25, r19
     b84:	ea 81       	ldd	r30, Y+2	; 0x02
     b86:	fb 81       	ldd	r31, Y+3	; 0x03
     b88:	91 83       	std	Z+1, r25	; 0x01
     b8a:	80 83       	st	Z, r24
     b8c:	59 c0       	rjmp	.+178    	; 0xc40 <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
     b8e:	e8 89       	ldd	r30, Y+16	; 0x10
     b90:	f9 89       	ldd	r31, Y+17	; 0x11
     b92:	82 81       	ldd	r24, Z+2	; 0x02
     b94:	93 81       	ldd	r25, Z+3	; 0x03
     b96:	9f 87       	std	Y+15, r25	; 0x0f
     b98:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     b9a:	e8 89       	ldd	r30, Y+16	; 0x10
     b9c:	f9 89       	ldd	r31, Y+17	; 0x11
     b9e:	80 81       	ld	r24, Z
     ba0:	91 81       	ldd	r25, Z+1	; 0x01
     ba2:	9f 83       	std	Y+7, r25	; 0x07
     ba4:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
     ba6:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     ba8:	8e 81       	ldd	r24, Y+6	; 0x06
     baa:	9f 81       	ldd	r25, Y+7	; 0x07
     bac:	80 70       	andi	r24, 0x00	; 0
     bae:	9d 83       	std	Y+5, r25	; 0x05
     bb0:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     bb2:	8e 81       	ldd	r24, Y+6	; 0x06
     bb4:	9f 81       	ldd	r25, Y+7	; 0x07
     bb6:	90 70       	andi	r25, 0x00	; 0
     bb8:	9f 83       	std	Y+7, r25	; 0x07
     bba:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     bbc:	8c 81       	ldd	r24, Y+4	; 0x04
     bbe:	9d 81       	ldd	r25, Y+5	; 0x05
     bc0:	80 70       	andi	r24, 0x00	; 0
     bc2:	94 70       	andi	r25, 0x04	; 4
     bc4:	00 97       	sbiw	r24, 0x00	; 0
     bc6:	69 f4       	brne	.+26     	; 0xbe2 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     bc8:	ea 81       	ldd	r30, Y+2	; 0x02
     bca:	fb 81       	ldd	r31, Y+3	; 0x03
     bcc:	20 81       	ld	r18, Z
     bce:	31 81       	ldd	r19, Z+1	; 0x01
     bd0:	8e 81       	ldd	r24, Y+6	; 0x06
     bd2:	9f 81       	ldd	r25, Y+7	; 0x07
     bd4:	82 23       	and	r24, r18
     bd6:	93 23       	and	r25, r19
     bd8:	00 97       	sbiw	r24, 0x00	; 0
     bda:	91 f0       	breq	.+36     	; 0xc00 <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
     bdc:	81 e0       	ldi	r24, 0x01	; 1
     bde:	89 83       	std	Y+1, r24	; 0x01
     be0:	0f c0       	rjmp	.+30     	; 0xc00 <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     be2:	ea 81       	ldd	r30, Y+2	; 0x02
     be4:	fb 81       	ldd	r31, Y+3	; 0x03
     be6:	20 81       	ld	r18, Z
     be8:	31 81       	ldd	r19, Z+1	; 0x01
     bea:	8e 81       	ldd	r24, Y+6	; 0x06
     bec:	9f 81       	ldd	r25, Y+7	; 0x07
     bee:	28 23       	and	r18, r24
     bf0:	39 23       	and	r19, r25
     bf2:	8e 81       	ldd	r24, Y+6	; 0x06
     bf4:	9f 81       	ldd	r25, Y+7	; 0x07
     bf6:	28 17       	cp	r18, r24
     bf8:	39 07       	cpc	r19, r25
     bfa:	11 f4       	brne	.+4      	; 0xc00 <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
     bfc:	81 e0       	ldi	r24, 0x01	; 1
     bfe:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
     c00:	89 81       	ldd	r24, Y+1	; 0x01
     c02:	88 23       	and	r24, r24
     c04:	c9 f0       	breq	.+50     	; 0xc38 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     c06:	8c 81       	ldd	r24, Y+4	; 0x04
     c08:	9d 81       	ldd	r25, Y+5	; 0x05
     c0a:	80 70       	andi	r24, 0x00	; 0
     c0c:	91 70       	andi	r25, 0x01	; 1
     c0e:	00 97       	sbiw	r24, 0x00	; 0
     c10:	41 f0       	breq	.+16     	; 0xc22 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
     c12:	88 85       	ldd	r24, Y+8	; 0x08
     c14:	99 85       	ldd	r25, Y+9	; 0x09
     c16:	2e 81       	ldd	r18, Y+6	; 0x06
     c18:	3f 81       	ldd	r19, Y+7	; 0x07
     c1a:	82 2b       	or	r24, r18
     c1c:	93 2b       	or	r25, r19
     c1e:	99 87       	std	Y+9, r25	; 0x09
     c20:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     c22:	ea 81       	ldd	r30, Y+2	; 0x02
     c24:	fb 81       	ldd	r31, Y+3	; 0x03
     c26:	80 81       	ld	r24, Z
     c28:	91 81       	ldd	r25, Z+1	; 0x01
     c2a:	9c 01       	movw	r18, r24
     c2c:	32 60       	ori	r19, 0x02	; 2
     c2e:	88 89       	ldd	r24, Y+16	; 0x10
     c30:	99 89       	ldd	r25, Y+17	; 0x11
     c32:	b9 01       	movw	r22, r18
     c34:	0e 94 85 20 	call	0x410a	; 0x410a <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
     c38:	8e 85       	ldd	r24, Y+14	; 0x0e
     c3a:	9f 85       	ldd	r25, Y+15	; 0x0f
     c3c:	99 8b       	std	Y+17, r25	; 0x11
     c3e:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
     c40:	28 89       	ldd	r18, Y+16	; 0x10
     c42:	39 89       	ldd	r19, Y+17	; 0x11
     c44:	8c 85       	ldd	r24, Y+12	; 0x0c
     c46:	9d 85       	ldd	r25, Y+13	; 0x0d
     c48:	28 17       	cp	r18, r24
     c4a:	39 07       	cpc	r19, r25
     c4c:	09 f0       	breq	.+2      	; 0xc50 <xEventGroupSetBits+0x12a>
     c4e:	9f cf       	rjmp	.-194    	; 0xb8e <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
     c50:	ea 81       	ldd	r30, Y+2	; 0x02
     c52:	fb 81       	ldd	r31, Y+3	; 0x03
     c54:	20 81       	ld	r18, Z
     c56:	31 81       	ldd	r19, Z+1	; 0x01
     c58:	88 85       	ldd	r24, Y+8	; 0x08
     c5a:	99 85       	ldd	r25, Y+9	; 0x09
     c5c:	80 95       	com	r24
     c5e:	90 95       	com	r25
     c60:	82 23       	and	r24, r18
     c62:	93 23       	and	r25, r19
     c64:	ea 81       	ldd	r30, Y+2	; 0x02
     c66:	fb 81       	ldd	r31, Y+3	; 0x03
     c68:	91 83       	std	Z+1, r25	; 0x01
     c6a:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
     c6c:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
     c70:	ea 81       	ldd	r30, Y+2	; 0x02
     c72:	fb 81       	ldd	r31, Y+3	; 0x03
     c74:	80 81       	ld	r24, Z
     c76:	91 81       	ldd	r25, Z+1	; 0x01
}
     c78:	65 96       	adiw	r28, 0x15	; 21
     c7a:	0f b6       	in	r0, 0x3f	; 63
     c7c:	f8 94       	cli
     c7e:	de bf       	out	0x3e, r29	; 62
     c80:	0f be       	out	0x3f, r0	; 63
     c82:	cd bf       	out	0x3d, r28	; 61
     c84:	cf 91       	pop	r28
     c86:	df 91       	pop	r29
     c88:	08 95       	ret

00000c8a <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     c8a:	df 93       	push	r29
     c8c:	cf 93       	push	r28
     c8e:	00 d0       	rcall	.+0      	; 0xc90 <vEventGroupDelete+0x6>
     c90:	00 d0       	rcall	.+0      	; 0xc92 <vEventGroupDelete+0x8>
     c92:	00 d0       	rcall	.+0      	; 0xc94 <vEventGroupDelete+0xa>
     c94:	cd b7       	in	r28, 0x3d	; 61
     c96:	de b7       	in	r29, 0x3e	; 62
     c98:	9e 83       	std	Y+6, r25	; 0x06
     c9a:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
     c9c:	8d 81       	ldd	r24, Y+5	; 0x05
     c9e:	9e 81       	ldd	r25, Y+6	; 0x06
     ca0:	9c 83       	std	Y+4, r25	; 0x04
     ca2:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     ca4:	8b 81       	ldd	r24, Y+3	; 0x03
     ca6:	9c 81       	ldd	r25, Y+4	; 0x04
     ca8:	02 96       	adiw	r24, 0x02	; 2
     caa:	9a 83       	std	Y+2, r25	; 0x02
     cac:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
     cae:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
     cb2:	08 c0       	rjmp	.+16     	; 0xcc4 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     cb4:	e9 81       	ldd	r30, Y+1	; 0x01
     cb6:	fa 81       	ldd	r31, Y+2	; 0x02
     cb8:	85 81       	ldd	r24, Z+5	; 0x05
     cba:	96 81       	ldd	r25, Z+6	; 0x06
     cbc:	60 e0       	ldi	r22, 0x00	; 0
     cbe:	72 e0       	ldi	r23, 0x02	; 2
     cc0:	0e 94 85 20 	call	0x410a	; 0x410a <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     cc4:	e9 81       	ldd	r30, Y+1	; 0x01
     cc6:	fa 81       	ldd	r31, Y+2	; 0x02
     cc8:	80 81       	ld	r24, Z
     cca:	88 23       	and	r24, r24
     ccc:	99 f7       	brne	.-26     	; 0xcb4 <vEventGroupDelete+0x2a>
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
        }
    }
    ( void ) xTaskResumeAll();
     cce:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
     cd2:	8b 81       	ldd	r24, Y+3	; 0x03
     cd4:	9c 81       	ldd	r25, Y+4	; 0x04
     cd6:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
     cda:	26 96       	adiw	r28, 0x06	; 6
     cdc:	0f b6       	in	r0, 0x3f	; 63
     cde:	f8 94       	cli
     ce0:	de bf       	out	0x3e, r29	; 62
     ce2:	0f be       	out	0x3f, r0	; 63
     ce4:	cd bf       	out	0x3d, r28	; 61
     ce6:	cf 91       	pop	r28
     ce8:	df 91       	pop	r29
     cea:	08 95       	ret

00000cec <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
     cec:	df 93       	push	r29
     cee:	cf 93       	push	r28
     cf0:	00 d0       	rcall	.+0      	; 0xcf2 <vEventGroupSetBitsCallback+0x6>
     cf2:	00 d0       	rcall	.+0      	; 0xcf4 <vEventGroupSetBitsCallback+0x8>
     cf4:	00 d0       	rcall	.+0      	; 0xcf6 <vEventGroupSetBitsCallback+0xa>
     cf6:	cd b7       	in	r28, 0x3d	; 61
     cf8:	de b7       	in	r29, 0x3e	; 62
     cfa:	9a 83       	std	Y+2, r25	; 0x02
     cfc:	89 83       	std	Y+1, r24	; 0x01
     cfe:	4b 83       	std	Y+3, r20	; 0x03
     d00:	5c 83       	std	Y+4, r21	; 0x04
     d02:	6d 83       	std	Y+5, r22	; 0x05
     d04:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     d06:	89 81       	ldd	r24, Y+1	; 0x01
     d08:	9a 81       	ldd	r25, Y+2	; 0x02
     d0a:	2b 81       	ldd	r18, Y+3	; 0x03
     d0c:	3c 81       	ldd	r19, Y+4	; 0x04
     d0e:	b9 01       	movw	r22, r18
     d10:	0e 94 93 05 	call	0xb26	; 0xb26 <xEventGroupSetBits>
}
     d14:	26 96       	adiw	r28, 0x06	; 6
     d16:	0f b6       	in	r0, 0x3f	; 63
     d18:	f8 94       	cli
     d1a:	de bf       	out	0x3e, r29	; 62
     d1c:	0f be       	out	0x3f, r0	; 63
     d1e:	cd bf       	out	0x3d, r28	; 61
     d20:	cf 91       	pop	r28
     d22:	df 91       	pop	r29
     d24:	08 95       	ret

00000d26 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
     d26:	df 93       	push	r29
     d28:	cf 93       	push	r28
     d2a:	00 d0       	rcall	.+0      	; 0xd2c <vEventGroupClearBitsCallback+0x6>
     d2c:	00 d0       	rcall	.+0      	; 0xd2e <vEventGroupClearBitsCallback+0x8>
     d2e:	00 d0       	rcall	.+0      	; 0xd30 <vEventGroupClearBitsCallback+0xa>
     d30:	cd b7       	in	r28, 0x3d	; 61
     d32:	de b7       	in	r29, 0x3e	; 62
     d34:	9a 83       	std	Y+2, r25	; 0x02
     d36:	89 83       	std	Y+1, r24	; 0x01
     d38:	4b 83       	std	Y+3, r20	; 0x03
     d3a:	5c 83       	std	Y+4, r21	; 0x04
     d3c:	6d 83       	std	Y+5, r22	; 0x05
     d3e:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     d40:	89 81       	ldd	r24, Y+1	; 0x01
     d42:	9a 81       	ldd	r25, Y+2	; 0x02
     d44:	2b 81       	ldd	r18, Y+3	; 0x03
     d46:	3c 81       	ldd	r19, Y+4	; 0x04
     d48:	b9 01       	movw	r22, r18
     d4a:	0e 94 3b 05 	call	0xa76	; 0xa76 <xEventGroupClearBits>
}
     d4e:	26 96       	adiw	r28, 0x06	; 6
     d50:	0f b6       	in	r0, 0x3f	; 63
     d52:	f8 94       	cli
     d54:	de bf       	out	0x3e, r29	; 62
     d56:	0f be       	out	0x3f, r0	; 63
     d58:	cd bf       	out	0x3d, r28	; 61
     d5a:	cf 91       	pop	r28
     d5c:	df 91       	pop	r29
     d5e:	08 95       	ret

00000d60 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
     d60:	df 93       	push	r29
     d62:	cf 93       	push	r28
     d64:	00 d0       	rcall	.+0      	; 0xd66 <prvTestWaitCondition+0x6>
     d66:	00 d0       	rcall	.+0      	; 0xd68 <prvTestWaitCondition+0x8>
     d68:	00 d0       	rcall	.+0      	; 0xd6a <prvTestWaitCondition+0xa>
     d6a:	cd b7       	in	r28, 0x3d	; 61
     d6c:	de b7       	in	r29, 0x3e	; 62
     d6e:	9b 83       	std	Y+3, r25	; 0x03
     d70:	8a 83       	std	Y+2, r24	; 0x02
     d72:	7d 83       	std	Y+5, r23	; 0x05
     d74:	6c 83       	std	Y+4, r22	; 0x04
     d76:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
     d78:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
     d7a:	8e 81       	ldd	r24, Y+6	; 0x06
     d7c:	88 23       	and	r24, r24
     d7e:	59 f4       	brne	.+22     	; 0xd96 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     d80:	8a 81       	ldd	r24, Y+2	; 0x02
     d82:	9b 81       	ldd	r25, Y+3	; 0x03
     d84:	2c 81       	ldd	r18, Y+4	; 0x04
     d86:	3d 81       	ldd	r19, Y+5	; 0x05
     d88:	82 23       	and	r24, r18
     d8a:	93 23       	and	r25, r19
     d8c:	00 97       	sbiw	r24, 0x00	; 0
     d8e:	81 f0       	breq	.+32     	; 0xdb0 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	89 83       	std	Y+1, r24	; 0x01
     d94:	0d c0       	rjmp	.+26     	; 0xdb0 <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     d96:	2a 81       	ldd	r18, Y+2	; 0x02
     d98:	3b 81       	ldd	r19, Y+3	; 0x03
     d9a:	8c 81       	ldd	r24, Y+4	; 0x04
     d9c:	9d 81       	ldd	r25, Y+5	; 0x05
     d9e:	28 23       	and	r18, r24
     da0:	39 23       	and	r19, r25
     da2:	8c 81       	ldd	r24, Y+4	; 0x04
     da4:	9d 81       	ldd	r25, Y+5	; 0x05
     da6:	28 17       	cp	r18, r24
     da8:	39 07       	cpc	r19, r25
     daa:	11 f4       	brne	.+4      	; 0xdb0 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
     dac:	81 e0       	ldi	r24, 0x01	; 1
     dae:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
     db0:	89 81       	ldd	r24, Y+1	; 0x01
}
     db2:	26 96       	adiw	r28, 0x06	; 6
     db4:	0f b6       	in	r0, 0x3f	; 63
     db6:	f8 94       	cli
     db8:	de bf       	out	0x3e, r29	; 62
     dba:	0f be       	out	0x3f, r0	; 63
     dbc:	cd bf       	out	0x3d, r28	; 61
     dbe:	cf 91       	pop	r28
     dc0:	df 91       	pop	r29
     dc2:	08 95       	ret

00000dc4 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     dc4:	df 93       	push	r29
     dc6:	cf 93       	push	r28
     dc8:	00 d0       	rcall	.+0      	; 0xdca <vListInitialise+0x6>
     dca:	cd b7       	in	r28, 0x3d	; 61
     dcc:	de b7       	in	r29, 0x3e	; 62
     dce:	9a 83       	std	Y+2, r25	; 0x02
     dd0:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dd2:	89 81       	ldd	r24, Y+1	; 0x01
     dd4:	9a 81       	ldd	r25, Y+2	; 0x02
     dd6:	03 96       	adiw	r24, 0x03	; 3
     dd8:	e9 81       	ldd	r30, Y+1	; 0x01
     dda:	fa 81       	ldd	r31, Y+2	; 0x02
     ddc:	92 83       	std	Z+2, r25	; 0x02
     dde:	81 83       	std	Z+1, r24	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     de0:	e9 81       	ldd	r30, Y+1	; 0x01
     de2:	fa 81       	ldd	r31, Y+2	; 0x02
     de4:	8f ef       	ldi	r24, 0xFF	; 255
     de6:	9f ef       	ldi	r25, 0xFF	; 255
     de8:	94 83       	std	Z+4, r25	; 0x04
     dea:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dec:	89 81       	ldd	r24, Y+1	; 0x01
     dee:	9a 81       	ldd	r25, Y+2	; 0x02
     df0:	03 96       	adiw	r24, 0x03	; 3
     df2:	e9 81       	ldd	r30, Y+1	; 0x01
     df4:	fa 81       	ldd	r31, Y+2	; 0x02
     df6:	96 83       	std	Z+6, r25	; 0x06
     df8:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     dfa:	89 81       	ldd	r24, Y+1	; 0x01
     dfc:	9a 81       	ldd	r25, Y+2	; 0x02
     dfe:	03 96       	adiw	r24, 0x03	; 3
     e00:	e9 81       	ldd	r30, Y+1	; 0x01
     e02:	fa 81       	ldd	r31, Y+2	; 0x02
     e04:	90 87       	std	Z+8, r25	; 0x08
     e06:	87 83       	std	Z+7, r24	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     e08:	e9 81       	ldd	r30, Y+1	; 0x01
     e0a:	fa 81       	ldd	r31, Y+2	; 0x02
     e0c:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     e0e:	0f 90       	pop	r0
     e10:	0f 90       	pop	r0
     e12:	cf 91       	pop	r28
     e14:	df 91       	pop	r29
     e16:	08 95       	ret

00000e18 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     e18:	df 93       	push	r29
     e1a:	cf 93       	push	r28
     e1c:	00 d0       	rcall	.+0      	; 0xe1e <vListInitialiseItem+0x6>
     e1e:	cd b7       	in	r28, 0x3d	; 61
     e20:	de b7       	in	r29, 0x3e	; 62
     e22:	9a 83       	std	Y+2, r25	; 0x02
     e24:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     e26:	e9 81       	ldd	r30, Y+1	; 0x01
     e28:	fa 81       	ldd	r31, Y+2	; 0x02
     e2a:	11 86       	std	Z+9, r1	; 0x09
     e2c:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     e2e:	0f 90       	pop	r0
     e30:	0f 90       	pop	r0
     e32:	cf 91       	pop	r28
     e34:	df 91       	pop	r29
     e36:	08 95       	ret

00000e38 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
     e38:	df 93       	push	r29
     e3a:	cf 93       	push	r28
     e3c:	00 d0       	rcall	.+0      	; 0xe3e <vListInsertEnd+0x6>
     e3e:	00 d0       	rcall	.+0      	; 0xe40 <vListInsertEnd+0x8>
     e40:	00 d0       	rcall	.+0      	; 0xe42 <vListInsertEnd+0xa>
     e42:	cd b7       	in	r28, 0x3d	; 61
     e44:	de b7       	in	r29, 0x3e	; 62
     e46:	9c 83       	std	Y+4, r25	; 0x04
     e48:	8b 83       	std	Y+3, r24	; 0x03
     e4a:	7e 83       	std	Y+6, r23	; 0x06
     e4c:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
     e4e:	eb 81       	ldd	r30, Y+3	; 0x03
     e50:	fc 81       	ldd	r31, Y+4	; 0x04
     e52:	81 81       	ldd	r24, Z+1	; 0x01
     e54:	92 81       	ldd	r25, Z+2	; 0x02
     e56:	9a 83       	std	Y+2, r25	; 0x02
     e58:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     e5a:	ed 81       	ldd	r30, Y+5	; 0x05
     e5c:	fe 81       	ldd	r31, Y+6	; 0x06
     e5e:	89 81       	ldd	r24, Y+1	; 0x01
     e60:	9a 81       	ldd	r25, Y+2	; 0x02
     e62:	93 83       	std	Z+3, r25	; 0x03
     e64:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     e66:	e9 81       	ldd	r30, Y+1	; 0x01
     e68:	fa 81       	ldd	r31, Y+2	; 0x02
     e6a:	84 81       	ldd	r24, Z+4	; 0x04
     e6c:	95 81       	ldd	r25, Z+5	; 0x05
     e6e:	ed 81       	ldd	r30, Y+5	; 0x05
     e70:	fe 81       	ldd	r31, Y+6	; 0x06
     e72:	95 83       	std	Z+5, r25	; 0x05
     e74:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
     e76:	e9 81       	ldd	r30, Y+1	; 0x01
     e78:	fa 81       	ldd	r31, Y+2	; 0x02
     e7a:	04 80       	ldd	r0, Z+4	; 0x04
     e7c:	f5 81       	ldd	r31, Z+5	; 0x05
     e7e:	e0 2d       	mov	r30, r0
     e80:	8d 81       	ldd	r24, Y+5	; 0x05
     e82:	9e 81       	ldd	r25, Y+6	; 0x06
     e84:	93 83       	std	Z+3, r25	; 0x03
     e86:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
     e88:	e9 81       	ldd	r30, Y+1	; 0x01
     e8a:	fa 81       	ldd	r31, Y+2	; 0x02
     e8c:	8d 81       	ldd	r24, Y+5	; 0x05
     e8e:	9e 81       	ldd	r25, Y+6	; 0x06
     e90:	95 83       	std	Z+5, r25	; 0x05
     e92:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
     e94:	ed 81       	ldd	r30, Y+5	; 0x05
     e96:	fe 81       	ldd	r31, Y+6	; 0x06
     e98:	8b 81       	ldd	r24, Y+3	; 0x03
     e9a:	9c 81       	ldd	r25, Y+4	; 0x04
     e9c:	91 87       	std	Z+9, r25	; 0x09
     e9e:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     ea0:	eb 81       	ldd	r30, Y+3	; 0x03
     ea2:	fc 81       	ldd	r31, Y+4	; 0x04
     ea4:	80 81       	ld	r24, Z
     ea6:	8f 5f       	subi	r24, 0xFF	; 255
     ea8:	eb 81       	ldd	r30, Y+3	; 0x03
     eaa:	fc 81       	ldd	r31, Y+4	; 0x04
     eac:	80 83       	st	Z, r24
}
     eae:	26 96       	adiw	r28, 0x06	; 6
     eb0:	0f b6       	in	r0, 0x3f	; 63
     eb2:	f8 94       	cli
     eb4:	de bf       	out	0x3e, r29	; 62
     eb6:	0f be       	out	0x3f, r0	; 63
     eb8:	cd bf       	out	0x3d, r28	; 61
     eba:	cf 91       	pop	r28
     ebc:	df 91       	pop	r29
     ebe:	08 95       	ret

00000ec0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
     ec0:	df 93       	push	r29
     ec2:	cf 93       	push	r28
     ec4:	cd b7       	in	r28, 0x3d	; 61
     ec6:	de b7       	in	r29, 0x3e	; 62
     ec8:	28 97       	sbiw	r28, 0x08	; 8
     eca:	0f b6       	in	r0, 0x3f	; 63
     ecc:	f8 94       	cli
     ece:	de bf       	out	0x3e, r29	; 62
     ed0:	0f be       	out	0x3f, r0	; 63
     ed2:	cd bf       	out	0x3d, r28	; 61
     ed4:	9e 83       	std	Y+6, r25	; 0x06
     ed6:	8d 83       	std	Y+5, r24	; 0x05
     ed8:	78 87       	std	Y+8, r23	; 0x08
     eda:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     edc:	ef 81       	ldd	r30, Y+7	; 0x07
     ede:	f8 85       	ldd	r31, Y+8	; 0x08
     ee0:	80 81       	ld	r24, Z
     ee2:	91 81       	ldd	r25, Z+1	; 0x01
     ee4:	9a 83       	std	Y+2, r25	; 0x02
     ee6:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     ee8:	89 81       	ldd	r24, Y+1	; 0x01
     eea:	9a 81       	ldd	r25, Y+2	; 0x02
     eec:	2f ef       	ldi	r18, 0xFF	; 255
     eee:	8f 3f       	cpi	r24, 0xFF	; 255
     ef0:	92 07       	cpc	r25, r18
     ef2:	39 f4       	brne	.+14     	; 0xf02 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
     ef4:	ed 81       	ldd	r30, Y+5	; 0x05
     ef6:	fe 81       	ldd	r31, Y+6	; 0x06
     ef8:	87 81       	ldd	r24, Z+7	; 0x07
     efa:	90 85       	ldd	r25, Z+8	; 0x08
     efc:	9c 83       	std	Y+4, r25	; 0x04
     efe:	8b 83       	std	Y+3, r24	; 0x03
     f00:	18 c0       	rjmp	.+48     	; 0xf32 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     f02:	8d 81       	ldd	r24, Y+5	; 0x05
     f04:	9e 81       	ldd	r25, Y+6	; 0x06
     f06:	03 96       	adiw	r24, 0x03	; 3
     f08:	9c 83       	std	Y+4, r25	; 0x04
     f0a:	8b 83       	std	Y+3, r24	; 0x03
     f0c:	06 c0       	rjmp	.+12     	; 0xf1a <vListInsert+0x5a>
     f0e:	eb 81       	ldd	r30, Y+3	; 0x03
     f10:	fc 81       	ldd	r31, Y+4	; 0x04
     f12:	82 81       	ldd	r24, Z+2	; 0x02
     f14:	93 81       	ldd	r25, Z+3	; 0x03
     f16:	9c 83       	std	Y+4, r25	; 0x04
     f18:	8b 83       	std	Y+3, r24	; 0x03
     f1a:	eb 81       	ldd	r30, Y+3	; 0x03
     f1c:	fc 81       	ldd	r31, Y+4	; 0x04
     f1e:	02 80       	ldd	r0, Z+2	; 0x02
     f20:	f3 81       	ldd	r31, Z+3	; 0x03
     f22:	e0 2d       	mov	r30, r0
     f24:	20 81       	ld	r18, Z
     f26:	31 81       	ldd	r19, Z+1	; 0x01
     f28:	89 81       	ldd	r24, Y+1	; 0x01
     f2a:	9a 81       	ldd	r25, Y+2	; 0x02
     f2c:	82 17       	cp	r24, r18
     f2e:	93 07       	cpc	r25, r19
     f30:	70 f7       	brcc	.-36     	; 0xf0e <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     f32:	eb 81       	ldd	r30, Y+3	; 0x03
     f34:	fc 81       	ldd	r31, Y+4	; 0x04
     f36:	82 81       	ldd	r24, Z+2	; 0x02
     f38:	93 81       	ldd	r25, Z+3	; 0x03
     f3a:	ef 81       	ldd	r30, Y+7	; 0x07
     f3c:	f8 85       	ldd	r31, Y+8	; 0x08
     f3e:	93 83       	std	Z+3, r25	; 0x03
     f40:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     f42:	ef 81       	ldd	r30, Y+7	; 0x07
     f44:	f8 85       	ldd	r31, Y+8	; 0x08
     f46:	02 80       	ldd	r0, Z+2	; 0x02
     f48:	f3 81       	ldd	r31, Z+3	; 0x03
     f4a:	e0 2d       	mov	r30, r0
     f4c:	8f 81       	ldd	r24, Y+7	; 0x07
     f4e:	98 85       	ldd	r25, Y+8	; 0x08
     f50:	95 83       	std	Z+5, r25	; 0x05
     f52:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
     f54:	ef 81       	ldd	r30, Y+7	; 0x07
     f56:	f8 85       	ldd	r31, Y+8	; 0x08
     f58:	8b 81       	ldd	r24, Y+3	; 0x03
     f5a:	9c 81       	ldd	r25, Y+4	; 0x04
     f5c:	95 83       	std	Z+5, r25	; 0x05
     f5e:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
     f60:	eb 81       	ldd	r30, Y+3	; 0x03
     f62:	fc 81       	ldd	r31, Y+4	; 0x04
     f64:	8f 81       	ldd	r24, Y+7	; 0x07
     f66:	98 85       	ldd	r25, Y+8	; 0x08
     f68:	93 83       	std	Z+3, r25	; 0x03
     f6a:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
     f6c:	ef 81       	ldd	r30, Y+7	; 0x07
     f6e:	f8 85       	ldd	r31, Y+8	; 0x08
     f70:	8d 81       	ldd	r24, Y+5	; 0x05
     f72:	9e 81       	ldd	r25, Y+6	; 0x06
     f74:	91 87       	std	Z+9, r25	; 0x09
     f76:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     f78:	ed 81       	ldd	r30, Y+5	; 0x05
     f7a:	fe 81       	ldd	r31, Y+6	; 0x06
     f7c:	80 81       	ld	r24, Z
     f7e:	8f 5f       	subi	r24, 0xFF	; 255
     f80:	ed 81       	ldd	r30, Y+5	; 0x05
     f82:	fe 81       	ldd	r31, Y+6	; 0x06
     f84:	80 83       	st	Z, r24
}
     f86:	28 96       	adiw	r28, 0x08	; 8
     f88:	0f b6       	in	r0, 0x3f	; 63
     f8a:	f8 94       	cli
     f8c:	de bf       	out	0x3e, r29	; 62
     f8e:	0f be       	out	0x3f, r0	; 63
     f90:	cd bf       	out	0x3d, r28	; 61
     f92:	cf 91       	pop	r28
     f94:	df 91       	pop	r29
     f96:	08 95       	ret

00000f98 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     f98:	df 93       	push	r29
     f9a:	cf 93       	push	r28
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <uxListRemove+0x6>
     f9e:	00 d0       	rcall	.+0      	; 0xfa0 <uxListRemove+0x8>
     fa0:	cd b7       	in	r28, 0x3d	; 61
     fa2:	de b7       	in	r29, 0x3e	; 62
     fa4:	9c 83       	std	Y+4, r25	; 0x04
     fa6:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
     fa8:	eb 81       	ldd	r30, Y+3	; 0x03
     faa:	fc 81       	ldd	r31, Y+4	; 0x04
     fac:	80 85       	ldd	r24, Z+8	; 0x08
     fae:	91 85       	ldd	r25, Z+9	; 0x09
     fb0:	9a 83       	std	Y+2, r25	; 0x02
     fb2:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     fb4:	eb 81       	ldd	r30, Y+3	; 0x03
     fb6:	fc 81       	ldd	r31, Y+4	; 0x04
     fb8:	a2 81       	ldd	r26, Z+2	; 0x02
     fba:	b3 81       	ldd	r27, Z+3	; 0x03
     fbc:	eb 81       	ldd	r30, Y+3	; 0x03
     fbe:	fc 81       	ldd	r31, Y+4	; 0x04
     fc0:	84 81       	ldd	r24, Z+4	; 0x04
     fc2:	95 81       	ldd	r25, Z+5	; 0x05
     fc4:	15 96       	adiw	r26, 0x05	; 5
     fc6:	9c 93       	st	X, r25
     fc8:	8e 93       	st	-X, r24
     fca:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     fcc:	eb 81       	ldd	r30, Y+3	; 0x03
     fce:	fc 81       	ldd	r31, Y+4	; 0x04
     fd0:	a4 81       	ldd	r26, Z+4	; 0x04
     fd2:	b5 81       	ldd	r27, Z+5	; 0x05
     fd4:	eb 81       	ldd	r30, Y+3	; 0x03
     fd6:	fc 81       	ldd	r31, Y+4	; 0x04
     fd8:	82 81       	ldd	r24, Z+2	; 0x02
     fda:	93 81       	ldd	r25, Z+3	; 0x03
     fdc:	13 96       	adiw	r26, 0x03	; 3
     fde:	9c 93       	st	X, r25
     fe0:	8e 93       	st	-X, r24
     fe2:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     fe4:	e9 81       	ldd	r30, Y+1	; 0x01
     fe6:	fa 81       	ldd	r31, Y+2	; 0x02
     fe8:	21 81       	ldd	r18, Z+1	; 0x01
     fea:	32 81       	ldd	r19, Z+2	; 0x02
     fec:	8b 81       	ldd	r24, Y+3	; 0x03
     fee:	9c 81       	ldd	r25, Y+4	; 0x04
     ff0:	28 17       	cp	r18, r24
     ff2:	39 07       	cpc	r19, r25
     ff4:	41 f4       	brne	.+16     	; 0x1006 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     ff6:	eb 81       	ldd	r30, Y+3	; 0x03
     ff8:	fc 81       	ldd	r31, Y+4	; 0x04
     ffa:	84 81       	ldd	r24, Z+4	; 0x04
     ffc:	95 81       	ldd	r25, Z+5	; 0x05
     ffe:	e9 81       	ldd	r30, Y+1	; 0x01
    1000:	fa 81       	ldd	r31, Y+2	; 0x02
    1002:	92 83       	std	Z+2, r25	; 0x02
    1004:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1006:	eb 81       	ldd	r30, Y+3	; 0x03
    1008:	fc 81       	ldd	r31, Y+4	; 0x04
    100a:	11 86       	std	Z+9, r1	; 0x09
    100c:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    100e:	e9 81       	ldd	r30, Y+1	; 0x01
    1010:	fa 81       	ldd	r31, Y+2	; 0x02
    1012:	80 81       	ld	r24, Z
    1014:	81 50       	subi	r24, 0x01	; 1
    1016:	e9 81       	ldd	r30, Y+1	; 0x01
    1018:	fa 81       	ldd	r31, Y+2	; 0x02
    101a:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    101c:	e9 81       	ldd	r30, Y+1	; 0x01
    101e:	fa 81       	ldd	r31, Y+2	; 0x02
    1020:	80 81       	ld	r24, Z
}
    1022:	0f 90       	pop	r0
    1024:	0f 90       	pop	r0
    1026:	0f 90       	pop	r0
    1028:	0f 90       	pop	r0
    102a:	cf 91       	pop	r28
    102c:	df 91       	pop	r29
    102e:	08 95       	ret

00001030 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    1030:	df 93       	push	r29
    1032:	cf 93       	push	r28
    1034:	00 d0       	rcall	.+0      	; 0x1036 <xQueueGenericReset+0x6>
    1036:	00 d0       	rcall	.+0      	; 0x1038 <xQueueGenericReset+0x8>
    1038:	00 d0       	rcall	.+0      	; 0x103a <xQueueGenericReset+0xa>
    103a:	cd b7       	in	r28, 0x3d	; 61
    103c:	de b7       	in	r29, 0x3e	; 62
    103e:	9d 83       	std	Y+5, r25	; 0x05
    1040:	8c 83       	std	Y+4, r24	; 0x04
    1042:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    1044:	81 e0       	ldi	r24, 0x01	; 1
    1046:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1048:	8c 81       	ldd	r24, Y+4	; 0x04
    104a:	9d 81       	ldd	r25, Y+5	; 0x05
    104c:	9a 83       	std	Y+2, r25	; 0x02
    104e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1050:	89 81       	ldd	r24, Y+1	; 0x01
    1052:	9a 81       	ldd	r25, Y+2	; 0x02
    1054:	00 97       	sbiw	r24, 0x00	; 0
    1056:	09 f4       	brne	.+2      	; 0x105a <xQueueGenericReset+0x2a>
    1058:	8b c0       	rjmp	.+278    	; 0x1170 <xQueueGenericReset+0x140>
    105a:	e9 81       	ldd	r30, Y+1	; 0x01
    105c:	fa 81       	ldd	r31, Y+2	; 0x02
    105e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1060:	88 23       	and	r24, r24
    1062:	09 f4       	brne	.+2      	; 0x1066 <xQueueGenericReset+0x36>
    1064:	85 c0       	rjmp	.+266    	; 0x1170 <xQueueGenericReset+0x140>
    1066:	e9 81       	ldd	r30, Y+1	; 0x01
    1068:	fa 81       	ldd	r31, Y+2	; 0x02
    106a:	83 8d       	ldd	r24, Z+27	; 0x1b
    106c:	28 2f       	mov	r18, r24
    106e:	30 e0       	ldi	r19, 0x00	; 0
    1070:	8f ef       	ldi	r24, 0xFF	; 255
    1072:	9f e7       	ldi	r25, 0x7F	; 127
    1074:	b9 01       	movw	r22, r18
    1076:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <__udivmodhi4>
    107a:	cb 01       	movw	r24, r22
    107c:	9c 01       	movw	r18, r24
    107e:	e9 81       	ldd	r30, Y+1	; 0x01
    1080:	fa 81       	ldd	r31, Y+2	; 0x02
    1082:	84 8d       	ldd	r24, Z+28	; 0x1c
    1084:	88 2f       	mov	r24, r24
    1086:	90 e0       	ldi	r25, 0x00	; 0
    1088:	28 17       	cp	r18, r24
    108a:	39 07       	cpc	r19, r25
    108c:	08 f4       	brcc	.+2      	; 0x1090 <xQueueGenericReset+0x60>
    108e:	70 c0       	rjmp	.+224    	; 0x1170 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    1090:	0f b6       	in	r0, 0x3f	; 63
    1092:	f8 94       	cli
    1094:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1096:	e9 81       	ldd	r30, Y+1	; 0x01
    1098:	fa 81       	ldd	r31, Y+2	; 0x02
    109a:	40 81       	ld	r20, Z
    109c:	51 81       	ldd	r21, Z+1	; 0x01
    109e:	e9 81       	ldd	r30, Y+1	; 0x01
    10a0:	fa 81       	ldd	r31, Y+2	; 0x02
    10a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    10a4:	28 2f       	mov	r18, r24
    10a6:	30 e0       	ldi	r19, 0x00	; 0
    10a8:	e9 81       	ldd	r30, Y+1	; 0x01
    10aa:	fa 81       	ldd	r31, Y+2	; 0x02
    10ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    10ae:	88 2f       	mov	r24, r24
    10b0:	90 e0       	ldi	r25, 0x00	; 0
    10b2:	bc 01       	movw	r22, r24
    10b4:	26 9f       	mul	r18, r22
    10b6:	c0 01       	movw	r24, r0
    10b8:	27 9f       	mul	r18, r23
    10ba:	90 0d       	add	r25, r0
    10bc:	36 9f       	mul	r19, r22
    10be:	90 0d       	add	r25, r0
    10c0:	11 24       	eor	r1, r1
    10c2:	84 0f       	add	r24, r20
    10c4:	95 1f       	adc	r25, r21
    10c6:	e9 81       	ldd	r30, Y+1	; 0x01
    10c8:	fa 81       	ldd	r31, Y+2	; 0x02
    10ca:	95 83       	std	Z+5, r25	; 0x05
    10cc:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    10ce:	e9 81       	ldd	r30, Y+1	; 0x01
    10d0:	fa 81       	ldd	r31, Y+2	; 0x02
    10d2:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    10d4:	e9 81       	ldd	r30, Y+1	; 0x01
    10d6:	fa 81       	ldd	r31, Y+2	; 0x02
    10d8:	80 81       	ld	r24, Z
    10da:	91 81       	ldd	r25, Z+1	; 0x01
    10dc:	e9 81       	ldd	r30, Y+1	; 0x01
    10de:	fa 81       	ldd	r31, Y+2	; 0x02
    10e0:	93 83       	std	Z+3, r25	; 0x03
    10e2:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    10e4:	e9 81       	ldd	r30, Y+1	; 0x01
    10e6:	fa 81       	ldd	r31, Y+2	; 0x02
    10e8:	40 81       	ld	r20, Z
    10ea:	51 81       	ldd	r21, Z+1	; 0x01
    10ec:	e9 81       	ldd	r30, Y+1	; 0x01
    10ee:	fa 81       	ldd	r31, Y+2	; 0x02
    10f0:	83 8d       	ldd	r24, Z+27	; 0x1b
    10f2:	88 2f       	mov	r24, r24
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	9c 01       	movw	r18, r24
    10f8:	21 50       	subi	r18, 0x01	; 1
    10fa:	30 40       	sbci	r19, 0x00	; 0
    10fc:	e9 81       	ldd	r30, Y+1	; 0x01
    10fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1100:	84 8d       	ldd	r24, Z+28	; 0x1c
    1102:	88 2f       	mov	r24, r24
    1104:	90 e0       	ldi	r25, 0x00	; 0
    1106:	bc 01       	movw	r22, r24
    1108:	26 9f       	mul	r18, r22
    110a:	c0 01       	movw	r24, r0
    110c:	27 9f       	mul	r18, r23
    110e:	90 0d       	add	r25, r0
    1110:	36 9f       	mul	r19, r22
    1112:	90 0d       	add	r25, r0
    1114:	11 24       	eor	r1, r1
    1116:	84 0f       	add	r24, r20
    1118:	95 1f       	adc	r25, r21
    111a:	e9 81       	ldd	r30, Y+1	; 0x01
    111c:	fa 81       	ldd	r31, Y+2	; 0x02
    111e:	97 83       	std	Z+7, r25	; 0x07
    1120:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    1122:	e9 81       	ldd	r30, Y+1	; 0x01
    1124:	fa 81       	ldd	r31, Y+2	; 0x02
    1126:	8f ef       	ldi	r24, 0xFF	; 255
    1128:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    112a:	e9 81       	ldd	r30, Y+1	; 0x01
    112c:	fa 81       	ldd	r31, Y+2	; 0x02
    112e:	8f ef       	ldi	r24, 0xFF	; 255
    1130:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    1132:	8e 81       	ldd	r24, Y+6	; 0x06
    1134:	88 23       	and	r24, r24
    1136:	79 f4       	brne	.+30     	; 0x1156 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1138:	e9 81       	ldd	r30, Y+1	; 0x01
    113a:	fa 81       	ldd	r31, Y+2	; 0x02
    113c:	80 85       	ldd	r24, Z+8	; 0x08
    113e:	88 23       	and	r24, r24
    1140:	a1 f0       	breq	.+40     	; 0x116a <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1142:	89 81       	ldd	r24, Y+1	; 0x01
    1144:	9a 81       	ldd	r25, Y+2	; 0x02
    1146:	08 96       	adiw	r24, 0x08	; 8
    1148:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <xTaskRemoveFromEventList>
    114c:	88 23       	and	r24, r24
    114e:	69 f0       	breq	.+26     	; 0x116a <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1150:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1154:	0a c0       	rjmp	.+20     	; 0x116a <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1156:	89 81       	ldd	r24, Y+1	; 0x01
    1158:	9a 81       	ldd	r25, Y+2	; 0x02
    115a:	08 96       	adiw	r24, 0x08	; 8
    115c:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1160:	89 81       	ldd	r24, Y+1	; 0x01
    1162:	9a 81       	ldd	r25, Y+2	; 0x02
    1164:	41 96       	adiw	r24, 0x11	; 17
    1166:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    116a:	0f 90       	pop	r0
    116c:	0f be       	out	0x3f, r0	; 63
    116e:	01 c0       	rjmp	.+2      	; 0x1172 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    1170:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    1172:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1174:	26 96       	adiw	r28, 0x06	; 6
    1176:	0f b6       	in	r0, 0x3f	; 63
    1178:	f8 94       	cli
    117a:	de bf       	out	0x3e, r29	; 62
    117c:	0f be       	out	0x3f, r0	; 63
    117e:	cd bf       	out	0x3d, r28	; 61
    1180:	cf 91       	pop	r28
    1182:	df 91       	pop	r29
    1184:	08 95       	ret

00001186 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1186:	0f 93       	push	r16
    1188:	1f 93       	push	r17
    118a:	df 93       	push	r29
    118c:	cf 93       	push	r28
    118e:	cd b7       	in	r28, 0x3d	; 61
    1190:	de b7       	in	r29, 0x3e	; 62
    1192:	29 97       	sbiw	r28, 0x09	; 9
    1194:	0f b6       	in	r0, 0x3f	; 63
    1196:	f8 94       	cli
    1198:	de bf       	out	0x3e, r29	; 62
    119a:	0f be       	out	0x3f, r0	; 63
    119c:	cd bf       	out	0x3d, r28	; 61
    119e:	8f 83       	std	Y+7, r24	; 0x07
    11a0:	68 87       	std	Y+8, r22	; 0x08
    11a2:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    11a4:	1e 82       	std	Y+6, r1	; 0x06
    11a6:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    11a8:	8f 81       	ldd	r24, Y+7	; 0x07
    11aa:	88 23       	and	r24, r24
    11ac:	09 f4       	brne	.+2      	; 0x11b0 <xQueueGenericCreate+0x2a>
    11ae:	52 c0       	rjmp	.+164    	; 0x1254 <xQueueGenericCreate+0xce>
    11b0:	8f 81       	ldd	r24, Y+7	; 0x07
    11b2:	28 2f       	mov	r18, r24
    11b4:	30 e0       	ldi	r19, 0x00	; 0
    11b6:	8f ef       	ldi	r24, 0xFF	; 255
    11b8:	9f e7       	ldi	r25, 0x7F	; 127
    11ba:	b9 01       	movw	r22, r18
    11bc:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <__udivmodhi4>
    11c0:	cb 01       	movw	r24, r22
    11c2:	9c 01       	movw	r18, r24
    11c4:	88 85       	ldd	r24, Y+8	; 0x08
    11c6:	88 2f       	mov	r24, r24
    11c8:	90 e0       	ldi	r25, 0x00	; 0
    11ca:	28 17       	cp	r18, r24
    11cc:	39 07       	cpc	r19, r25
    11ce:	08 f4       	brcc	.+2      	; 0x11d2 <xQueueGenericCreate+0x4c>
    11d0:	41 c0       	rjmp	.+130    	; 0x1254 <xQueueGenericCreate+0xce>
    11d2:	8f 81       	ldd	r24, Y+7	; 0x07
    11d4:	28 2f       	mov	r18, r24
    11d6:	30 e0       	ldi	r19, 0x00	; 0
    11d8:	88 85       	ldd	r24, Y+8	; 0x08
    11da:	88 2f       	mov	r24, r24
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	ac 01       	movw	r20, r24
    11e0:	24 9f       	mul	r18, r20
    11e2:	c0 01       	movw	r24, r0
    11e4:	25 9f       	mul	r18, r21
    11e6:	90 0d       	add	r25, r0
    11e8:	34 9f       	mul	r19, r20
    11ea:	90 0d       	add	r25, r0
    11ec:	11 24       	eor	r1, r1
    11ee:	5f e7       	ldi	r21, 0x7F	; 127
    11f0:	81 3e       	cpi	r24, 0xE1	; 225
    11f2:	95 07       	cpc	r25, r21
    11f4:	78 f5       	brcc	.+94     	; 0x1254 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    11f6:	8f 81       	ldd	r24, Y+7	; 0x07
    11f8:	28 2f       	mov	r18, r24
    11fa:	30 e0       	ldi	r19, 0x00	; 0
    11fc:	88 85       	ldd	r24, Y+8	; 0x08
    11fe:	88 2f       	mov	r24, r24
    1200:	90 e0       	ldi	r25, 0x00	; 0
    1202:	ac 01       	movw	r20, r24
    1204:	24 9f       	mul	r18, r20
    1206:	c0 01       	movw	r24, r0
    1208:	25 9f       	mul	r18, r21
    120a:	90 0d       	add	r25, r0
    120c:	34 9f       	mul	r19, r20
    120e:	90 0d       	add	r25, r0
    1210:	11 24       	eor	r1, r1
    1212:	9c 83       	std	Y+4, r25	; 0x04
    1214:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1216:	8b 81       	ldd	r24, Y+3	; 0x03
    1218:	9c 81       	ldd	r25, Y+4	; 0x04
    121a:	4f 96       	adiw	r24, 0x1f	; 31
    121c:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1220:	9e 83       	std	Y+6, r25	; 0x06
    1222:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    1224:	8d 81       	ldd	r24, Y+5	; 0x05
    1226:	9e 81       	ldd	r25, Y+6	; 0x06
    1228:	00 97       	sbiw	r24, 0x00	; 0
    122a:	a1 f0       	breq	.+40     	; 0x1254 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    122c:	8d 81       	ldd	r24, Y+5	; 0x05
    122e:	9e 81       	ldd	r25, Y+6	; 0x06
    1230:	9a 83       	std	Y+2, r25	; 0x02
    1232:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1234:	89 81       	ldd	r24, Y+1	; 0x01
    1236:	9a 81       	ldd	r25, Y+2	; 0x02
    1238:	4f 96       	adiw	r24, 0x1f	; 31
    123a:	9a 83       	std	Y+2, r25	; 0x02
    123c:	89 83       	std	Y+1, r24	; 0x01
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    123e:	29 81       	ldd	r18, Y+1	; 0x01
    1240:	3a 81       	ldd	r19, Y+2	; 0x02
    1242:	ed 81       	ldd	r30, Y+5	; 0x05
    1244:	fe 81       	ldd	r31, Y+6	; 0x06
    1246:	8f 81       	ldd	r24, Y+7	; 0x07
    1248:	68 85       	ldd	r22, Y+8	; 0x08
    124a:	a9 01       	movw	r20, r18
    124c:	29 85       	ldd	r18, Y+9	; 0x09
    124e:	8f 01       	movw	r16, r30
    1250:	0e 94 37 09 	call	0x126e	; 0x126e <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    1254:	8d 81       	ldd	r24, Y+5	; 0x05
    1256:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    1258:	29 96       	adiw	r28, 0x09	; 9
    125a:	0f b6       	in	r0, 0x3f	; 63
    125c:	f8 94       	cli
    125e:	de bf       	out	0x3e, r29	; 62
    1260:	0f be       	out	0x3f, r0	; 63
    1262:	cd bf       	out	0x3d, r28	; 61
    1264:	cf 91       	pop	r28
    1266:	df 91       	pop	r29
    1268:	1f 91       	pop	r17
    126a:	0f 91       	pop	r16
    126c:	08 95       	ret

0000126e <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    126e:	0f 93       	push	r16
    1270:	1f 93       	push	r17
    1272:	df 93       	push	r29
    1274:	cf 93       	push	r28
    1276:	cd b7       	in	r28, 0x3d	; 61
    1278:	de b7       	in	r29, 0x3e	; 62
    127a:	27 97       	sbiw	r28, 0x07	; 7
    127c:	0f b6       	in	r0, 0x3f	; 63
    127e:	f8 94       	cli
    1280:	de bf       	out	0x3e, r29	; 62
    1282:	0f be       	out	0x3f, r0	; 63
    1284:	cd bf       	out	0x3d, r28	; 61
    1286:	89 83       	std	Y+1, r24	; 0x01
    1288:	6a 83       	std	Y+2, r22	; 0x02
    128a:	5c 83       	std	Y+4, r21	; 0x04
    128c:	4b 83       	std	Y+3, r20	; 0x03
    128e:	2d 83       	std	Y+5, r18	; 0x05
    1290:	1f 83       	std	Y+7, r17	; 0x07
    1292:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    1294:	8a 81       	ldd	r24, Y+2	; 0x02
    1296:	88 23       	and	r24, r24
    1298:	39 f4       	brne	.+14     	; 0x12a8 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    129a:	8e 81       	ldd	r24, Y+6	; 0x06
    129c:	9f 81       	ldd	r25, Y+7	; 0x07
    129e:	ee 81       	ldd	r30, Y+6	; 0x06
    12a0:	ff 81       	ldd	r31, Y+7	; 0x07
    12a2:	91 83       	std	Z+1, r25	; 0x01
    12a4:	80 83       	st	Z, r24
    12a6:	06 c0       	rjmp	.+12     	; 0x12b4 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    12a8:	8b 81       	ldd	r24, Y+3	; 0x03
    12aa:	9c 81       	ldd	r25, Y+4	; 0x04
    12ac:	ee 81       	ldd	r30, Y+6	; 0x06
    12ae:	ff 81       	ldd	r31, Y+7	; 0x07
    12b0:	91 83       	std	Z+1, r25	; 0x01
    12b2:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    12b4:	ee 81       	ldd	r30, Y+6	; 0x06
    12b6:	ff 81       	ldd	r31, Y+7	; 0x07
    12b8:	89 81       	ldd	r24, Y+1	; 0x01
    12ba:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    12bc:	ee 81       	ldd	r30, Y+6	; 0x06
    12be:	ff 81       	ldd	r31, Y+7	; 0x07
    12c0:	8a 81       	ldd	r24, Y+2	; 0x02
    12c2:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    12c4:	8e 81       	ldd	r24, Y+6	; 0x06
    12c6:	9f 81       	ldd	r25, Y+7	; 0x07
    12c8:	61 e0       	ldi	r22, 0x01	; 1
    12ca:	0e 94 18 08 	call	0x1030	; 0x1030 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    12ce:	27 96       	adiw	r28, 0x07	; 7
    12d0:	0f b6       	in	r0, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	de bf       	out	0x3e, r29	; 62
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	cd bf       	out	0x3d, r28	; 61
    12da:	cf 91       	pop	r28
    12dc:	df 91       	pop	r29
    12de:	1f 91       	pop	r17
    12e0:	0f 91       	pop	r16
    12e2:	08 95       	ret

000012e4 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    12e4:	df 93       	push	r29
    12e6:	cf 93       	push	r28
    12e8:	cd b7       	in	r28, 0x3d	; 61
    12ea:	de b7       	in	r29, 0x3e	; 62
    12ec:	2f 97       	sbiw	r28, 0x0f	; 15
    12ee:	0f b6       	in	r0, 0x3f	; 63
    12f0:	f8 94       	cli
    12f2:	de bf       	out	0x3e, r29	; 62
    12f4:	0f be       	out	0x3f, r0	; 63
    12f6:	cd bf       	out	0x3d, r28	; 61
    12f8:	99 87       	std	Y+9, r25	; 0x09
    12fa:	88 87       	std	Y+8, r24	; 0x08
    12fc:	7b 87       	std	Y+11, r23	; 0x0b
    12fe:	6a 87       	std	Y+10, r22	; 0x0a
    1300:	5d 87       	std	Y+13, r21	; 0x0d
    1302:	4c 87       	std	Y+12, r20	; 0x0c
    1304:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1306:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    1308:	88 85       	ldd	r24, Y+8	; 0x08
    130a:	99 85       	ldd	r25, Y+9	; 0x09
    130c:	9a 83       	std	Y+2, r25	; 0x02
    130e:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1310:	0f b6       	in	r0, 0x3f	; 63
    1312:	f8 94       	cli
    1314:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1316:	e9 81       	ldd	r30, Y+1	; 0x01
    1318:	fa 81       	ldd	r31, Y+2	; 0x02
    131a:	92 8d       	ldd	r25, Z+26	; 0x1a
    131c:	e9 81       	ldd	r30, Y+1	; 0x01
    131e:	fa 81       	ldd	r31, Y+2	; 0x02
    1320:	83 8d       	ldd	r24, Z+27	; 0x1b
    1322:	98 17       	cp	r25, r24
    1324:	18 f0       	brcs	.+6      	; 0x132c <xQueueGenericSend+0x48>
    1326:	8e 85       	ldd	r24, Y+14	; 0x0e
    1328:	82 30       	cpi	r24, 0x02	; 2
    132a:	11 f5       	brne	.+68     	; 0x1370 <xQueueGenericSend+0x8c>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    132c:	89 81       	ldd	r24, Y+1	; 0x01
    132e:	9a 81       	ldd	r25, Y+2	; 0x02
    1330:	2a 85       	ldd	r18, Y+10	; 0x0a
    1332:	3b 85       	ldd	r19, Y+11	; 0x0b
    1334:	b9 01       	movw	r22, r18
    1336:	4e 85       	ldd	r20, Y+14	; 0x0e
    1338:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <prvCopyDataToQueue>
    133c:	8b 83       	std	Y+3, r24	; 0x03

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    133e:	e9 81       	ldd	r30, Y+1	; 0x01
    1340:	fa 81       	ldd	r31, Y+2	; 0x02
    1342:	81 89       	ldd	r24, Z+17	; 0x11
    1344:	88 23       	and	r24, r24
    1346:	51 f0       	breq	.+20     	; 0x135c <xQueueGenericSend+0x78>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1348:	89 81       	ldd	r24, Y+1	; 0x01
    134a:	9a 81       	ldd	r25, Y+2	; 0x02
    134c:	41 96       	adiw	r24, 0x11	; 17
    134e:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <xTaskRemoveFromEventList>
    1352:	88 23       	and	r24, r24
    1354:	41 f0       	breq	.+16     	; 0x1366 <xQueueGenericSend+0x82>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    1356:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    135a:	05 c0       	rjmp	.+10     	; 0x1366 <xQueueGenericSend+0x82>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    135c:	8b 81       	ldd	r24, Y+3	; 0x03
    135e:	88 23       	and	r24, r24
    1360:	11 f0       	breq	.+4      	; 0x1366 <xQueueGenericSend+0x82>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    1362:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1366:	0f 90       	pop	r0
    1368:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    136a:	81 e0       	ldi	r24, 0x01	; 1
    136c:	8f 87       	std	Y+15, r24	; 0x0f
    136e:	5c c0       	rjmp	.+184    	; 0x1428 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1370:	8c 85       	ldd	r24, Y+12	; 0x0c
    1372:	9d 85       	ldd	r25, Y+13	; 0x0d
    1374:	00 97       	sbiw	r24, 0x00	; 0
    1376:	21 f4       	brne	.+8      	; 0x1380 <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1378:	0f 90       	pop	r0
    137a:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    137c:	1f 86       	std	Y+15, r1	; 0x0f
    137e:	54 c0       	rjmp	.+168    	; 0x1428 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    1380:	8c 81       	ldd	r24, Y+4	; 0x04
    1382:	88 23       	and	r24, r24
    1384:	31 f4       	brne	.+12     	; 0x1392 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1386:	ce 01       	movw	r24, r28
    1388:	05 96       	adiw	r24, 0x05	; 5
    138a:	0e 94 b1 21 	call	0x4362	; 0x4362 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    138e:	81 e0       	ldi	r24, 0x01	; 1
    1390:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1392:	0f 90       	pop	r0
    1394:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1396:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    139a:	0f b6       	in	r0, 0x3f	; 63
    139c:	f8 94       	cli
    139e:	0f 92       	push	r0
    13a0:	e9 81       	ldd	r30, Y+1	; 0x01
    13a2:	fa 81       	ldd	r31, Y+2	; 0x02
    13a4:	85 8d       	ldd	r24, Z+29	; 0x1d
    13a6:	8f 3f       	cpi	r24, 0xFF	; 255
    13a8:	19 f4       	brne	.+6      	; 0x13b0 <xQueueGenericSend+0xcc>
    13aa:	e9 81       	ldd	r30, Y+1	; 0x01
    13ac:	fa 81       	ldd	r31, Y+2	; 0x02
    13ae:	15 8e       	std	Z+29, r1	; 0x1d
    13b0:	e9 81       	ldd	r30, Y+1	; 0x01
    13b2:	fa 81       	ldd	r31, Y+2	; 0x02
    13b4:	86 8d       	ldd	r24, Z+30	; 0x1e
    13b6:	8f 3f       	cpi	r24, 0xFF	; 255
    13b8:	19 f4       	brne	.+6      	; 0x13c0 <xQueueGenericSend+0xdc>
    13ba:	e9 81       	ldd	r30, Y+1	; 0x01
    13bc:	fa 81       	ldd	r31, Y+2	; 0x02
    13be:	16 8e       	std	Z+30, r1	; 0x1e
    13c0:	0f 90       	pop	r0
    13c2:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13c4:	ce 01       	movw	r24, r28
    13c6:	05 96       	adiw	r24, 0x05	; 5
    13c8:	9e 01       	movw	r18, r28
    13ca:	24 5f       	subi	r18, 0xF4	; 244
    13cc:	3f 4f       	sbci	r19, 0xFF	; 255
    13ce:	b9 01       	movw	r22, r18
    13d0:	0e 94 ca 21 	call	0x4394	; 0x4394 <xTaskCheckForTimeOut>
    13d4:	88 23       	and	r24, r24
    13d6:	09 f5       	brne	.+66     	; 0x141a <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    13d8:	89 81       	ldd	r24, Y+1	; 0x01
    13da:	9a 81       	ldd	r25, Y+2	; 0x02
    13dc:	0e 94 59 0f 	call	0x1eb2	; 0x1eb2 <prvIsQueueFull>
    13e0:	88 23       	and	r24, r24
    13e2:	a1 f0       	breq	.+40     	; 0x140c <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    13e4:	89 81       	ldd	r24, Y+1	; 0x01
    13e6:	9a 81       	ldd	r25, Y+2	; 0x02
    13e8:	08 96       	adiw	r24, 0x08	; 8
    13ea:	2c 85       	ldd	r18, Y+12	; 0x0c
    13ec:	3d 85       	ldd	r19, Y+13	; 0x0d
    13ee:	b9 01       	movw	r22, r18
    13f0:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    13f4:	89 81       	ldd	r24, Y+1	; 0x01
    13f6:	9a 81       	ldd	r25, Y+2	; 0x02
    13f8:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    13fc:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    1400:	88 23       	and	r24, r24
    1402:	09 f0       	breq	.+2      	; 0x1406 <xQueueGenericSend+0x122>
    1404:	85 cf       	rjmp	.-246    	; 0x1310 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    1406:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    140a:	82 cf       	rjmp	.-252    	; 0x1310 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    140c:	89 81       	ldd	r24, Y+1	; 0x01
    140e:	9a 81       	ldd	r25, Y+2	; 0x02
    1410:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1414:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    1418:	7b cf       	rjmp	.-266    	; 0x1310 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    141a:	89 81       	ldd	r24, Y+1	; 0x01
    141c:	9a 81       	ldd	r25, Y+2	; 0x02
    141e:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1422:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    1426:	1f 86       	std	Y+15, r1	; 0x0f
    1428:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    142a:	2f 96       	adiw	r28, 0x0f	; 15
    142c:	0f b6       	in	r0, 0x3f	; 63
    142e:	f8 94       	cli
    1430:	de bf       	out	0x3e, r29	; 62
    1432:	0f be       	out	0x3f, r0	; 63
    1434:	cd bf       	out	0x3d, r28	; 61
    1436:	cf 91       	pop	r28
    1438:	df 91       	pop	r29
    143a:	08 95       	ret

0000143c <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    143c:	df 93       	push	r29
    143e:	cf 93       	push	r28
    1440:	cd b7       	in	r28, 0x3d	; 61
    1442:	de b7       	in	r29, 0x3e	; 62
    1444:	2e 97       	sbiw	r28, 0x0e	; 14
    1446:	0f b6       	in	r0, 0x3f	; 63
    1448:	f8 94       	cli
    144a:	de bf       	out	0x3e, r29	; 62
    144c:	0f be       	out	0x3f, r0	; 63
    144e:	cd bf       	out	0x3d, r28	; 61
    1450:	99 87       	std	Y+9, r25	; 0x09
    1452:	88 87       	std	Y+8, r24	; 0x08
    1454:	7b 87       	std	Y+11, r23	; 0x0b
    1456:	6a 87       	std	Y+10, r22	; 0x0a
    1458:	5d 87       	std	Y+13, r21	; 0x0d
    145a:	4c 87       	std	Y+12, r20	; 0x0c
    145c:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    145e:	88 85       	ldd	r24, Y+8	; 0x08
    1460:	99 85       	ldd	r25, Y+9	; 0x09
    1462:	9d 83       	std	Y+5, r25	; 0x05
    1464:	8c 83       	std	Y+4, r24	; 0x04
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1466:	1e 82       	std	Y+6, r1	; 0x06
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1468:	ec 81       	ldd	r30, Y+4	; 0x04
    146a:	fd 81       	ldd	r31, Y+5	; 0x05
    146c:	92 8d       	ldd	r25, Z+26	; 0x1a
    146e:	ec 81       	ldd	r30, Y+4	; 0x04
    1470:	fd 81       	ldd	r31, Y+5	; 0x05
    1472:	83 8d       	ldd	r24, Z+27	; 0x1b
    1474:	98 17       	cp	r25, r24
    1476:	18 f0       	brcs	.+6      	; 0x147e <xQueueGenericSendFromISR+0x42>
    1478:	8e 85       	ldd	r24, Y+14	; 0x0e
    147a:	82 30       	cpi	r24, 0x02	; 2
    147c:	b9 f5       	brne	.+110    	; 0x14ec <xQueueGenericSendFromISR+0xb0>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    147e:	ec 81       	ldd	r30, Y+4	; 0x04
    1480:	fd 81       	ldd	r31, Y+5	; 0x05
    1482:	86 8d       	ldd	r24, Z+30	; 0x1e
    1484:	8b 83       	std	Y+3, r24	; 0x03
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    1486:	ec 81       	ldd	r30, Y+4	; 0x04
    1488:	fd 81       	ldd	r31, Y+5	; 0x05
    148a:	82 8d       	ldd	r24, Z+26	; 0x1a
    148c:	8a 83       	std	Y+2, r24	; 0x02
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    148e:	8c 81       	ldd	r24, Y+4	; 0x04
    1490:	9d 81       	ldd	r25, Y+5	; 0x05
    1492:	2a 85       	ldd	r18, Y+10	; 0x0a
    1494:	3b 85       	ldd	r19, Y+11	; 0x0b
    1496:	b9 01       	movw	r22, r18
    1498:	4e 85       	ldd	r20, Y+14	; 0x0e
    149a:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    149e:	8b 81       	ldd	r24, Y+3	; 0x03
    14a0:	8f 3f       	cpi	r24, 0xFF	; 255
    14a2:	a9 f4       	brne	.+42     	; 0x14ce <xQueueGenericSendFromISR+0x92>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14a4:	ec 81       	ldd	r30, Y+4	; 0x04
    14a6:	fd 81       	ldd	r31, Y+5	; 0x05
    14a8:	81 89       	ldd	r24, Z+17	; 0x11
    14aa:	88 23       	and	r24, r24
    14ac:	e1 f0       	breq	.+56     	; 0x14e6 <xQueueGenericSendFromISR+0xaa>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14ae:	8c 81       	ldd	r24, Y+4	; 0x04
    14b0:	9d 81       	ldd	r25, Y+5	; 0x05
    14b2:	41 96       	adiw	r24, 0x11	; 17
    14b4:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <xTaskRemoveFromEventList>
    14b8:	88 23       	and	r24, r24
    14ba:	a9 f0       	breq	.+42     	; 0x14e6 <xQueueGenericSendFromISR+0xaa>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    14bc:	8c 85       	ldd	r24, Y+12	; 0x0c
    14be:	9d 85       	ldd	r25, Y+13	; 0x0d
    14c0:	00 97       	sbiw	r24, 0x00	; 0
    14c2:	89 f0       	breq	.+34     	; 0x14e6 <xQueueGenericSendFromISR+0xaa>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    14c4:	ec 85       	ldd	r30, Y+12	; 0x0c
    14c6:	fd 85       	ldd	r31, Y+13	; 0x0d
    14c8:	81 e0       	ldi	r24, 0x01	; 1
    14ca:	80 83       	st	Z, r24
    14cc:	0c c0       	rjmp	.+24     	; 0x14e6 <xQueueGenericSendFromISR+0xaa>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    14ce:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <uxTaskGetNumberOfTasks>
    14d2:	89 83       	std	Y+1, r24	; 0x01
    14d4:	9b 81       	ldd	r25, Y+3	; 0x03
    14d6:	89 81       	ldd	r24, Y+1	; 0x01
    14d8:	98 17       	cp	r25, r24
    14da:	28 f4       	brcc	.+10     	; 0x14e6 <xQueueGenericSendFromISR+0xaa>
    14dc:	8b 81       	ldd	r24, Y+3	; 0x03
    14de:	8f 5f       	subi	r24, 0xFF	; 255
    14e0:	ec 81       	ldd	r30, Y+4	; 0x04
    14e2:	fd 81       	ldd	r31, Y+5	; 0x05
    14e4:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    14e6:	81 e0       	ldi	r24, 0x01	; 1
    14e8:	8f 83       	std	Y+7, r24	; 0x07
    14ea:	01 c0       	rjmp	.+2      	; 0x14ee <xQueueGenericSendFromISR+0xb2>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    14ec:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    14ee:	8f 81       	ldd	r24, Y+7	; 0x07
}
    14f0:	2e 96       	adiw	r28, 0x0e	; 14
    14f2:	0f b6       	in	r0, 0x3f	; 63
    14f4:	f8 94       	cli
    14f6:	de bf       	out	0x3e, r29	; 62
    14f8:	0f be       	out	0x3f, r0	; 63
    14fa:	cd bf       	out	0x3d, r28	; 61
    14fc:	cf 91       	pop	r28
    14fe:	df 91       	pop	r29
    1500:	08 95       	ret

00001502 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    1502:	df 93       	push	r29
    1504:	cf 93       	push	r28
    1506:	cd b7       	in	r28, 0x3d	; 61
    1508:	de b7       	in	r29, 0x3e	; 62
    150a:	2b 97       	sbiw	r28, 0x0b	; 11
    150c:	0f b6       	in	r0, 0x3f	; 63
    150e:	f8 94       	cli
    1510:	de bf       	out	0x3e, r29	; 62
    1512:	0f be       	out	0x3f, r0	; 63
    1514:	cd bf       	out	0x3d, r28	; 61
    1516:	99 87       	std	Y+9, r25	; 0x09
    1518:	88 87       	std	Y+8, r24	; 0x08
    151a:	7b 87       	std	Y+11, r23	; 0x0b
    151c:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    151e:	88 85       	ldd	r24, Y+8	; 0x08
    1520:	99 85       	ldd	r25, Y+9	; 0x09
    1522:	9d 83       	std	Y+5, r25	; 0x05
    1524:	8c 83       	std	Y+4, r24	; 0x04
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1526:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1528:	ec 81       	ldd	r30, Y+4	; 0x04
    152a:	fd 81       	ldd	r31, Y+5	; 0x05
    152c:	82 8d       	ldd	r24, Z+26	; 0x1a
    152e:	8b 83       	std	Y+3, r24	; 0x03

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    1530:	ec 81       	ldd	r30, Y+4	; 0x04
    1532:	fd 81       	ldd	r31, Y+5	; 0x05
    1534:	93 8d       	ldd	r25, Z+27	; 0x1b
    1536:	8b 81       	ldd	r24, Y+3	; 0x03
    1538:	89 17       	cp	r24, r25
    153a:	80 f5       	brcc	.+96     	; 0x159c <xQueueGiveFromISR+0x9a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    153c:	ec 81       	ldd	r30, Y+4	; 0x04
    153e:	fd 81       	ldd	r31, Y+5	; 0x05
    1540:	86 8d       	ldd	r24, Z+30	; 0x1e
    1542:	8a 83       	std	Y+2, r24	; 0x02
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1544:	8b 81       	ldd	r24, Y+3	; 0x03
    1546:	8f 5f       	subi	r24, 0xFF	; 255
    1548:	ec 81       	ldd	r30, Y+4	; 0x04
    154a:	fd 81       	ldd	r31, Y+5	; 0x05
    154c:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    154e:	8a 81       	ldd	r24, Y+2	; 0x02
    1550:	8f 3f       	cpi	r24, 0xFF	; 255
    1552:	a9 f4       	brne	.+42     	; 0x157e <xQueueGiveFromISR+0x7c>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1554:	ec 81       	ldd	r30, Y+4	; 0x04
    1556:	fd 81       	ldd	r31, Y+5	; 0x05
    1558:	81 89       	ldd	r24, Z+17	; 0x11
    155a:	88 23       	and	r24, r24
    155c:	e1 f0       	breq	.+56     	; 0x1596 <xQueueGiveFromISR+0x94>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    155e:	8c 81       	ldd	r24, Y+4	; 0x04
    1560:	9d 81       	ldd	r25, Y+5	; 0x05
    1562:	41 96       	adiw	r24, 0x11	; 17
    1564:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <xTaskRemoveFromEventList>
    1568:	88 23       	and	r24, r24
    156a:	a9 f0       	breq	.+42     	; 0x1596 <xQueueGiveFromISR+0x94>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    156c:	8a 85       	ldd	r24, Y+10	; 0x0a
    156e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1570:	00 97       	sbiw	r24, 0x00	; 0
    1572:	89 f0       	breq	.+34     	; 0x1596 <xQueueGiveFromISR+0x94>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    1574:	ea 85       	ldd	r30, Y+10	; 0x0a
    1576:	fb 85       	ldd	r31, Y+11	; 0x0b
    1578:	81 e0       	ldi	r24, 0x01	; 1
    157a:	80 83       	st	Z, r24
    157c:	0c c0       	rjmp	.+24     	; 0x1596 <xQueueGiveFromISR+0x94>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    157e:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <uxTaskGetNumberOfTasks>
    1582:	89 83       	std	Y+1, r24	; 0x01
    1584:	9a 81       	ldd	r25, Y+2	; 0x02
    1586:	89 81       	ldd	r24, Y+1	; 0x01
    1588:	98 17       	cp	r25, r24
    158a:	28 f4       	brcc	.+10     	; 0x1596 <xQueueGiveFromISR+0x94>
    158c:	8a 81       	ldd	r24, Y+2	; 0x02
    158e:	8f 5f       	subi	r24, 0xFF	; 255
    1590:	ec 81       	ldd	r30, Y+4	; 0x04
    1592:	fd 81       	ldd	r31, Y+5	; 0x05
    1594:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	8f 83       	std	Y+7, r24	; 0x07
    159a:	01 c0       	rjmp	.+2      	; 0x159e <xQueueGiveFromISR+0x9c>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    159c:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    159e:	8f 81       	ldd	r24, Y+7	; 0x07
}
    15a0:	2b 96       	adiw	r28, 0x0b	; 11
    15a2:	0f b6       	in	r0, 0x3f	; 63
    15a4:	f8 94       	cli
    15a6:	de bf       	out	0x3e, r29	; 62
    15a8:	0f be       	out	0x3f, r0	; 63
    15aa:	cd bf       	out	0x3d, r28	; 61
    15ac:	cf 91       	pop	r28
    15ae:	df 91       	pop	r29
    15b0:	08 95       	ret

000015b2 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    15b2:	df 93       	push	r29
    15b4:	cf 93       	push	r28
    15b6:	cd b7       	in	r28, 0x3d	; 61
    15b8:	de b7       	in	r29, 0x3e	; 62
    15ba:	2e 97       	sbiw	r28, 0x0e	; 14
    15bc:	0f b6       	in	r0, 0x3f	; 63
    15be:	f8 94       	cli
    15c0:	de bf       	out	0x3e, r29	; 62
    15c2:	0f be       	out	0x3f, r0	; 63
    15c4:	cd bf       	out	0x3d, r28	; 61
    15c6:	99 87       	std	Y+9, r25	; 0x09
    15c8:	88 87       	std	Y+8, r24	; 0x08
    15ca:	7b 87       	std	Y+11, r23	; 0x0b
    15cc:	6a 87       	std	Y+10, r22	; 0x0a
    15ce:	5d 87       	std	Y+13, r21	; 0x0d
    15d0:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    15d2:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    15d4:	88 85       	ldd	r24, Y+8	; 0x08
    15d6:	99 85       	ldd	r25, Y+9	; 0x09
    15d8:	9b 83       	std	Y+3, r25	; 0x03
    15da:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    15dc:	0f b6       	in	r0, 0x3f	; 63
    15de:	f8 94       	cli
    15e0:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15e2:	ea 81       	ldd	r30, Y+2	; 0x02
    15e4:	fb 81       	ldd	r31, Y+3	; 0x03
    15e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    15e8:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15ea:	89 81       	ldd	r24, Y+1	; 0x01
    15ec:	88 23       	and	r24, r24
    15ee:	f9 f0       	breq	.+62     	; 0x162e <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    15f0:	8a 81       	ldd	r24, Y+2	; 0x02
    15f2:	9b 81       	ldd	r25, Y+3	; 0x03
    15f4:	2a 85       	ldd	r18, Y+10	; 0x0a
    15f6:	3b 85       	ldd	r19, Y+11	; 0x0b
    15f8:	b9 01       	movw	r22, r18
    15fa:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    15fe:	89 81       	ldd	r24, Y+1	; 0x01
    1600:	81 50       	subi	r24, 0x01	; 1
    1602:	ea 81       	ldd	r30, Y+2	; 0x02
    1604:	fb 81       	ldd	r31, Y+3	; 0x03
    1606:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1608:	ea 81       	ldd	r30, Y+2	; 0x02
    160a:	fb 81       	ldd	r31, Y+3	; 0x03
    160c:	80 85       	ldd	r24, Z+8	; 0x08
    160e:	88 23       	and	r24, r24
    1610:	49 f0       	breq	.+18     	; 0x1624 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1612:	8a 81       	ldd	r24, Y+2	; 0x02
    1614:	9b 81       	ldd	r25, Y+3	; 0x03
    1616:	08 96       	adiw	r24, 0x08	; 8
    1618:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <xTaskRemoveFromEventList>
    161c:	88 23       	and	r24, r24
    161e:	11 f0       	breq	.+4      	; 0x1624 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1620:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1624:	0f 90       	pop	r0
    1626:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1628:	81 e0       	ldi	r24, 0x01	; 1
    162a:	8e 87       	std	Y+14, r24	; 0x0e
    162c:	63 c0       	rjmp	.+198    	; 0x16f4 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    162e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1630:	9d 85       	ldd	r25, Y+13	; 0x0d
    1632:	00 97       	sbiw	r24, 0x00	; 0
    1634:	21 f4       	brne	.+8      	; 0x163e <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1636:	0f 90       	pop	r0
    1638:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    163a:	1e 86       	std	Y+14, r1	; 0x0e
    163c:	5b c0       	rjmp	.+182    	; 0x16f4 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    163e:	8c 81       	ldd	r24, Y+4	; 0x04
    1640:	88 23       	and	r24, r24
    1642:	31 f4       	brne	.+12     	; 0x1650 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1644:	ce 01       	movw	r24, r28
    1646:	05 96       	adiw	r24, 0x05	; 5
    1648:	0e 94 b1 21 	call	0x4362	; 0x4362 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    164c:	81 e0       	ldi	r24, 0x01	; 1
    164e:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1650:	0f 90       	pop	r0
    1652:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1654:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1658:	0f b6       	in	r0, 0x3f	; 63
    165a:	f8 94       	cli
    165c:	0f 92       	push	r0
    165e:	ea 81       	ldd	r30, Y+2	; 0x02
    1660:	fb 81       	ldd	r31, Y+3	; 0x03
    1662:	85 8d       	ldd	r24, Z+29	; 0x1d
    1664:	8f 3f       	cpi	r24, 0xFF	; 255
    1666:	19 f4       	brne	.+6      	; 0x166e <xQueueReceive+0xbc>
    1668:	ea 81       	ldd	r30, Y+2	; 0x02
    166a:	fb 81       	ldd	r31, Y+3	; 0x03
    166c:	15 8e       	std	Z+29, r1	; 0x1d
    166e:	ea 81       	ldd	r30, Y+2	; 0x02
    1670:	fb 81       	ldd	r31, Y+3	; 0x03
    1672:	86 8d       	ldd	r24, Z+30	; 0x1e
    1674:	8f 3f       	cpi	r24, 0xFF	; 255
    1676:	19 f4       	brne	.+6      	; 0x167e <xQueueReceive+0xcc>
    1678:	ea 81       	ldd	r30, Y+2	; 0x02
    167a:	fb 81       	ldd	r31, Y+3	; 0x03
    167c:	16 8e       	std	Z+30, r1	; 0x1e
    167e:	0f 90       	pop	r0
    1680:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1682:	ce 01       	movw	r24, r28
    1684:	05 96       	adiw	r24, 0x05	; 5
    1686:	9e 01       	movw	r18, r28
    1688:	24 5f       	subi	r18, 0xF4	; 244
    168a:	3f 4f       	sbci	r19, 0xFF	; 255
    168c:	b9 01       	movw	r22, r18
    168e:	0e 94 ca 21 	call	0x4394	; 0x4394 <xTaskCheckForTimeOut>
    1692:	88 23       	and	r24, r24
    1694:	09 f5       	brne	.+66     	; 0x16d8 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1696:	8a 81       	ldd	r24, Y+2	; 0x02
    1698:	9b 81       	ldd	r25, Y+3	; 0x03
    169a:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    169e:	88 23       	and	r24, r24
    16a0:	a1 f0       	breq	.+40     	; 0x16ca <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16a2:	8a 81       	ldd	r24, Y+2	; 0x02
    16a4:	9b 81       	ldd	r25, Y+3	; 0x03
    16a6:	41 96       	adiw	r24, 0x11	; 17
    16a8:	2c 85       	ldd	r18, Y+12	; 0x0c
    16aa:	3d 85       	ldd	r19, Y+13	; 0x0d
    16ac:	b9 01       	movw	r22, r18
    16ae:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    16b2:	8a 81       	ldd	r24, Y+2	; 0x02
    16b4:	9b 81       	ldd	r25, Y+3	; 0x03
    16b6:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    16ba:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    16be:	88 23       	and	r24, r24
    16c0:	09 f0       	breq	.+2      	; 0x16c4 <xQueueReceive+0x112>
    16c2:	8c cf       	rjmp	.-232    	; 0x15dc <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    16c4:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    16c8:	89 cf       	rjmp	.-238    	; 0x15dc <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    16ca:	8a 81       	ldd	r24, Y+2	; 0x02
    16cc:	9b 81       	ldd	r25, Y+3	; 0x03
    16ce:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    16d2:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    16d6:	82 cf       	rjmp	.-252    	; 0x15dc <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    16d8:	8a 81       	ldd	r24, Y+2	; 0x02
    16da:	9b 81       	ldd	r25, Y+3	; 0x03
    16dc:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    16e0:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16e4:	8a 81       	ldd	r24, Y+2	; 0x02
    16e6:	9b 81       	ldd	r25, Y+3	; 0x03
    16e8:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    16ec:	88 23       	and	r24, r24
    16ee:	09 f4       	brne	.+2      	; 0x16f2 <xQueueReceive+0x140>
    16f0:	75 cf       	rjmp	.-278    	; 0x15dc <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    16f2:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    16f4:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    16f6:	2e 96       	adiw	r28, 0x0e	; 14
    16f8:	0f b6       	in	r0, 0x3f	; 63
    16fa:	f8 94       	cli
    16fc:	de bf       	out	0x3e, r29	; 62
    16fe:	0f be       	out	0x3f, r0	; 63
    1700:	cd bf       	out	0x3d, r28	; 61
    1702:	cf 91       	pop	r28
    1704:	df 91       	pop	r29
    1706:	08 95       	ret

00001708 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    1708:	df 93       	push	r29
    170a:	cf 93       	push	r28
    170c:	cd b7       	in	r28, 0x3d	; 61
    170e:	de b7       	in	r29, 0x3e	; 62
    1710:	2c 97       	sbiw	r28, 0x0c	; 12
    1712:	0f b6       	in	r0, 0x3f	; 63
    1714:	f8 94       	cli
    1716:	de bf       	out	0x3e, r29	; 62
    1718:	0f be       	out	0x3f, r0	; 63
    171a:	cd bf       	out	0x3d, r28	; 61
    171c:	99 87       	std	Y+9, r25	; 0x09
    171e:	88 87       	std	Y+8, r24	; 0x08
    1720:	7b 87       	std	Y+11, r23	; 0x0b
    1722:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    1724:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    1726:	88 85       	ldd	r24, Y+8	; 0x08
    1728:	99 85       	ldd	r25, Y+9	; 0x09
    172a:	9b 83       	std	Y+3, r25	; 0x03
    172c:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    172e:	0f b6       	in	r0, 0x3f	; 63
    1730:	f8 94       	cli
    1732:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1734:	ea 81       	ldd	r30, Y+2	; 0x02
    1736:	fb 81       	ldd	r31, Y+3	; 0x03
    1738:	82 8d       	ldd	r24, Z+26	; 0x1a
    173a:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    173c:	89 81       	ldd	r24, Y+1	; 0x01
    173e:	88 23       	and	r24, r24
    1740:	c1 f0       	breq	.+48     	; 0x1772 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1742:	89 81       	ldd	r24, Y+1	; 0x01
    1744:	81 50       	subi	r24, 0x01	; 1
    1746:	ea 81       	ldd	r30, Y+2	; 0x02
    1748:	fb 81       	ldd	r31, Y+3	; 0x03
    174a:	82 8f       	std	Z+26, r24	; 0x1a
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    174c:	ea 81       	ldd	r30, Y+2	; 0x02
    174e:	fb 81       	ldd	r31, Y+3	; 0x03
    1750:	80 85       	ldd	r24, Z+8	; 0x08
    1752:	88 23       	and	r24, r24
    1754:	49 f0       	breq	.+18     	; 0x1768 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1756:	8a 81       	ldd	r24, Y+2	; 0x02
    1758:	9b 81       	ldd	r25, Y+3	; 0x03
    175a:	08 96       	adiw	r24, 0x08	; 8
    175c:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <xTaskRemoveFromEventList>
    1760:	88 23       	and	r24, r24
    1762:	11 f0       	breq	.+4      	; 0x1768 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1764:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1768:	0f 90       	pop	r0
    176a:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    176c:	81 e0       	ldi	r24, 0x01	; 1
    176e:	8c 87       	std	Y+12, r24	; 0x0c
    1770:	63 c0       	rjmp	.+198    	; 0x1838 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1772:	8a 85       	ldd	r24, Y+10	; 0x0a
    1774:	9b 85       	ldd	r25, Y+11	; 0x0b
    1776:	00 97       	sbiw	r24, 0x00	; 0
    1778:	21 f4       	brne	.+8      	; 0x1782 <xQueueSemaphoreTake+0x7a>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    177a:	0f 90       	pop	r0
    177c:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    177e:	1c 86       	std	Y+12, r1	; 0x0c
    1780:	5b c0       	rjmp	.+182    	; 0x1838 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    1782:	8c 81       	ldd	r24, Y+4	; 0x04
    1784:	88 23       	and	r24, r24
    1786:	31 f4       	brne	.+12     	; 0x1794 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1788:	ce 01       	movw	r24, r28
    178a:	05 96       	adiw	r24, 0x05	; 5
    178c:	0e 94 b1 21 	call	0x4362	; 0x4362 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1790:	81 e0       	ldi	r24, 0x01	; 1
    1792:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1794:	0f 90       	pop	r0
    1796:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1798:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    179c:	0f b6       	in	r0, 0x3f	; 63
    179e:	f8 94       	cli
    17a0:	0f 92       	push	r0
    17a2:	ea 81       	ldd	r30, Y+2	; 0x02
    17a4:	fb 81       	ldd	r31, Y+3	; 0x03
    17a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    17a8:	8f 3f       	cpi	r24, 0xFF	; 255
    17aa:	19 f4       	brne	.+6      	; 0x17b2 <xQueueSemaphoreTake+0xaa>
    17ac:	ea 81       	ldd	r30, Y+2	; 0x02
    17ae:	fb 81       	ldd	r31, Y+3	; 0x03
    17b0:	15 8e       	std	Z+29, r1	; 0x1d
    17b2:	ea 81       	ldd	r30, Y+2	; 0x02
    17b4:	fb 81       	ldd	r31, Y+3	; 0x03
    17b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    17b8:	8f 3f       	cpi	r24, 0xFF	; 255
    17ba:	19 f4       	brne	.+6      	; 0x17c2 <xQueueSemaphoreTake+0xba>
    17bc:	ea 81       	ldd	r30, Y+2	; 0x02
    17be:	fb 81       	ldd	r31, Y+3	; 0x03
    17c0:	16 8e       	std	Z+30, r1	; 0x1e
    17c2:	0f 90       	pop	r0
    17c4:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    17c6:	ce 01       	movw	r24, r28
    17c8:	05 96       	adiw	r24, 0x05	; 5
    17ca:	9e 01       	movw	r18, r28
    17cc:	26 5f       	subi	r18, 0xF6	; 246
    17ce:	3f 4f       	sbci	r19, 0xFF	; 255
    17d0:	b9 01       	movw	r22, r18
    17d2:	0e 94 ca 21 	call	0x4394	; 0x4394 <xTaskCheckForTimeOut>
    17d6:	88 23       	and	r24, r24
    17d8:	09 f5       	brne	.+66     	; 0x181c <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17da:	8a 81       	ldd	r24, Y+2	; 0x02
    17dc:	9b 81       	ldd	r25, Y+3	; 0x03
    17de:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    17e2:	88 23       	and	r24, r24
    17e4:	a1 f0       	breq	.+40     	; 0x180e <xQueueSemaphoreTake+0x106>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17e6:	8a 81       	ldd	r24, Y+2	; 0x02
    17e8:	9b 81       	ldd	r25, Y+3	; 0x03
    17ea:	41 96       	adiw	r24, 0x11	; 17
    17ec:	2a 85       	ldd	r18, Y+10	; 0x0a
    17ee:	3b 85       	ldd	r19, Y+11	; 0x0b
    17f0:	b9 01       	movw	r22, r18
    17f2:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    17f6:	8a 81       	ldd	r24, Y+2	; 0x02
    17f8:	9b 81       	ldd	r25, Y+3	; 0x03
    17fa:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    17fe:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    1802:	88 23       	and	r24, r24
    1804:	09 f0       	breq	.+2      	; 0x1808 <xQueueSemaphoreTake+0x100>
    1806:	93 cf       	rjmp	.-218    	; 0x172e <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    1808:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    180c:	90 cf       	rjmp	.-224    	; 0x172e <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    180e:	8a 81       	ldd	r24, Y+2	; 0x02
    1810:	9b 81       	ldd	r25, Y+3	; 0x03
    1812:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1816:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    181a:	89 cf       	rjmp	.-238    	; 0x172e <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    181c:	8a 81       	ldd	r24, Y+2	; 0x02
    181e:	9b 81       	ldd	r25, Y+3	; 0x03
    1820:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1824:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1828:	8a 81       	ldd	r24, Y+2	; 0x02
    182a:	9b 81       	ldd	r25, Y+3	; 0x03
    182c:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    1830:	88 23       	and	r24, r24
    1832:	09 f4       	brne	.+2      	; 0x1836 <xQueueSemaphoreTake+0x12e>
    1834:	7c cf       	rjmp	.-264    	; 0x172e <xQueueSemaphoreTake+0x26>
                    }
                }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    1836:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    1838:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    183a:	2c 96       	adiw	r28, 0x0c	; 12
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	f8 94       	cli
    1840:	de bf       	out	0x3e, r29	; 62
    1842:	0f be       	out	0x3f, r0	; 63
    1844:	cd bf       	out	0x3d, r28	; 61
    1846:	cf 91       	pop	r28
    1848:	df 91       	pop	r29
    184a:	08 95       	ret

0000184c <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    184c:	df 93       	push	r29
    184e:	cf 93       	push	r28
    1850:	cd b7       	in	r28, 0x3d	; 61
    1852:	de b7       	in	r29, 0x3e	; 62
    1854:	60 97       	sbiw	r28, 0x10	; 16
    1856:	0f b6       	in	r0, 0x3f	; 63
    1858:	f8 94       	cli
    185a:	de bf       	out	0x3e, r29	; 62
    185c:	0f be       	out	0x3f, r0	; 63
    185e:	cd bf       	out	0x3d, r28	; 61
    1860:	9b 87       	std	Y+11, r25	; 0x0b
    1862:	8a 87       	std	Y+10, r24	; 0x0a
    1864:	7d 87       	std	Y+13, r23	; 0x0d
    1866:	6c 87       	std	Y+12, r22	; 0x0c
    1868:	5f 87       	std	Y+15, r21	; 0x0f
    186a:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    186c:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    186e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1870:	9b 85       	ldd	r25, Y+11	; 0x0b
    1872:	9b 83       	std	Y+3, r25	; 0x03
    1874:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1876:	0f b6       	in	r0, 0x3f	; 63
    1878:	f8 94       	cli
    187a:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    187c:	ea 81       	ldd	r30, Y+2	; 0x02
    187e:	fb 81       	ldd	r31, Y+3	; 0x03
    1880:	82 8d       	ldd	r24, Z+26	; 0x1a
    1882:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1884:	89 81       	ldd	r24, Y+1	; 0x01
    1886:	88 23       	and	r24, r24
    1888:	31 f1       	breq	.+76     	; 0x18d6 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    188a:	ea 81       	ldd	r30, Y+2	; 0x02
    188c:	fb 81       	ldd	r31, Y+3	; 0x03
    188e:	86 81       	ldd	r24, Z+6	; 0x06
    1890:	97 81       	ldd	r25, Z+7	; 0x07
    1892:	9d 83       	std	Y+5, r25	; 0x05
    1894:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    1896:	8a 81       	ldd	r24, Y+2	; 0x02
    1898:	9b 81       	ldd	r25, Y+3	; 0x03
    189a:	2c 85       	ldd	r18, Y+12	; 0x0c
    189c:	3d 85       	ldd	r19, Y+13	; 0x0d
    189e:	b9 01       	movw	r22, r18
    18a0:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    18a4:	ea 81       	ldd	r30, Y+2	; 0x02
    18a6:	fb 81       	ldd	r31, Y+3	; 0x03
    18a8:	8c 81       	ldd	r24, Y+4	; 0x04
    18aa:	9d 81       	ldd	r25, Y+5	; 0x05
    18ac:	97 83       	std	Z+7, r25	; 0x07
    18ae:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18b0:	ea 81       	ldd	r30, Y+2	; 0x02
    18b2:	fb 81       	ldd	r31, Y+3	; 0x03
    18b4:	81 89       	ldd	r24, Z+17	; 0x11
    18b6:	88 23       	and	r24, r24
    18b8:	49 f0       	breq	.+18     	; 0x18cc <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18ba:	8a 81       	ldd	r24, Y+2	; 0x02
    18bc:	9b 81       	ldd	r25, Y+3	; 0x03
    18be:	41 96       	adiw	r24, 0x11	; 17
    18c0:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <xTaskRemoveFromEventList>
    18c4:	88 23       	and	r24, r24
    18c6:	11 f0       	breq	.+4      	; 0x18cc <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    18c8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    18cc:	0f 90       	pop	r0
    18ce:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	88 8b       	std	Y+16, r24	; 0x10
    18d4:	63 c0       	rjmp	.+198    	; 0x199c <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    18d6:	8e 85       	ldd	r24, Y+14	; 0x0e
    18d8:	9f 85       	ldd	r25, Y+15	; 0x0f
    18da:	00 97       	sbiw	r24, 0x00	; 0
    18dc:	21 f4       	brne	.+8      	; 0x18e6 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    18de:	0f 90       	pop	r0
    18e0:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    18e2:	18 8a       	std	Y+16, r1	; 0x10
    18e4:	5b c0       	rjmp	.+182    	; 0x199c <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    18e6:	8e 81       	ldd	r24, Y+6	; 0x06
    18e8:	88 23       	and	r24, r24
    18ea:	31 f4       	brne	.+12     	; 0x18f8 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    18ec:	ce 01       	movw	r24, r28
    18ee:	07 96       	adiw	r24, 0x07	; 7
    18f0:	0e 94 b1 21 	call	0x4362	; 0x4362 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    18f4:	81 e0       	ldi	r24, 0x01	; 1
    18f6:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    18f8:	0f 90       	pop	r0
    18fa:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    18fc:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1900:	0f b6       	in	r0, 0x3f	; 63
    1902:	f8 94       	cli
    1904:	0f 92       	push	r0
    1906:	ea 81       	ldd	r30, Y+2	; 0x02
    1908:	fb 81       	ldd	r31, Y+3	; 0x03
    190a:	85 8d       	ldd	r24, Z+29	; 0x1d
    190c:	8f 3f       	cpi	r24, 0xFF	; 255
    190e:	19 f4       	brne	.+6      	; 0x1916 <xQueuePeek+0xca>
    1910:	ea 81       	ldd	r30, Y+2	; 0x02
    1912:	fb 81       	ldd	r31, Y+3	; 0x03
    1914:	15 8e       	std	Z+29, r1	; 0x1d
    1916:	ea 81       	ldd	r30, Y+2	; 0x02
    1918:	fb 81       	ldd	r31, Y+3	; 0x03
    191a:	86 8d       	ldd	r24, Z+30	; 0x1e
    191c:	8f 3f       	cpi	r24, 0xFF	; 255
    191e:	19 f4       	brne	.+6      	; 0x1926 <xQueuePeek+0xda>
    1920:	ea 81       	ldd	r30, Y+2	; 0x02
    1922:	fb 81       	ldd	r31, Y+3	; 0x03
    1924:	16 8e       	std	Z+30, r1	; 0x1e
    1926:	0f 90       	pop	r0
    1928:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    192a:	ce 01       	movw	r24, r28
    192c:	07 96       	adiw	r24, 0x07	; 7
    192e:	9e 01       	movw	r18, r28
    1930:	22 5f       	subi	r18, 0xF2	; 242
    1932:	3f 4f       	sbci	r19, 0xFF	; 255
    1934:	b9 01       	movw	r22, r18
    1936:	0e 94 ca 21 	call	0x4394	; 0x4394 <xTaskCheckForTimeOut>
    193a:	88 23       	and	r24, r24
    193c:	09 f5       	brne	.+66     	; 0x1980 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    193e:	8a 81       	ldd	r24, Y+2	; 0x02
    1940:	9b 81       	ldd	r25, Y+3	; 0x03
    1942:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    1946:	88 23       	and	r24, r24
    1948:	a1 f0       	breq	.+40     	; 0x1972 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    194a:	8a 81       	ldd	r24, Y+2	; 0x02
    194c:	9b 81       	ldd	r25, Y+3	; 0x03
    194e:	41 96       	adiw	r24, 0x11	; 17
    1950:	2e 85       	ldd	r18, Y+14	; 0x0e
    1952:	3f 85       	ldd	r19, Y+15	; 0x0f
    1954:	b9 01       	movw	r22, r18
    1956:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    195a:	8a 81       	ldd	r24, Y+2	; 0x02
    195c:	9b 81       	ldd	r25, Y+3	; 0x03
    195e:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1962:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    1966:	88 23       	and	r24, r24
    1968:	09 f0       	breq	.+2      	; 0x196c <xQueuePeek+0x120>
    196a:	85 cf       	rjmp	.-246    	; 0x1876 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    196c:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1970:	82 cf       	rjmp	.-252    	; 0x1876 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    1972:	8a 81       	ldd	r24, Y+2	; 0x02
    1974:	9b 81       	ldd	r25, Y+3	; 0x03
    1976:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    197a:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    197e:	7b cf       	rjmp	.-266    	; 0x1876 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    1980:	8a 81       	ldd	r24, Y+2	; 0x02
    1982:	9b 81       	ldd	r25, Y+3	; 0x03
    1984:	0e 94 ca 0e 	call	0x1d94	; 0x1d94 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1988:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    198c:	8a 81       	ldd	r24, Y+2	; 0x02
    198e:	9b 81       	ldd	r25, Y+3	; 0x03
    1990:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <prvIsQueueEmpty>
    1994:	88 23       	and	r24, r24
    1996:	09 f4       	brne	.+2      	; 0x199a <xQueuePeek+0x14e>
    1998:	6e cf       	rjmp	.-292    	; 0x1876 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    199a:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    199c:	88 89       	ldd	r24, Y+16	; 0x10
}
    199e:	60 96       	adiw	r28, 0x10	; 16
    19a0:	0f b6       	in	r0, 0x3f	; 63
    19a2:	f8 94       	cli
    19a4:	de bf       	out	0x3e, r29	; 62
    19a6:	0f be       	out	0x3f, r0	; 63
    19a8:	cd bf       	out	0x3d, r28	; 61
    19aa:	cf 91       	pop	r28
    19ac:	df 91       	pop	r29
    19ae:	08 95       	ret

000019b0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    19b0:	df 93       	push	r29
    19b2:	cf 93       	push	r28
    19b4:	cd b7       	in	r28, 0x3d	; 61
    19b6:	de b7       	in	r29, 0x3e	; 62
    19b8:	2d 97       	sbiw	r28, 0x0d	; 13
    19ba:	0f b6       	in	r0, 0x3f	; 63
    19bc:	f8 94       	cli
    19be:	de bf       	out	0x3e, r29	; 62
    19c0:	0f be       	out	0x3f, r0	; 63
    19c2:	cd bf       	out	0x3d, r28	; 61
    19c4:	99 87       	std	Y+9, r25	; 0x09
    19c6:	88 87       	std	Y+8, r24	; 0x08
    19c8:	7b 87       	std	Y+11, r23	; 0x0b
    19ca:	6a 87       	std	Y+10, r22	; 0x0a
    19cc:	5d 87       	std	Y+13, r21	; 0x0d
    19ce:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    19d0:	88 85       	ldd	r24, Y+8	; 0x08
    19d2:	99 85       	ldd	r25, Y+9	; 0x09
    19d4:	9d 83       	std	Y+5, r25	; 0x05
    19d6:	8c 83       	std	Y+4, r24	; 0x04
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    19d8:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    19da:	ec 81       	ldd	r30, Y+4	; 0x04
    19dc:	fd 81       	ldd	r31, Y+5	; 0x05
    19de:	82 8d       	ldd	r24, Z+26	; 0x1a
    19e0:	8b 83       	std	Y+3, r24	; 0x03

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    19e2:	8b 81       	ldd	r24, Y+3	; 0x03
    19e4:	88 23       	and	r24, r24
    19e6:	b9 f1       	breq	.+110    	; 0x1a56 <xQueueReceiveFromISR+0xa6>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    19e8:	ec 81       	ldd	r30, Y+4	; 0x04
    19ea:	fd 81       	ldd	r31, Y+5	; 0x05
    19ec:	85 8d       	ldd	r24, Z+29	; 0x1d
    19ee:	8a 83       	std	Y+2, r24	; 0x02

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    19f0:	8c 81       	ldd	r24, Y+4	; 0x04
    19f2:	9d 81       	ldd	r25, Y+5	; 0x05
    19f4:	2a 85       	ldd	r18, Y+10	; 0x0a
    19f6:	3b 85       	ldd	r19, Y+11	; 0x0b
    19f8:	b9 01       	movw	r22, r18
    19fa:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    19fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1a00:	81 50       	subi	r24, 0x01	; 1
    1a02:	ec 81       	ldd	r30, Y+4	; 0x04
    1a04:	fd 81       	ldd	r31, Y+5	; 0x05
    1a06:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    1a08:	8a 81       	ldd	r24, Y+2	; 0x02
    1a0a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a0c:	a9 f4       	brne	.+42     	; 0x1a38 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a0e:	ec 81       	ldd	r30, Y+4	; 0x04
    1a10:	fd 81       	ldd	r31, Y+5	; 0x05
    1a12:	80 85       	ldd	r24, Z+8	; 0x08
    1a14:	88 23       	and	r24, r24
    1a16:	e1 f0       	breq	.+56     	; 0x1a50 <xQueueReceiveFromISR+0xa0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a18:	8c 81       	ldd	r24, Y+4	; 0x04
    1a1a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a1c:	08 96       	adiw	r24, 0x08	; 8
    1a1e:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <xTaskRemoveFromEventList>
    1a22:	88 23       	and	r24, r24
    1a24:	a9 f0       	breq	.+42     	; 0x1a50 <xQueueReceiveFromISR+0xa0>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    1a26:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a28:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a2a:	00 97       	sbiw	r24, 0x00	; 0
    1a2c:	89 f0       	breq	.+34     	; 0x1a50 <xQueueReceiveFromISR+0xa0>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    1a2e:	ec 85       	ldd	r30, Y+12	; 0x0c
    1a30:	fd 85       	ldd	r31, Y+13	; 0x0d
    1a32:	81 e0       	ldi	r24, 0x01	; 1
    1a34:	80 83       	st	Z, r24
    1a36:	0c c0       	rjmp	.+24     	; 0x1a50 <xQueueReceiveFromISR+0xa0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
    1a38:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <uxTaskGetNumberOfTasks>
    1a3c:	89 83       	std	Y+1, r24	; 0x01
    1a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a40:	89 81       	ldd	r24, Y+1	; 0x01
    1a42:	98 17       	cp	r25, r24
    1a44:	28 f4       	brcc	.+10     	; 0x1a50 <xQueueReceiveFromISR+0xa0>
    1a46:	8a 81       	ldd	r24, Y+2	; 0x02
    1a48:	8f 5f       	subi	r24, 0xFF	; 255
    1a4a:	ec 81       	ldd	r30, Y+4	; 0x04
    1a4c:	fd 81       	ldd	r31, Y+5	; 0x05
    1a4e:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    1a50:	81 e0       	ldi	r24, 0x01	; 1
    1a52:	8f 83       	std	Y+7, r24	; 0x07
    1a54:	01 c0       	rjmp	.+2      	; 0x1a58 <xQueueReceiveFromISR+0xa8>
        }
        else
        {
            xReturn = pdFAIL;
    1a56:	1f 82       	std	Y+7, r1	; 0x07
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1a58:	8f 81       	ldd	r24, Y+7	; 0x07
}
    1a5a:	2d 96       	adiw	r28, 0x0d	; 13
    1a5c:	0f b6       	in	r0, 0x3f	; 63
    1a5e:	f8 94       	cli
    1a60:	de bf       	out	0x3e, r29	; 62
    1a62:	0f be       	out	0x3f, r0	; 63
    1a64:	cd bf       	out	0x3d, r28	; 61
    1a66:	cf 91       	pop	r28
    1a68:	df 91       	pop	r29
    1a6a:	08 95       	ret

00001a6c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    1a6c:	df 93       	push	r29
    1a6e:	cf 93       	push	r28
    1a70:	cd b7       	in	r28, 0x3d	; 61
    1a72:	de b7       	in	r29, 0x3e	; 62
    1a74:	2a 97       	sbiw	r28, 0x0a	; 10
    1a76:	0f b6       	in	r0, 0x3f	; 63
    1a78:	f8 94       	cli
    1a7a:	de bf       	out	0x3e, r29	; 62
    1a7c:	0f be       	out	0x3f, r0	; 63
    1a7e:	cd bf       	out	0x3d, r28	; 61
    1a80:	98 87       	std	Y+8, r25	; 0x08
    1a82:	8f 83       	std	Y+7, r24	; 0x07
    1a84:	7a 87       	std	Y+10, r23	; 0x0a
    1a86:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    1a88:	8f 81       	ldd	r24, Y+7	; 0x07
    1a8a:	98 85       	ldd	r25, Y+8	; 0x08
    1a8c:	9a 83       	std	Y+2, r25	; 0x02
    1a8e:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1a90:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a92:	e9 81       	ldd	r30, Y+1	; 0x01
    1a94:	fa 81       	ldd	r31, Y+2	; 0x02
    1a96:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a98:	88 23       	and	r24, r24
    1a9a:	b1 f0       	breq	.+44     	; 0x1ac8 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1a9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1aa0:	86 81       	ldd	r24, Z+6	; 0x06
    1aa2:	97 81       	ldd	r25, Z+7	; 0x07
    1aa4:	9c 83       	std	Y+4, r25	; 0x04
    1aa6:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    1aa8:	89 81       	ldd	r24, Y+1	; 0x01
    1aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    1aac:	29 85       	ldd	r18, Y+9	; 0x09
    1aae:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ab0:	b9 01       	movw	r22, r18
    1ab2:	0e 94 83 0e 	call	0x1d06	; 0x1d06 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1ab6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ab8:	fa 81       	ldd	r31, Y+2	; 0x02
    1aba:	8b 81       	ldd	r24, Y+3	; 0x03
    1abc:	9c 81       	ldd	r25, Y+4	; 0x04
    1abe:	97 83       	std	Z+7, r25	; 0x07
    1ac0:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    1ac2:	81 e0       	ldi	r24, 0x01	; 1
    1ac4:	8e 83       	std	Y+6, r24	; 0x06
    1ac6:	01 c0       	rjmp	.+2      	; 0x1aca <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    1ac8:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1aca:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1acc:	2a 96       	adiw	r28, 0x0a	; 10
    1ace:	0f b6       	in	r0, 0x3f	; 63
    1ad0:	f8 94       	cli
    1ad2:	de bf       	out	0x3e, r29	; 62
    1ad4:	0f be       	out	0x3f, r0	; 63
    1ad6:	cd bf       	out	0x3d, r28	; 61
    1ad8:	cf 91       	pop	r28
    1ada:	df 91       	pop	r29
    1adc:	08 95       	ret

00001ade <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1ade:	df 93       	push	r29
    1ae0:	cf 93       	push	r28
    1ae2:	00 d0       	rcall	.+0      	; 0x1ae4 <uxQueueMessagesWaiting+0x6>
    1ae4:	0f 92       	push	r0
    1ae6:	cd b7       	in	r28, 0x3d	; 61
    1ae8:	de b7       	in	r29, 0x3e	; 62
    1aea:	9b 83       	std	Y+3, r25	; 0x03
    1aec:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    1aee:	0f b6       	in	r0, 0x3f	; 63
    1af0:	f8 94       	cli
    1af2:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1af4:	ea 81       	ldd	r30, Y+2	; 0x02
    1af6:	fb 81       	ldd	r31, Y+3	; 0x03
    1af8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1afa:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    1afc:	0f 90       	pop	r0
    1afe:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1b00:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b02:	0f 90       	pop	r0
    1b04:	0f 90       	pop	r0
    1b06:	0f 90       	pop	r0
    1b08:	cf 91       	pop	r28
    1b0a:	df 91       	pop	r29
    1b0c:	08 95       	ret

00001b0e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1b0e:	df 93       	push	r29
    1b10:	cf 93       	push	r28
    1b12:	00 d0       	rcall	.+0      	; 0x1b14 <uxQueueSpacesAvailable+0x6>
    1b14:	00 d0       	rcall	.+0      	; 0x1b16 <uxQueueSpacesAvailable+0x8>
    1b16:	0f 92       	push	r0
    1b18:	cd b7       	in	r28, 0x3d	; 61
    1b1a:	de b7       	in	r29, 0x3e	; 62
    1b1c:	9d 83       	std	Y+5, r25	; 0x05
    1b1e:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    1b20:	8c 81       	ldd	r24, Y+4	; 0x04
    1b22:	9d 81       	ldd	r25, Y+5	; 0x05
    1b24:	9a 83       	std	Y+2, r25	; 0x02
    1b26:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    1b28:	0f b6       	in	r0, 0x3f	; 63
    1b2a:	f8 94       	cli
    1b2c:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1b2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b30:	fa 81       	ldd	r31, Y+2	; 0x02
    1b32:	93 8d       	ldd	r25, Z+27	; 0x1b
    1b34:	e9 81       	ldd	r30, Y+1	; 0x01
    1b36:	fa 81       	ldd	r31, Y+2	; 0x02
    1b38:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b3a:	29 2f       	mov	r18, r25
    1b3c:	28 1b       	sub	r18, r24
    1b3e:	82 2f       	mov	r24, r18
    1b40:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    1b42:	0f 90       	pop	r0
    1b44:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1b46:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b48:	0f 90       	pop	r0
    1b4a:	0f 90       	pop	r0
    1b4c:	0f 90       	pop	r0
    1b4e:	0f 90       	pop	r0
    1b50:	0f 90       	pop	r0
    1b52:	cf 91       	pop	r28
    1b54:	df 91       	pop	r29
    1b56:	08 95       	ret

00001b58 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1b58:	df 93       	push	r29
    1b5a:	cf 93       	push	r28
    1b5c:	00 d0       	rcall	.+0      	; 0x1b5e <uxQueueMessagesWaitingFromISR+0x6>
    1b5e:	00 d0       	rcall	.+0      	; 0x1b60 <uxQueueMessagesWaitingFromISR+0x8>
    1b60:	0f 92       	push	r0
    1b62:	cd b7       	in	r28, 0x3d	; 61
    1b64:	de b7       	in	r29, 0x3e	; 62
    1b66:	9d 83       	std	Y+5, r25	; 0x05
    1b68:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    1b6a:	8c 81       	ldd	r24, Y+4	; 0x04
    1b6c:	9d 81       	ldd	r25, Y+5	; 0x05
    1b6e:	9a 83       	std	Y+2, r25	; 0x02
    1b70:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    1b72:	e9 81       	ldd	r30, Y+1	; 0x01
    1b74:	fa 81       	ldd	r31, Y+2	; 0x02
    1b76:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b78:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    1b7a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b7c:	0f 90       	pop	r0
    1b7e:	0f 90       	pop	r0
    1b80:	0f 90       	pop	r0
    1b82:	0f 90       	pop	r0
    1b84:	0f 90       	pop	r0
    1b86:	cf 91       	pop	r28
    1b88:	df 91       	pop	r29
    1b8a:	08 95       	ret

00001b8c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1b8c:	df 93       	push	r29
    1b8e:	cf 93       	push	r28
    1b90:	00 d0       	rcall	.+0      	; 0x1b92 <vQueueDelete+0x6>
    1b92:	00 d0       	rcall	.+0      	; 0x1b94 <vQueueDelete+0x8>
    1b94:	cd b7       	in	r28, 0x3d	; 61
    1b96:	de b7       	in	r29, 0x3e	; 62
    1b98:	9c 83       	std	Y+4, r25	; 0x04
    1b9a:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1ba0:	9a 83       	std	Y+2, r25	; 0x02
    1ba2:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
    1ba4:	89 81       	ldd	r24, Y+1	; 0x01
    1ba6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba8:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1bac:	0f 90       	pop	r0
    1bae:	0f 90       	pop	r0
    1bb0:	0f 90       	pop	r0
    1bb2:	0f 90       	pop	r0
    1bb4:	cf 91       	pop	r28
    1bb6:	df 91       	pop	r29
    1bb8:	08 95       	ret

00001bba <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    1bba:	df 93       	push	r29
    1bbc:	cf 93       	push	r28
    1bbe:	cd b7       	in	r28, 0x3d	; 61
    1bc0:	de b7       	in	r29, 0x3e	; 62
    1bc2:	27 97       	sbiw	r28, 0x07	; 7
    1bc4:	0f b6       	in	r0, 0x3f	; 63
    1bc6:	f8 94       	cli
    1bc8:	de bf       	out	0x3e, r29	; 62
    1bca:	0f be       	out	0x3f, r0	; 63
    1bcc:	cd bf       	out	0x3d, r28	; 61
    1bce:	9c 83       	std	Y+4, r25	; 0x04
    1bd0:	8b 83       	std	Y+3, r24	; 0x03
    1bd2:	7e 83       	std	Y+6, r23	; 0x06
    1bd4:	6d 83       	std	Y+5, r22	; 0x05
    1bd6:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    1bd8:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1bda:	eb 81       	ldd	r30, Y+3	; 0x03
    1bdc:	fc 81       	ldd	r31, Y+4	; 0x04
    1bde:	82 8d       	ldd	r24, Z+26	; 0x1a
    1be0:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1be2:	eb 81       	ldd	r30, Y+3	; 0x03
    1be4:	fc 81       	ldd	r31, Y+4	; 0x04
    1be6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1be8:	88 23       	and	r24, r24
    1bea:	09 f4       	brne	.+2      	; 0x1bee <prvCopyDataToQueue+0x34>
    1bec:	7d c0       	rjmp	.+250    	; 0x1ce8 <prvCopyDataToQueue+0x12e>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    1bee:	8f 81       	ldd	r24, Y+7	; 0x07
    1bf0:	88 23       	and	r24, r24
    1bf2:	99 f5       	brne	.+102    	; 0x1c5a <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf8:	62 81       	ldd	r22, Z+2	; 0x02
    1bfa:	73 81       	ldd	r23, Z+3	; 0x03
    1bfc:	eb 81       	ldd	r30, Y+3	; 0x03
    1bfe:	fc 81       	ldd	r31, Y+4	; 0x04
    1c00:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c02:	48 2f       	mov	r20, r24
    1c04:	50 e0       	ldi	r21, 0x00	; 0
    1c06:	2d 81       	ldd	r18, Y+5	; 0x05
    1c08:	3e 81       	ldd	r19, Y+6	; 0x06
    1c0a:	cb 01       	movw	r24, r22
    1c0c:	b9 01       	movw	r22, r18
    1c0e:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1c12:	eb 81       	ldd	r30, Y+3	; 0x03
    1c14:	fc 81       	ldd	r31, Y+4	; 0x04
    1c16:	22 81       	ldd	r18, Z+2	; 0x02
    1c18:	33 81       	ldd	r19, Z+3	; 0x03
    1c1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c1e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c20:	88 2f       	mov	r24, r24
    1c22:	90 e0       	ldi	r25, 0x00	; 0
    1c24:	82 0f       	add	r24, r18
    1c26:	93 1f       	adc	r25, r19
    1c28:	eb 81       	ldd	r30, Y+3	; 0x03
    1c2a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c2c:	93 83       	std	Z+3, r25	; 0x03
    1c2e:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1c30:	eb 81       	ldd	r30, Y+3	; 0x03
    1c32:	fc 81       	ldd	r31, Y+4	; 0x04
    1c34:	22 81       	ldd	r18, Z+2	; 0x02
    1c36:	33 81       	ldd	r19, Z+3	; 0x03
    1c38:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c3c:	84 81       	ldd	r24, Z+4	; 0x04
    1c3e:	95 81       	ldd	r25, Z+5	; 0x05
    1c40:	28 17       	cp	r18, r24
    1c42:	39 07       	cpc	r19, r25
    1c44:	08 f4       	brcc	.+2      	; 0x1c48 <prvCopyDataToQueue+0x8e>
    1c46:	50 c0       	rjmp	.+160    	; 0x1ce8 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1c48:	eb 81       	ldd	r30, Y+3	; 0x03
    1c4a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c4c:	80 81       	ld	r24, Z
    1c4e:	91 81       	ldd	r25, Z+1	; 0x01
    1c50:	eb 81       	ldd	r30, Y+3	; 0x03
    1c52:	fc 81       	ldd	r31, Y+4	; 0x04
    1c54:	93 83       	std	Z+3, r25	; 0x03
    1c56:	82 83       	std	Z+2, r24	; 0x02
    1c58:	47 c0       	rjmp	.+142    	; 0x1ce8 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1c5a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c5c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c5e:	66 81       	ldd	r22, Z+6	; 0x06
    1c60:	77 81       	ldd	r23, Z+7	; 0x07
    1c62:	eb 81       	ldd	r30, Y+3	; 0x03
    1c64:	fc 81       	ldd	r31, Y+4	; 0x04
    1c66:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c68:	48 2f       	mov	r20, r24
    1c6a:	50 e0       	ldi	r21, 0x00	; 0
    1c6c:	2d 81       	ldd	r18, Y+5	; 0x05
    1c6e:	3e 81       	ldd	r19, Y+6	; 0x06
    1c70:	cb 01       	movw	r24, r22
    1c72:	b9 01       	movw	r22, r18
    1c74:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1c78:	eb 81       	ldd	r30, Y+3	; 0x03
    1c7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c7c:	26 81       	ldd	r18, Z+6	; 0x06
    1c7e:	37 81       	ldd	r19, Z+7	; 0x07
    1c80:	eb 81       	ldd	r30, Y+3	; 0x03
    1c82:	fc 81       	ldd	r31, Y+4	; 0x04
    1c84:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c86:	88 2f       	mov	r24, r24
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	90 95       	com	r25
    1c8c:	81 95       	neg	r24
    1c8e:	9f 4f       	sbci	r25, 0xFF	; 255
    1c90:	82 0f       	add	r24, r18
    1c92:	93 1f       	adc	r25, r19
    1c94:	eb 81       	ldd	r30, Y+3	; 0x03
    1c96:	fc 81       	ldd	r31, Y+4	; 0x04
    1c98:	97 83       	std	Z+7, r25	; 0x07
    1c9a:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1c9c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c9e:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca0:	26 81       	ldd	r18, Z+6	; 0x06
    1ca2:	37 81       	ldd	r19, Z+7	; 0x07
    1ca4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ca6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca8:	80 81       	ld	r24, Z
    1caa:	91 81       	ldd	r25, Z+1	; 0x01
    1cac:	28 17       	cp	r18, r24
    1cae:	39 07       	cpc	r19, r25
    1cb0:	90 f4       	brcc	.+36     	; 0x1cd6 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1cb2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb6:	24 81       	ldd	r18, Z+4	; 0x04
    1cb8:	35 81       	ldd	r19, Z+5	; 0x05
    1cba:	eb 81       	ldd	r30, Y+3	; 0x03
    1cbc:	fc 81       	ldd	r31, Y+4	; 0x04
    1cbe:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cc0:	88 2f       	mov	r24, r24
    1cc2:	90 e0       	ldi	r25, 0x00	; 0
    1cc4:	90 95       	com	r25
    1cc6:	81 95       	neg	r24
    1cc8:	9f 4f       	sbci	r25, 0xFF	; 255
    1cca:	82 0f       	add	r24, r18
    1ccc:	93 1f       	adc	r25, r19
    1cce:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd2:	97 83       	std	Z+7, r25	; 0x07
    1cd4:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    1cd6:	8f 81       	ldd	r24, Y+7	; 0x07
    1cd8:	82 30       	cpi	r24, 0x02	; 2
    1cda:	31 f4       	brne	.+12     	; 0x1ce8 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1cdc:	89 81       	ldd	r24, Y+1	; 0x01
    1cde:	88 23       	and	r24, r24
    1ce0:	19 f0       	breq	.+6      	; 0x1ce8 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    1ce2:	89 81       	ldd	r24, Y+1	; 0x01
    1ce4:	81 50       	subi	r24, 0x01	; 1
    1ce6:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1ce8:	89 81       	ldd	r24, Y+1	; 0x01
    1cea:	8f 5f       	subi	r24, 0xFF	; 255
    1cec:	eb 81       	ldd	r30, Y+3	; 0x03
    1cee:	fc 81       	ldd	r31, Y+4	; 0x04
    1cf0:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    1cf2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1cf4:	27 96       	adiw	r28, 0x07	; 7
    1cf6:	0f b6       	in	r0, 0x3f	; 63
    1cf8:	f8 94       	cli
    1cfa:	de bf       	out	0x3e, r29	; 62
    1cfc:	0f be       	out	0x3f, r0	; 63
    1cfe:	cd bf       	out	0x3d, r28	; 61
    1d00:	cf 91       	pop	r28
    1d02:	df 91       	pop	r29
    1d04:	08 95       	ret

00001d06 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    1d06:	df 93       	push	r29
    1d08:	cf 93       	push	r28
    1d0a:	00 d0       	rcall	.+0      	; 0x1d0c <prvCopyDataFromQueue+0x6>
    1d0c:	00 d0       	rcall	.+0      	; 0x1d0e <prvCopyDataFromQueue+0x8>
    1d0e:	cd b7       	in	r28, 0x3d	; 61
    1d10:	de b7       	in	r29, 0x3e	; 62
    1d12:	9a 83       	std	Y+2, r25	; 0x02
    1d14:	89 83       	std	Y+1, r24	; 0x01
    1d16:	7c 83       	std	Y+4, r23	; 0x04
    1d18:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1d1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d1e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d20:	88 23       	and	r24, r24
    1d22:	89 f1       	breq	.+98     	; 0x1d86 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1d24:	e9 81       	ldd	r30, Y+1	; 0x01
    1d26:	fa 81       	ldd	r31, Y+2	; 0x02
    1d28:	26 81       	ldd	r18, Z+6	; 0x06
    1d2a:	37 81       	ldd	r19, Z+7	; 0x07
    1d2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d30:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d32:	88 2f       	mov	r24, r24
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	82 0f       	add	r24, r18
    1d38:	93 1f       	adc	r25, r19
    1d3a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d3c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d3e:	97 83       	std	Z+7, r25	; 0x07
    1d40:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1d42:	e9 81       	ldd	r30, Y+1	; 0x01
    1d44:	fa 81       	ldd	r31, Y+2	; 0x02
    1d46:	26 81       	ldd	r18, Z+6	; 0x06
    1d48:	37 81       	ldd	r19, Z+7	; 0x07
    1d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4e:	84 81       	ldd	r24, Z+4	; 0x04
    1d50:	95 81       	ldd	r25, Z+5	; 0x05
    1d52:	28 17       	cp	r18, r24
    1d54:	39 07       	cpc	r19, r25
    1d56:	40 f0       	brcs	.+16     	; 0x1d68 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1d58:	e9 81       	ldd	r30, Y+1	; 0x01
    1d5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d5c:	80 81       	ld	r24, Z
    1d5e:	91 81       	ldd	r25, Z+1	; 0x01
    1d60:	e9 81       	ldd	r30, Y+1	; 0x01
    1d62:	fa 81       	ldd	r31, Y+2	; 0x02
    1d64:	97 83       	std	Z+7, r25	; 0x07
    1d66:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1d68:	e9 81       	ldd	r30, Y+1	; 0x01
    1d6a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d6c:	46 81       	ldd	r20, Z+6	; 0x06
    1d6e:	57 81       	ldd	r21, Z+7	; 0x07
    1d70:	e9 81       	ldd	r30, Y+1	; 0x01
    1d72:	fa 81       	ldd	r31, Y+2	; 0x02
    1d74:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d76:	28 2f       	mov	r18, r24
    1d78:	30 e0       	ldi	r19, 0x00	; 0
    1d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d7e:	ba 01       	movw	r22, r20
    1d80:	a9 01       	movw	r20, r18
    1d82:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <memcpy>
    }
}
    1d86:	0f 90       	pop	r0
    1d88:	0f 90       	pop	r0
    1d8a:	0f 90       	pop	r0
    1d8c:	0f 90       	pop	r0
    1d8e:	cf 91       	pop	r28
    1d90:	df 91       	pop	r29
    1d92:	08 95       	ret

00001d94 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1d94:	df 93       	push	r29
    1d96:	cf 93       	push	r28
    1d98:	00 d0       	rcall	.+0      	; 0x1d9a <prvUnlockQueue+0x6>
    1d9a:	00 d0       	rcall	.+0      	; 0x1d9c <prvUnlockQueue+0x8>
    1d9c:	cd b7       	in	r28, 0x3d	; 61
    1d9e:	de b7       	in	r29, 0x3e	; 62
    1da0:	9c 83       	std	Y+4, r25	; 0x04
    1da2:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    1da4:	0f b6       	in	r0, 0x3f	; 63
    1da6:	f8 94       	cli
    1da8:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    1daa:	eb 81       	ldd	r30, Y+3	; 0x03
    1dac:	fc 81       	ldd	r31, Y+4	; 0x04
    1dae:	86 8d       	ldd	r24, Z+30	; 0x1e
    1db0:	8a 83       	std	Y+2, r24	; 0x02
    1db2:	11 c0       	rjmp	.+34     	; 0x1dd6 <prvUnlockQueue+0x42>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1db4:	eb 81       	ldd	r30, Y+3	; 0x03
    1db6:	fc 81       	ldd	r31, Y+4	; 0x04
    1db8:	81 89       	ldd	r24, Z+17	; 0x11
    1dba:	88 23       	and	r24, r24
    1dbc:	79 f0       	breq	.+30     	; 0x1ddc <prvUnlockQueue+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1dbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc2:	41 96       	adiw	r24, 0x11	; 17
    1dc4:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <xTaskRemoveFromEventList>
    1dc8:	88 23       	and	r24, r24
    1dca:	11 f0       	breq	.+4      	; 0x1dd0 <prvUnlockQueue+0x3c>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
    1dcc:	0e 94 31 22 	call	0x4462	; 0x4462 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    1dd0:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd2:	81 50       	subi	r24, 0x01	; 1
    1dd4:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    1dd6:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd8:	18 16       	cp	r1, r24
    1dda:	64 f3       	brlt	.-40     	; 0x1db4 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    1ddc:	eb 81       	ldd	r30, Y+3	; 0x03
    1dde:	fc 81       	ldd	r31, Y+4	; 0x04
    1de0:	8f ef       	ldi	r24, 0xFF	; 255
    1de2:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    1de4:	0f 90       	pop	r0
    1de6:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    1de8:	0f b6       	in	r0, 0x3f	; 63
    1dea:	f8 94       	cli
    1dec:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    1dee:	eb 81       	ldd	r30, Y+3	; 0x03
    1df0:	fc 81       	ldd	r31, Y+4	; 0x04
    1df2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1df4:	89 83       	std	Y+1, r24	; 0x01
    1df6:	11 c0       	rjmp	.+34     	; 0x1e1a <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1df8:	eb 81       	ldd	r30, Y+3	; 0x03
    1dfa:	fc 81       	ldd	r31, Y+4	; 0x04
    1dfc:	80 85       	ldd	r24, Z+8	; 0x08
    1dfe:	88 23       	and	r24, r24
    1e00:	79 f0       	breq	.+30     	; 0x1e20 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e02:	8b 81       	ldd	r24, Y+3	; 0x03
    1e04:	9c 81       	ldd	r25, Y+4	; 0x04
    1e06:	08 96       	adiw	r24, 0x08	; 8
    1e08:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <xTaskRemoveFromEventList>
    1e0c:	88 23       	and	r24, r24
    1e0e:	11 f0       	breq	.+4      	; 0x1e14 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    1e10:	0e 94 31 22 	call	0x4462	; 0x4462 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    1e14:	89 81       	ldd	r24, Y+1	; 0x01
    1e16:	81 50       	subi	r24, 0x01	; 1
    1e18:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    1e1a:	89 81       	ldd	r24, Y+1	; 0x01
    1e1c:	18 16       	cp	r1, r24
    1e1e:	64 f3       	brlt	.-40     	; 0x1df8 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    1e20:	eb 81       	ldd	r30, Y+3	; 0x03
    1e22:	fc 81       	ldd	r31, Y+4	; 0x04
    1e24:	8f ef       	ldi	r24, 0xFF	; 255
    1e26:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    1e28:	0f 90       	pop	r0
    1e2a:	0f be       	out	0x3f, r0	; 63
}
    1e2c:	0f 90       	pop	r0
    1e2e:	0f 90       	pop	r0
    1e30:	0f 90       	pop	r0
    1e32:	0f 90       	pop	r0
    1e34:	cf 91       	pop	r28
    1e36:	df 91       	pop	r29
    1e38:	08 95       	ret

00001e3a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    1e3a:	df 93       	push	r29
    1e3c:	cf 93       	push	r28
    1e3e:	00 d0       	rcall	.+0      	; 0x1e40 <prvIsQueueEmpty+0x6>
    1e40:	0f 92       	push	r0
    1e42:	cd b7       	in	r28, 0x3d	; 61
    1e44:	de b7       	in	r29, 0x3e	; 62
    1e46:	9b 83       	std	Y+3, r25	; 0x03
    1e48:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1e4a:	0f b6       	in	r0, 0x3f	; 63
    1e4c:	f8 94       	cli
    1e4e:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1e50:	ea 81       	ldd	r30, Y+2	; 0x02
    1e52:	fb 81       	ldd	r31, Y+3	; 0x03
    1e54:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e56:	88 23       	and	r24, r24
    1e58:	19 f4       	brne	.+6      	; 0x1e60 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    1e5a:	81 e0       	ldi	r24, 0x01	; 1
    1e5c:	89 83       	std	Y+1, r24	; 0x01
    1e5e:	01 c0       	rjmp	.+2      	; 0x1e62 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    1e60:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    1e62:	0f 90       	pop	r0
    1e64:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    1e66:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e68:	0f 90       	pop	r0
    1e6a:	0f 90       	pop	r0
    1e6c:	0f 90       	pop	r0
    1e6e:	cf 91       	pop	r28
    1e70:	df 91       	pop	r29
    1e72:	08 95       	ret

00001e74 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1e74:	df 93       	push	r29
    1e76:	cf 93       	push	r28
    1e78:	00 d0       	rcall	.+0      	; 0x1e7a <xQueueIsQueueEmptyFromISR+0x6>
    1e7a:	00 d0       	rcall	.+0      	; 0x1e7c <xQueueIsQueueEmptyFromISR+0x8>
    1e7c:	0f 92       	push	r0
    1e7e:	cd b7       	in	r28, 0x3d	; 61
    1e80:	de b7       	in	r29, 0x3e	; 62
    1e82:	9d 83       	std	Y+5, r25	; 0x05
    1e84:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    1e86:	8c 81       	ldd	r24, Y+4	; 0x04
    1e88:	9d 81       	ldd	r25, Y+5	; 0x05
    1e8a:	9a 83       	std	Y+2, r25	; 0x02
    1e8c:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1e8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e90:	fa 81       	ldd	r31, Y+2	; 0x02
    1e92:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e94:	88 23       	and	r24, r24
    1e96:	19 f4       	brne	.+6      	; 0x1e9e <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    1e98:	81 e0       	ldi	r24, 0x01	; 1
    1e9a:	8b 83       	std	Y+3, r24	; 0x03
    1e9c:	01 c0       	rjmp	.+2      	; 0x1ea0 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    1e9e:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    1ea0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1ea2:	0f 90       	pop	r0
    1ea4:	0f 90       	pop	r0
    1ea6:	0f 90       	pop	r0
    1ea8:	0f 90       	pop	r0
    1eaa:	0f 90       	pop	r0
    1eac:	cf 91       	pop	r28
    1eae:	df 91       	pop	r29
    1eb0:	08 95       	ret

00001eb2 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    1eb2:	df 93       	push	r29
    1eb4:	cf 93       	push	r28
    1eb6:	00 d0       	rcall	.+0      	; 0x1eb8 <prvIsQueueFull+0x6>
    1eb8:	0f 92       	push	r0
    1eba:	cd b7       	in	r28, 0x3d	; 61
    1ebc:	de b7       	in	r29, 0x3e	; 62
    1ebe:	9b 83       	std	Y+3, r25	; 0x03
    1ec0:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1ec2:	0f b6       	in	r0, 0x3f	; 63
    1ec4:	f8 94       	cli
    1ec6:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1ec8:	ea 81       	ldd	r30, Y+2	; 0x02
    1eca:	fb 81       	ldd	r31, Y+3	; 0x03
    1ecc:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ece:	ea 81       	ldd	r30, Y+2	; 0x02
    1ed0:	fb 81       	ldd	r31, Y+3	; 0x03
    1ed2:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ed4:	98 17       	cp	r25, r24
    1ed6:	19 f4       	brne	.+6      	; 0x1ede <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    1ed8:	81 e0       	ldi	r24, 0x01	; 1
    1eda:	89 83       	std	Y+1, r24	; 0x01
    1edc:	01 c0       	rjmp	.+2      	; 0x1ee0 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    1ede:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    1ee4:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ee6:	0f 90       	pop	r0
    1ee8:	0f 90       	pop	r0
    1eea:	0f 90       	pop	r0
    1eec:	cf 91       	pop	r28
    1eee:	df 91       	pop	r29
    1ef0:	08 95       	ret

00001ef2 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1ef2:	df 93       	push	r29
    1ef4:	cf 93       	push	r28
    1ef6:	00 d0       	rcall	.+0      	; 0x1ef8 <xQueueIsQueueFullFromISR+0x6>
    1ef8:	00 d0       	rcall	.+0      	; 0x1efa <xQueueIsQueueFullFromISR+0x8>
    1efa:	0f 92       	push	r0
    1efc:	cd b7       	in	r28, 0x3d	; 61
    1efe:	de b7       	in	r29, 0x3e	; 62
    1f00:	9d 83       	std	Y+5, r25	; 0x05
    1f02:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    1f04:	8c 81       	ldd	r24, Y+4	; 0x04
    1f06:	9d 81       	ldd	r25, Y+5	; 0x05
    1f08:	9a 83       	std	Y+2, r25	; 0x02
    1f0a:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1f0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f10:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f12:	e9 81       	ldd	r30, Y+1	; 0x01
    1f14:	fa 81       	ldd	r31, Y+2	; 0x02
    1f16:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f18:	98 17       	cp	r25, r24
    1f1a:	19 f4       	brne	.+6      	; 0x1f22 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    1f1c:	81 e0       	ldi	r24, 0x01	; 1
    1f1e:	8b 83       	std	Y+3, r24	; 0x03
    1f20:	01 c0       	rjmp	.+2      	; 0x1f24 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    1f22:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    1f24:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1f26:	0f 90       	pop	r0
    1f28:	0f 90       	pop	r0
    1f2a:	0f 90       	pop	r0
    1f2c:	0f 90       	pop	r0
    1f2e:	0f 90       	pop	r0
    1f30:	cf 91       	pop	r28
    1f32:	df 91       	pop	r29
    1f34:	08 95       	ret

00001f36 <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
    1f36:	cf 92       	push	r12
    1f38:	df 92       	push	r13
    1f3a:	ef 92       	push	r14
    1f3c:	ff 92       	push	r15
    1f3e:	0f 93       	push	r16
    1f40:	1f 93       	push	r17
    1f42:	df 93       	push	r29
    1f44:	cf 93       	push	r28
    1f46:	cd b7       	in	r28, 0x3d	; 61
    1f48:	de b7       	in	r29, 0x3e	; 62
    1f4a:	2c 97       	sbiw	r28, 0x0c	; 12
    1f4c:	0f b6       	in	r0, 0x3f	; 63
    1f4e:	f8 94       	cli
    1f50:	de bf       	out	0x3e, r29	; 62
    1f52:	0f be       	out	0x3f, r0	; 63
    1f54:	cd bf       	out	0x3d, r28	; 61
    1f56:	9d 83       	std	Y+5, r25	; 0x05
    1f58:	8c 83       	std	Y+4, r24	; 0x04
    1f5a:	7f 83       	std	Y+7, r23	; 0x07
    1f5c:	6e 83       	std	Y+6, r22	; 0x06
    1f5e:	48 87       	std	Y+8, r20	; 0x08
    1f60:	3a 87       	std	Y+10, r19	; 0x0a
    1f62:	29 87       	std	Y+9, r18	; 0x09
    1f64:	1c 87       	std	Y+12, r17	; 0x0c
    1f66:	0b 87       	std	Y+11, r16	; 0x0b

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
    1f68:	88 85       	ldd	r24, Y+8	; 0x08
    1f6a:	81 30       	cpi	r24, 0x01	; 1
    1f6c:	19 f4       	brne	.+6      	; 0x1f74 <xStreamBufferGenericCreate+0x3e>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	89 83       	std	Y+1, r24	; 0x01
    1f72:	01 c0       	rjmp	.+2      	; 0x1f76 <xStreamBufferGenericCreate+0x40>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
    1f74:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    1f76:	8e 81       	ldd	r24, Y+6	; 0x06
    1f78:	9f 81       	ldd	r25, Y+7	; 0x07
    1f7a:	00 97       	sbiw	r24, 0x00	; 0
    1f7c:	21 f4       	brne	.+8      	; 0x1f86 <xStreamBufferGenericCreate+0x50>
        {
            xTriggerLevelBytes = ( size_t ) 1;
    1f7e:	81 e0       	ldi	r24, 0x01	; 1
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	9f 83       	std	Y+7, r25	; 0x07
    1f84:	8e 83       	std	Y+6, r24	; 0x06
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    1f86:	8c 81       	ldd	r24, Y+4	; 0x04
    1f88:	9d 81       	ldd	r25, Y+5	; 0x05
    1f8a:	9c 01       	movw	r18, r24
    1f8c:	20 5f       	subi	r18, 0xF0	; 240
    1f8e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f90:	8c 81       	ldd	r24, Y+4	; 0x04
    1f92:	9d 81       	ldd	r25, Y+5	; 0x05
    1f94:	82 17       	cp	r24, r18
    1f96:	93 07       	cpc	r25, r19
    1f98:	68 f4       	brcc	.+26     	; 0x1fb4 <xStreamBufferGenericCreate+0x7e>
        {
            xBufferSizeBytes++;
    1f9a:	8c 81       	ldd	r24, Y+4	; 0x04
    1f9c:	9d 81       	ldd	r25, Y+5	; 0x05
    1f9e:	01 96       	adiw	r24, 0x01	; 1
    1fa0:	9d 83       	std	Y+5, r25	; 0x05
    1fa2:	8c 83       	std	Y+4, r24	; 0x04
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    1fa4:	8c 81       	ldd	r24, Y+4	; 0x04
    1fa6:	9d 81       	ldd	r25, Y+5	; 0x05
    1fa8:	0f 96       	adiw	r24, 0x0f	; 15
    1faa:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1fae:	9b 83       	std	Y+3, r25	; 0x03
    1fb0:	8a 83       	std	Y+2, r24	; 0x02
    1fb2:	02 c0       	rjmp	.+4      	; 0x1fb8 <xStreamBufferGenericCreate+0x82>
        }
        else
        {
            pucAllocatedMemory = NULL;
    1fb4:	1b 82       	std	Y+3, r1	; 0x03
    1fb6:	1a 82       	std	Y+2, r1	; 0x02
        }

        if( pucAllocatedMemory != NULL )
    1fb8:	8a 81       	ldd	r24, Y+2	; 0x02
    1fba:	9b 81       	ldd	r25, Y+3	; 0x03
    1fbc:	00 97       	sbiw	r24, 0x00	; 0
    1fbe:	b1 f0       	breq	.+44     	; 0x1fec <xStreamBufferGenericCreate+0xb6>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    1fc0:	6a 81       	ldd	r22, Y+2	; 0x02
    1fc2:	7b 81       	ldd	r23, Y+3	; 0x03
    1fc4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc6:	9b 81       	ldd	r25, Y+3	; 0x03
    1fc8:	9c 01       	movw	r18, r24
    1fca:	21 5f       	subi	r18, 0xF1	; 241
    1fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    1fce:	4c 81       	ldd	r20, Y+4	; 0x04
    1fd0:	5d 81       	ldd	r21, Y+5	; 0x05
    1fd2:	ee 81       	ldd	r30, Y+6	; 0x06
    1fd4:	ff 81       	ldd	r31, Y+7	; 0x07
    1fd6:	a9 85       	ldd	r26, Y+9	; 0x09
    1fd8:	ba 85       	ldd	r27, Y+10	; 0x0a
    1fda:	cb 84       	ldd	r12, Y+11	; 0x0b
    1fdc:	dc 84       	ldd	r13, Y+12	; 0x0c
    1fde:	cb 01       	movw	r24, r22
    1fe0:	b9 01       	movw	r22, r18
    1fe2:	9f 01       	movw	r18, r30
    1fe4:	09 81       	ldd	r16, Y+1	; 0x01
    1fe6:	7d 01       	movw	r14, r26
    1fe8:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    1fec:	8a 81       	ldd	r24, Y+2	; 0x02
    1fee:	9b 81       	ldd	r25, Y+3	; 0x03
    }
    1ff0:	2c 96       	adiw	r28, 0x0c	; 12
    1ff2:	0f b6       	in	r0, 0x3f	; 63
    1ff4:	f8 94       	cli
    1ff6:	de bf       	out	0x3e, r29	; 62
    1ff8:	0f be       	out	0x3f, r0	; 63
    1ffa:	cd bf       	out	0x3d, r28	; 61
    1ffc:	cf 91       	pop	r28
    1ffe:	df 91       	pop	r29
    2000:	1f 91       	pop	r17
    2002:	0f 91       	pop	r16
    2004:	ff 90       	pop	r15
    2006:	ef 90       	pop	r14
    2008:	df 90       	pop	r13
    200a:	cf 90       	pop	r12
    200c:	08 95       	ret

0000200e <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    200e:	df 93       	push	r29
    2010:	cf 93       	push	r28
    2012:	00 d0       	rcall	.+0      	; 0x2014 <vStreamBufferDelete+0x6>
    2014:	00 d0       	rcall	.+0      	; 0x2016 <vStreamBufferDelete+0x8>
    2016:	cd b7       	in	r28, 0x3d	; 61
    2018:	de b7       	in	r29, 0x3e	; 62
    201a:	9c 83       	std	Y+4, r25	; 0x04
    201c:	8b 83       	std	Y+3, r24	; 0x03
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    201e:	8b 81       	ldd	r24, Y+3	; 0x03
    2020:	9c 81       	ldd	r25, Y+4	; 0x04
    2022:	9a 83       	std	Y+2, r25	; 0x02
    2024:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2026:	e9 81       	ldd	r30, Y+1	; 0x01
    2028:	fa 81       	ldd	r31, Y+2	; 0x02
    202a:	86 85       	ldd	r24, Z+14	; 0x0e
    202c:	88 2f       	mov	r24, r24
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	82 70       	andi	r24, 0x02	; 2
    2032:	90 70       	andi	r25, 0x00	; 0
    2034:	00 97       	sbiw	r24, 0x00	; 0
    2036:	29 f4       	brne	.+10     	; 0x2042 <vStreamBufferDelete+0x34>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2038:	89 81       	ldd	r24, Y+1	; 0x01
    203a:	9a 81       	ldd	r25, Y+2	; 0x02
    203c:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    2040:	08 c0       	rjmp	.+16     	; 0x2052 <vStreamBufferDelete+0x44>
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2042:	89 81       	ldd	r24, Y+1	; 0x01
    2044:	9a 81       	ldd	r25, Y+2	; 0x02
    2046:	60 e0       	ldi	r22, 0x00	; 0
    2048:	70 e0       	ldi	r23, 0x00	; 0
    204a:	4f e0       	ldi	r20, 0x0F	; 15
    204c:	50 e0       	ldi	r21, 0x00	; 0
    204e:	0e 94 75 2b 	call	0x56ea	; 0x56ea <memset>
    }
}
    2052:	0f 90       	pop	r0
    2054:	0f 90       	pop	r0
    2056:	0f 90       	pop	r0
    2058:	0f 90       	pop	r0
    205a:	cf 91       	pop	r28
    205c:	df 91       	pop	r29
    205e:	08 95       	ret

00002060 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2060:	cf 92       	push	r12
    2062:	df 92       	push	r13
    2064:	ef 92       	push	r14
    2066:	ff 92       	push	r15
    2068:	0f 93       	push	r16
    206a:	1f 93       	push	r17
    206c:	df 93       	push	r29
    206e:	cf 93       	push	r28
    2070:	cd b7       	in	r28, 0x3d	; 61
    2072:	de b7       	in	r29, 0x3e	; 62
    2074:	29 97       	sbiw	r28, 0x09	; 9
    2076:	0f b6       	in	r0, 0x3f	; 63
    2078:	f8 94       	cli
    207a:	de bf       	out	0x3e, r29	; 62
    207c:	0f be       	out	0x3f, r0	; 63
    207e:	cd bf       	out	0x3d, r28	; 61
    2080:	99 87       	std	Y+9, r25	; 0x09
    2082:	88 87       	std	Y+8, r24	; 0x08
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2084:	88 85       	ldd	r24, Y+8	; 0x08
    2086:	99 85       	ldd	r25, Y+9	; 0x09
    2088:	9f 83       	std	Y+7, r25	; 0x07
    208a:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn = pdFAIL;
    208c:	1d 82       	std	Y+5, r1	; 0x05
    StreamBufferCallbackFunction_t pxSendCallback = NULL, pxReceiveCallback = NULL;
    208e:	1c 82       	std	Y+4, r1	; 0x04
    2090:	1b 82       	std	Y+3, r1	; 0x03
    2092:	1a 82       	std	Y+2, r1	; 0x02
    2094:	19 82       	std	Y+1, r1	; 0x01
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    2096:	0f b6       	in	r0, 0x3f	; 63
    2098:	f8 94       	cli
    209a:	0f 92       	push	r0
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
    209c:	ee 81       	ldd	r30, Y+6	; 0x06
    209e:	ff 81       	ldd	r31, Y+7	; 0x07
    20a0:	80 85       	ldd	r24, Z+8	; 0x08
    20a2:	91 85       	ldd	r25, Z+9	; 0x09
    20a4:	00 97       	sbiw	r24, 0x00	; 0
    20a6:	21 f5       	brne	.+72     	; 0x20f0 <xStreamBufferReset+0x90>
    20a8:	ee 81       	ldd	r30, Y+6	; 0x06
    20aa:	ff 81       	ldd	r31, Y+7	; 0x07
    20ac:	82 85       	ldd	r24, Z+10	; 0x0a
    20ae:	93 85       	ldd	r25, Z+11	; 0x0b
    20b0:	00 97       	sbiw	r24, 0x00	; 0
    20b2:	f1 f4       	brne	.+60     	; 0x20f0 <xStreamBufferReset+0x90>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
    20b4:	ee 81       	ldd	r30, Y+6	; 0x06
    20b6:	ff 81       	ldd	r31, Y+7	; 0x07
    20b8:	44 85       	ldd	r20, Z+12	; 0x0c
    20ba:	55 85       	ldd	r21, Z+13	; 0x0d
    20bc:	ee 81       	ldd	r30, Y+6	; 0x06
    20be:	ff 81       	ldd	r31, Y+7	; 0x07
    20c0:	24 81       	ldd	r18, Z+4	; 0x04
    20c2:	35 81       	ldd	r19, Z+5	; 0x05
    20c4:	ee 81       	ldd	r30, Y+6	; 0x06
    20c6:	ff 81       	ldd	r31, Y+7	; 0x07
    20c8:	a6 81       	ldd	r26, Z+6	; 0x06
    20ca:	b7 81       	ldd	r27, Z+7	; 0x07
    20cc:	ee 81       	ldd	r30, Y+6	; 0x06
    20ce:	ff 81       	ldd	r31, Y+7	; 0x07
    20d0:	16 85       	ldd	r17, Z+14	; 0x0e
    20d2:	8e 81       	ldd	r24, Y+6	; 0x06
    20d4:	9f 81       	ldd	r25, Y+7	; 0x07
    20d6:	eb 81       	ldd	r30, Y+3	; 0x03
    20d8:	fc 81       	ldd	r31, Y+4	; 0x04
    20da:	c9 80       	ldd	r12, Y+1	; 0x01
    20dc:	da 80       	ldd	r13, Y+2	; 0x02
    20de:	ba 01       	movw	r22, r20
    20e0:	a9 01       	movw	r20, r18
    20e2:	9d 01       	movw	r18, r26
    20e4:	01 2f       	mov	r16, r17
    20e6:	7f 01       	movw	r14, r30
    20e8:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <prvInitialiseNewStreamBuffer>
            }
            #endif

            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
    20ec:	81 e0       	ldi	r24, 0x01	; 1
    20ee:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    20f0:	0f 90       	pop	r0
    20f2:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    20f4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    20f6:	29 96       	adiw	r28, 0x09	; 9
    20f8:	0f b6       	in	r0, 0x3f	; 63
    20fa:	f8 94       	cli
    20fc:	de bf       	out	0x3e, r29	; 62
    20fe:	0f be       	out	0x3f, r0	; 63
    2100:	cd bf       	out	0x3d, r28	; 61
    2102:	cf 91       	pop	r28
    2104:	df 91       	pop	r29
    2106:	1f 91       	pop	r17
    2108:	0f 91       	pop	r16
    210a:	ff 90       	pop	r15
    210c:	ef 90       	pop	r14
    210e:	df 90       	pop	r13
    2110:	cf 90       	pop	r12
    2112:	08 95       	ret

00002114 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    2114:	df 93       	push	r29
    2116:	cf 93       	push	r28
    2118:	cd b7       	in	r28, 0x3d	; 61
    211a:	de b7       	in	r29, 0x3e	; 62
    211c:	27 97       	sbiw	r28, 0x07	; 7
    211e:	0f b6       	in	r0, 0x3f	; 63
    2120:	f8 94       	cli
    2122:	de bf       	out	0x3e, r29	; 62
    2124:	0f be       	out	0x3f, r0	; 63
    2126:	cd bf       	out	0x3d, r28	; 61
    2128:	9d 83       	std	Y+5, r25	; 0x05
    212a:	8c 83       	std	Y+4, r24	; 0x04
    212c:	7f 83       	std	Y+7, r23	; 0x07
    212e:	6e 83       	std	Y+6, r22	; 0x06
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2130:	8c 81       	ldd	r24, Y+4	; 0x04
    2132:	9d 81       	ldd	r25, Y+5	; 0x05
    2134:	9b 83       	std	Y+3, r25	; 0x03
    2136:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    2138:	8e 81       	ldd	r24, Y+6	; 0x06
    213a:	9f 81       	ldd	r25, Y+7	; 0x07
    213c:	00 97       	sbiw	r24, 0x00	; 0
    213e:	21 f4       	brne	.+8      	; 0x2148 <xStreamBufferSetTriggerLevel+0x34>
    {
        xTriggerLevel = ( size_t ) 1;
    2140:	81 e0       	ldi	r24, 0x01	; 1
    2142:	90 e0       	ldi	r25, 0x00	; 0
    2144:	9f 83       	std	Y+7, r25	; 0x07
    2146:	8e 83       	std	Y+6, r24	; 0x06
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    2148:	ea 81       	ldd	r30, Y+2	; 0x02
    214a:	fb 81       	ldd	r31, Y+3	; 0x03
    214c:	24 81       	ldd	r18, Z+4	; 0x04
    214e:	35 81       	ldd	r19, Z+5	; 0x05
    2150:	8e 81       	ldd	r24, Y+6	; 0x06
    2152:	9f 81       	ldd	r25, Y+7	; 0x07
    2154:	82 17       	cp	r24, r18
    2156:	93 07       	cpc	r25, r19
    2158:	48 f4       	brcc	.+18     	; 0x216c <xStreamBufferSetTriggerLevel+0x58>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    215a:	ea 81       	ldd	r30, Y+2	; 0x02
    215c:	fb 81       	ldd	r31, Y+3	; 0x03
    215e:	8e 81       	ldd	r24, Y+6	; 0x06
    2160:	9f 81       	ldd	r25, Y+7	; 0x07
    2162:	97 83       	std	Z+7, r25	; 0x07
    2164:	86 83       	std	Z+6, r24	; 0x06
        xReturn = pdPASS;
    2166:	81 e0       	ldi	r24, 0x01	; 1
    2168:	89 83       	std	Y+1, r24	; 0x01
    216a:	01 c0       	rjmp	.+2      	; 0x216e <xStreamBufferSetTriggerLevel+0x5a>
    }
    else
    {
        xReturn = pdFALSE;
    216c:	19 82       	std	Y+1, r1	; 0x01
    }

    return xReturn;
    216e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2170:	27 96       	adiw	r28, 0x07	; 7
    2172:	0f b6       	in	r0, 0x3f	; 63
    2174:	f8 94       	cli
    2176:	de bf       	out	0x3e, r29	; 62
    2178:	0f be       	out	0x3f, r0	; 63
    217a:	cd bf       	out	0x3d, r28	; 61
    217c:	cf 91       	pop	r28
    217e:	df 91       	pop	r29
    2180:	08 95       	ret

00002182 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2182:	df 93       	push	r29
    2184:	cf 93       	push	r28
    2186:	cd b7       	in	r28, 0x3d	; 61
    2188:	de b7       	in	r29, 0x3e	; 62
    218a:	28 97       	sbiw	r28, 0x08	; 8
    218c:	0f b6       	in	r0, 0x3f	; 63
    218e:	f8 94       	cli
    2190:	de bf       	out	0x3e, r29	; 62
    2192:	0f be       	out	0x3f, r0	; 63
    2194:	cd bf       	out	0x3d, r28	; 61
    2196:	98 87       	std	Y+8, r25	; 0x08
    2198:	8f 83       	std	Y+7, r24	; 0x07
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    219a:	8f 81       	ldd	r24, Y+7	; 0x07
    219c:	98 85       	ldd	r25, Y+8	; 0x08
    219e:	9e 83       	std	Y+6, r25	; 0x06
    21a0:	8d 83       	std	Y+5, r24	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    21a2:	ed 81       	ldd	r30, Y+5	; 0x05
    21a4:	fe 81       	ldd	r31, Y+6	; 0x06
    21a6:	80 81       	ld	r24, Z
    21a8:	91 81       	ldd	r25, Z+1	; 0x01
    21aa:	9a 83       	std	Y+2, r25	; 0x02
    21ac:	89 83       	std	Y+1, r24	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    21ae:	ed 81       	ldd	r30, Y+5	; 0x05
    21b0:	fe 81       	ldd	r31, Y+6	; 0x06
    21b2:	24 81       	ldd	r18, Z+4	; 0x04
    21b4:	35 81       	ldd	r19, Z+5	; 0x05
    21b6:	ed 81       	ldd	r30, Y+5	; 0x05
    21b8:	fe 81       	ldd	r31, Y+6	; 0x06
    21ba:	80 81       	ld	r24, Z
    21bc:	91 81       	ldd	r25, Z+1	; 0x01
    21be:	82 0f       	add	r24, r18
    21c0:	93 1f       	adc	r25, r19
    21c2:	9c 83       	std	Y+4, r25	; 0x04
    21c4:	8b 83       	std	Y+3, r24	; 0x03
        xSpace -= pxStreamBuffer->xHead;
    21c6:	ed 81       	ldd	r30, Y+5	; 0x05
    21c8:	fe 81       	ldd	r31, Y+6	; 0x06
    21ca:	22 81       	ldd	r18, Z+2	; 0x02
    21cc:	33 81       	ldd	r19, Z+3	; 0x03
    21ce:	8b 81       	ldd	r24, Y+3	; 0x03
    21d0:	9c 81       	ldd	r25, Y+4	; 0x04
    21d2:	82 1b       	sub	r24, r18
    21d4:	93 0b       	sbc	r25, r19
    21d6:	9c 83       	std	Y+4, r25	; 0x04
    21d8:	8b 83       	std	Y+3, r24	; 0x03
    } while( xOriginalTail != pxStreamBuffer->xTail );
    21da:	ed 81       	ldd	r30, Y+5	; 0x05
    21dc:	fe 81       	ldd	r31, Y+6	; 0x06
    21de:	20 81       	ld	r18, Z
    21e0:	31 81       	ldd	r19, Z+1	; 0x01
    21e2:	89 81       	ldd	r24, Y+1	; 0x01
    21e4:	9a 81       	ldd	r25, Y+2	; 0x02
    21e6:	28 17       	cp	r18, r24
    21e8:	39 07       	cpc	r19, r25
    21ea:	d9 f6       	brne	.-74     	; 0x21a2 <xStreamBufferSpacesAvailable+0x20>

    xSpace -= ( size_t ) 1;
    21ec:	8b 81       	ldd	r24, Y+3	; 0x03
    21ee:	9c 81       	ldd	r25, Y+4	; 0x04
    21f0:	01 97       	sbiw	r24, 0x01	; 1
    21f2:	9c 83       	std	Y+4, r25	; 0x04
    21f4:	8b 83       	std	Y+3, r24	; 0x03

    if( xSpace >= pxStreamBuffer->xLength )
    21f6:	ed 81       	ldd	r30, Y+5	; 0x05
    21f8:	fe 81       	ldd	r31, Y+6	; 0x06
    21fa:	24 81       	ldd	r18, Z+4	; 0x04
    21fc:	35 81       	ldd	r19, Z+5	; 0x05
    21fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2200:	9c 81       	ldd	r25, Y+4	; 0x04
    2202:	82 17       	cp	r24, r18
    2204:	93 07       	cpc	r25, r19
    2206:	50 f0       	brcs	.+20     	; 0x221c <xStreamBufferSpacesAvailable+0x9a>
    {
        xSpace -= pxStreamBuffer->xLength;
    2208:	ed 81       	ldd	r30, Y+5	; 0x05
    220a:	fe 81       	ldd	r31, Y+6	; 0x06
    220c:	24 81       	ldd	r18, Z+4	; 0x04
    220e:	35 81       	ldd	r19, Z+5	; 0x05
    2210:	8b 81       	ldd	r24, Y+3	; 0x03
    2212:	9c 81       	ldd	r25, Y+4	; 0x04
    2214:	82 1b       	sub	r24, r18
    2216:	93 0b       	sbc	r25, r19
    2218:	9c 83       	std	Y+4, r25	; 0x04
    221a:	8b 83       	std	Y+3, r24	; 0x03
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
    221c:	8b 81       	ldd	r24, Y+3	; 0x03
    221e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2220:	28 96       	adiw	r28, 0x08	; 8
    2222:	0f b6       	in	r0, 0x3f	; 63
    2224:	f8 94       	cli
    2226:	de bf       	out	0x3e, r29	; 62
    2228:	0f be       	out	0x3f, r0	; 63
    222a:	cd bf       	out	0x3d, r28	; 61
    222c:	cf 91       	pop	r28
    222e:	df 91       	pop	r29
    2230:	08 95       	ret

00002232 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2232:	df 93       	push	r29
    2234:	cf 93       	push	r28
    2236:	00 d0       	rcall	.+0      	; 0x2238 <xStreamBufferBytesAvailable+0x6>
    2238:	00 d0       	rcall	.+0      	; 0x223a <xStreamBufferBytesAvailable+0x8>
    223a:	00 d0       	rcall	.+0      	; 0x223c <xStreamBufferBytesAvailable+0xa>
    223c:	cd b7       	in	r28, 0x3d	; 61
    223e:	de b7       	in	r29, 0x3e	; 62
    2240:	9e 83       	std	Y+6, r25	; 0x06
    2242:	8d 83       	std	Y+5, r24	; 0x05
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2244:	8d 81       	ldd	r24, Y+5	; 0x05
    2246:	9e 81       	ldd	r25, Y+6	; 0x06
    2248:	9c 83       	std	Y+4, r25	; 0x04
    224a:	8b 83       	std	Y+3, r24	; 0x03
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    224c:	8b 81       	ldd	r24, Y+3	; 0x03
    224e:	9c 81       	ldd	r25, Y+4	; 0x04
    2250:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvBytesInBuffer>
    2254:	9a 83       	std	Y+2, r25	; 0x02
    2256:	89 83       	std	Y+1, r24	; 0x01
    return xReturn;
    2258:	89 81       	ldd	r24, Y+1	; 0x01
    225a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    225c:	26 96       	adiw	r28, 0x06	; 6
    225e:	0f b6       	in	r0, 0x3f	; 63
    2260:	f8 94       	cli
    2262:	de bf       	out	0x3e, r29	; 62
    2264:	0f be       	out	0x3f, r0	; 63
    2266:	cd bf       	out	0x3d, r28	; 61
    2268:	cf 91       	pop	r28
    226a:	df 91       	pop	r29
    226c:	08 95       	ret

0000226e <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    226e:	cf 92       	push	r12
    2270:	df 92       	push	r13
    2272:	ef 92       	push	r14
    2274:	ff 92       	push	r15
    2276:	0f 93       	push	r16
    2278:	1f 93       	push	r17
    227a:	df 93       	push	r29
    227c:	cf 93       	push	r28
    227e:	cd b7       	in	r28, 0x3d	; 61
    2280:	de b7       	in	r29, 0x3e	; 62
    2282:	65 97       	sbiw	r28, 0x15	; 21
    2284:	0f b6       	in	r0, 0x3f	; 63
    2286:	f8 94       	cli
    2288:	de bf       	out	0x3e, r29	; 62
    228a:	0f be       	out	0x3f, r0	; 63
    228c:	cd bf       	out	0x3d, r28	; 61
    228e:	9f 87       	std	Y+15, r25	; 0x0f
    2290:	8e 87       	std	Y+14, r24	; 0x0e
    2292:	79 8b       	std	Y+17, r23	; 0x11
    2294:	68 8b       	std	Y+16, r22	; 0x10
    2296:	5b 8b       	std	Y+19, r21	; 0x13
    2298:	4a 8b       	std	Y+18, r20	; 0x12
    229a:	3d 8b       	std	Y+21, r19	; 0x15
    229c:	2c 8b       	std	Y+20, r18	; 0x14
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    229e:	8e 85       	ldd	r24, Y+14	; 0x0e
    22a0:	9f 85       	ldd	r25, Y+15	; 0x0f
    22a2:	9a 87       	std	Y+10, r25	; 0x0a
    22a4:	89 87       	std	Y+9, r24	; 0x09
    size_t xReturn, xSpace = 0;
    22a6:	1e 82       	std	Y+6, r1	; 0x06
    22a8:	1d 82       	std	Y+5, r1	; 0x05
    size_t xRequiredSpace = xDataLengthBytes;
    22aa:	8a 89       	ldd	r24, Y+18	; 0x12
    22ac:	9b 89       	ldd	r25, Y+19	; 0x13
    22ae:	9c 83       	std	Y+4, r25	; 0x04
    22b0:	8b 83       	std	Y+3, r24	; 0x03
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
    22b2:	1a 82       	std	Y+2, r1	; 0x02
    22b4:	19 82       	std	Y+1, r1	; 0x01
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    22b6:	e9 85       	ldd	r30, Y+9	; 0x09
    22b8:	fa 85       	ldd	r31, Y+10	; 0x0a
    22ba:	84 81       	ldd	r24, Z+4	; 0x04
    22bc:	95 81       	ldd	r25, Z+5	; 0x05
    22be:	01 97       	sbiw	r24, 0x01	; 1
    22c0:	9a 83       	std	Y+2, r25	; 0x02
    22c2:	89 83       	std	Y+1, r24	; 0x01

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    22c4:	e9 85       	ldd	r30, Y+9	; 0x09
    22c6:	fa 85       	ldd	r31, Y+10	; 0x0a
    22c8:	86 85       	ldd	r24, Z+14	; 0x0e
    22ca:	88 2f       	mov	r24, r24
    22cc:	90 e0       	ldi	r25, 0x00	; 0
    22ce:	81 70       	andi	r24, 0x01	; 1
    22d0:	90 70       	andi	r25, 0x00	; 0
    22d2:	88 23       	and	r24, r24
    22d4:	79 f0       	breq	.+30     	; 0x22f4 <xStreamBufferSend+0x86>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    22d6:	8b 81       	ldd	r24, Y+3	; 0x03
    22d8:	9c 81       	ldd	r25, Y+4	; 0x04
    22da:	02 96       	adiw	r24, 0x02	; 2
    22dc:	9c 83       	std	Y+4, r25	; 0x04
    22de:	8b 83       	std	Y+3, r24	; 0x03
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    22e0:	2b 81       	ldd	r18, Y+3	; 0x03
    22e2:	3c 81       	ldd	r19, Y+4	; 0x04
    22e4:	89 81       	ldd	r24, Y+1	; 0x01
    22e6:	9a 81       	ldd	r25, Y+2	; 0x02
    22e8:	82 17       	cp	r24, r18
    22ea:	93 07       	cpc	r25, r19
    22ec:	70 f4       	brcc	.+28     	; 0x230a <xStreamBufferSend+0x9c>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    22ee:	1d 8a       	std	Y+21, r1	; 0x15
    22f0:	1c 8a       	std	Y+20, r1	; 0x14
    22f2:	0b c0       	rjmp	.+22     	; 0x230a <xStreamBufferSend+0x9c>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
    22f4:	2b 81       	ldd	r18, Y+3	; 0x03
    22f6:	3c 81       	ldd	r19, Y+4	; 0x04
    22f8:	89 81       	ldd	r24, Y+1	; 0x01
    22fa:	9a 81       	ldd	r25, Y+2	; 0x02
    22fc:	82 17       	cp	r24, r18
    22fe:	93 07       	cpc	r25, r19
    2300:	20 f4       	brcc	.+8      	; 0x230a <xStreamBufferSend+0x9c>
        {
            xRequiredSpace = xMaxReportedSpace;
    2302:	89 81       	ldd	r24, Y+1	; 0x01
    2304:	9a 81       	ldd	r25, Y+2	; 0x02
    2306:	9c 83       	std	Y+4, r25	; 0x04
    2308:	8b 83       	std	Y+3, r24	; 0x03
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    230a:	8c 89       	ldd	r24, Y+20	; 0x14
    230c:	9d 89       	ldd	r25, Y+21	; 0x15
    230e:	00 97       	sbiw	r24, 0x00	; 0
    2310:	09 f4       	brne	.+2      	; 0x2314 <xStreamBufferSend+0xa6>
    2312:	43 c0       	rjmp	.+134    	; 0x239a <xStreamBufferSend+0x12c>
    {
        vTaskSetTimeOutState( &xTimeOut );
    2314:	ce 01       	movw	r24, r28
    2316:	0b 96       	adiw	r24, 0x0b	; 11
    2318:	0e 94 93 21 	call	0x4326	; 0x4326 <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    231c:	0f b6       	in	r0, 0x3f	; 63
    231e:	f8 94       	cli
    2320:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2322:	89 85       	ldd	r24, Y+9	; 0x09
    2324:	9a 85       	ldd	r25, Y+10	; 0x0a
    2326:	0e 94 c1 10 	call	0x2182	; 0x2182 <xStreamBufferSpacesAvailable>
    232a:	9e 83       	std	Y+6, r25	; 0x06
    232c:	8d 83       	std	Y+5, r24	; 0x05

                if( xSpace < xRequiredSpace )
    232e:	2d 81       	ldd	r18, Y+5	; 0x05
    2330:	3e 81       	ldd	r19, Y+6	; 0x06
    2332:	8b 81       	ldd	r24, Y+3	; 0x03
    2334:	9c 81       	ldd	r25, Y+4	; 0x04
    2336:	28 17       	cp	r18, r24
    2338:	39 07       	cpc	r19, r25
    233a:	68 f5       	brcc	.+90     	; 0x2396 <xStreamBufferSend+0x128>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    233c:	80 e0       	ldi	r24, 0x00	; 0
    233e:	90 e0       	ldi	r25, 0x00	; 0
    2340:	60 e0       	ldi	r22, 0x00	; 0
    2342:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    2346:	0e 94 ef 22 	call	0x45de	; 0x45de <xTaskGetCurrentTaskHandle>
    234a:	e9 85       	ldd	r30, Y+9	; 0x09
    234c:	fa 85       	ldd	r31, Y+10	; 0x0a
    234e:	93 87       	std	Z+11, r25	; 0x0b
    2350:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    2352:	0f 90       	pop	r0
    2354:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2356:	ec 89       	ldd	r30, Y+20	; 0x14
    2358:	fd 89       	ldd	r31, Y+21	; 0x15
    235a:	80 e0       	ldi	r24, 0x00	; 0
    235c:	40 e0       	ldi	r20, 0x00	; 0
    235e:	50 e0       	ldi	r21, 0x00	; 0
    2360:	60 e0       	ldi	r22, 0x00	; 0
    2362:	70 e0       	ldi	r23, 0x00	; 0
    2364:	00 e0       	ldi	r16, 0x00	; 0
    2366:	10 e0       	ldi	r17, 0x00	; 0
    2368:	20 e0       	ldi	r18, 0x00	; 0
    236a:	30 e0       	ldi	r19, 0x00	; 0
    236c:	ee 24       	eor	r14, r14
    236e:	ff 24       	eor	r15, r15
    2370:	6f 01       	movw	r12, r30
    2372:	0e 94 de 23 	call	0x47bc	; 0x47bc <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    2376:	e9 85       	ldd	r30, Y+9	; 0x09
    2378:	fa 85       	ldd	r31, Y+10	; 0x0a
    237a:	13 86       	std	Z+11, r1	; 0x0b
    237c:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    237e:	ce 01       	movw	r24, r28
    2380:	0b 96       	adiw	r24, 0x0b	; 11
    2382:	9e 01       	movw	r18, r28
    2384:	2c 5e       	subi	r18, 0xEC	; 236
    2386:	3f 4f       	sbci	r19, 0xFF	; 255
    2388:	b9 01       	movw	r22, r18
    238a:	0e 94 ca 21 	call	0x4394	; 0x4394 <xTaskCheckForTimeOut>
    238e:	88 23       	and	r24, r24
    2390:	09 f4       	brne	.+2      	; 0x2394 <xStreamBufferSend+0x126>
    2392:	c4 cf       	rjmp	.-120    	; 0x231c <xStreamBufferSend+0xae>
    2394:	02 c0       	rjmp	.+4      	; 0x239a <xStreamBufferSend+0x12c>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    2396:	0f 90       	pop	r0
    2398:	0f be       	out	0x3f, r0	; 63
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    239a:	8d 81       	ldd	r24, Y+5	; 0x05
    239c:	9e 81       	ldd	r25, Y+6	; 0x06
    239e:	00 97       	sbiw	r24, 0x00	; 0
    23a0:	31 f4       	brne	.+12     	; 0x23ae <xStreamBufferSend+0x140>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    23a2:	89 85       	ldd	r24, Y+9	; 0x09
    23a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    23a6:	0e 94 c1 10 	call	0x2182	; 0x2182 <xStreamBufferSpacesAvailable>
    23aa:	9e 83       	std	Y+6, r25	; 0x06
    23ac:	8d 83       	std	Y+5, r24	; 0x05
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    23ae:	89 85       	ldd	r24, Y+9	; 0x09
    23b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    23b2:	28 89       	ldd	r18, Y+16	; 0x10
    23b4:	39 89       	ldd	r19, Y+17	; 0x11
    23b6:	4a 89       	ldd	r20, Y+18	; 0x12
    23b8:	5b 89       	ldd	r21, Y+19	; 0x13
    23ba:	ed 81       	ldd	r30, Y+5	; 0x05
    23bc:	fe 81       	ldd	r31, Y+6	; 0x06
    23be:	ab 81       	ldd	r26, Y+3	; 0x03
    23c0:	bc 81       	ldd	r27, Y+4	; 0x04
    23c2:	b9 01       	movw	r22, r18
    23c4:	9f 01       	movw	r18, r30
    23c6:	8d 01       	movw	r16, r26
    23c8:	0e 94 a7 12 	call	0x254e	; 0x254e <prvWriteMessageToBuffer>
    23cc:	98 87       	std	Y+8, r25	; 0x08
    23ce:	8f 83       	std	Y+7, r24	; 0x07

    if( xReturn > ( size_t ) 0 )
    23d0:	8f 81       	ldd	r24, Y+7	; 0x07
    23d2:	98 85       	ldd	r25, Y+8	; 0x08
    23d4:	00 97       	sbiw	r24, 0x00	; 0
    23d6:	41 f1       	breq	.+80     	; 0x2428 <xStreamBufferSend+0x1ba>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    23d8:	89 85       	ldd	r24, Y+9	; 0x09
    23da:	9a 85       	ldd	r25, Y+10	; 0x0a
    23dc:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvBytesInBuffer>
    23e0:	9c 01       	movw	r18, r24
    23e2:	e9 85       	ldd	r30, Y+9	; 0x09
    23e4:	fa 85       	ldd	r31, Y+10	; 0x0a
    23e6:	86 81       	ldd	r24, Z+6	; 0x06
    23e8:	97 81       	ldd	r25, Z+7	; 0x07
    23ea:	28 17       	cp	r18, r24
    23ec:	39 07       	cpc	r19, r25
    23ee:	e0 f0       	brcs	.+56     	; 0x2428 <xStreamBufferSend+0x1ba>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
    23f0:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
    23f4:	e9 85       	ldd	r30, Y+9	; 0x09
    23f6:	fa 85       	ldd	r31, Y+10	; 0x0a
    23f8:	80 85       	ldd	r24, Z+8	; 0x08
    23fa:	91 85       	ldd	r25, Z+9	; 0x09
    23fc:	00 97       	sbiw	r24, 0x00	; 0
    23fe:	91 f0       	breq	.+36     	; 0x2424 <xStreamBufferSend+0x1b6>
    2400:	e9 85       	ldd	r30, Y+9	; 0x09
    2402:	fa 85       	ldd	r31, Y+10	; 0x0a
    2404:	80 85       	ldd	r24, Z+8	; 0x08
    2406:	91 85       	ldd	r25, Z+9	; 0x09
    2408:	60 e0       	ldi	r22, 0x00	; 0
    240a:	20 e0       	ldi	r18, 0x00	; 0
    240c:	30 e0       	ldi	r19, 0x00	; 0
    240e:	40 e0       	ldi	r20, 0x00	; 0
    2410:	50 e0       	ldi	r21, 0x00	; 0
    2412:	00 e0       	ldi	r16, 0x00	; 0
    2414:	ee 24       	eor	r14, r14
    2416:	ff 24       	eor	r15, r15
    2418:	0e 94 d5 24 	call	0x49aa	; 0x49aa <xTaskGenericNotify>
    241c:	e9 85       	ldd	r30, Y+9	; 0x09
    241e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2420:	11 86       	std	Z+9, r1	; 0x09
    2422:	10 86       	std	Z+8, r1	; 0x08
    2424:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
    2428:	8f 81       	ldd	r24, Y+7	; 0x07
    242a:	98 85       	ldd	r25, Y+8	; 0x08
}
    242c:	65 96       	adiw	r28, 0x15	; 21
    242e:	0f b6       	in	r0, 0x3f	; 63
    2430:	f8 94       	cli
    2432:	de bf       	out	0x3e, r29	; 62
    2434:	0f be       	out	0x3f, r0	; 63
    2436:	cd bf       	out	0x3d, r28	; 61
    2438:	cf 91       	pop	r28
    243a:	df 91       	pop	r29
    243c:	1f 91       	pop	r17
    243e:	0f 91       	pop	r16
    2440:	ff 90       	pop	r15
    2442:	ef 90       	pop	r14
    2444:	df 90       	pop	r13
    2446:	cf 90       	pop	r12
    2448:	08 95       	ret

0000244a <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    244a:	cf 92       	push	r12
    244c:	df 92       	push	r13
    244e:	ef 92       	push	r14
    2450:	ff 92       	push	r15
    2452:	0f 93       	push	r16
    2454:	1f 93       	push	r17
    2456:	df 93       	push	r29
    2458:	cf 93       	push	r28
    245a:	cd b7       	in	r28, 0x3d	; 61
    245c:	de b7       	in	r29, 0x3e	; 62
    245e:	61 97       	sbiw	r28, 0x11	; 17
    2460:	0f b6       	in	r0, 0x3f	; 63
    2462:	f8 94       	cli
    2464:	de bf       	out	0x3e, r29	; 62
    2466:	0f be       	out	0x3f, r0	; 63
    2468:	cd bf       	out	0x3d, r28	; 61
    246a:	9b 87       	std	Y+11, r25	; 0x0b
    246c:	8a 87       	std	Y+10, r24	; 0x0a
    246e:	7d 87       	std	Y+13, r23	; 0x0d
    2470:	6c 87       	std	Y+12, r22	; 0x0c
    2472:	5f 87       	std	Y+15, r21	; 0x0f
    2474:	4e 87       	std	Y+14, r20	; 0x0e
    2476:	39 8b       	std	Y+17, r19	; 0x11
    2478:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    247a:	8a 85       	ldd	r24, Y+10	; 0x0a
    247c:	9b 85       	ldd	r25, Y+11	; 0x0b
    247e:	99 87       	std	Y+9, r25	; 0x09
    2480:	88 87       	std	Y+8, r24	; 0x08
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
    2482:	8e 85       	ldd	r24, Y+14	; 0x0e
    2484:	9f 85       	ldd	r25, Y+15	; 0x0f
    2486:	9b 83       	std	Y+3, r25	; 0x03
    2488:	8a 83       	std	Y+2, r24	; 0x02

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    248a:	e8 85       	ldd	r30, Y+8	; 0x08
    248c:	f9 85       	ldd	r31, Y+9	; 0x09
    248e:	86 85       	ldd	r24, Z+14	; 0x0e
    2490:	88 2f       	mov	r24, r24
    2492:	90 e0       	ldi	r25, 0x00	; 0
    2494:	81 70       	andi	r24, 0x01	; 1
    2496:	90 70       	andi	r25, 0x00	; 0
    2498:	88 23       	and	r24, r24
    249a:	29 f0       	breq	.+10     	; 0x24a6 <xStreamBufferSendFromISR+0x5c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    249c:	8a 81       	ldd	r24, Y+2	; 0x02
    249e:	9b 81       	ldd	r25, Y+3	; 0x03
    24a0:	02 96       	adiw	r24, 0x02	; 2
    24a2:	9b 83       	std	Y+3, r25	; 0x03
    24a4:	8a 83       	std	Y+2, r24	; 0x02
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    24a6:	88 85       	ldd	r24, Y+8	; 0x08
    24a8:	99 85       	ldd	r25, Y+9	; 0x09
    24aa:	0e 94 c1 10 	call	0x2182	; 0x2182 <xStreamBufferSpacesAvailable>
    24ae:	9d 83       	std	Y+5, r25	; 0x05
    24b0:	8c 83       	std	Y+4, r24	; 0x04
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    24b2:	88 85       	ldd	r24, Y+8	; 0x08
    24b4:	99 85       	ldd	r25, Y+9	; 0x09
    24b6:	2c 85       	ldd	r18, Y+12	; 0x0c
    24b8:	3d 85       	ldd	r19, Y+13	; 0x0d
    24ba:	4e 85       	ldd	r20, Y+14	; 0x0e
    24bc:	5f 85       	ldd	r21, Y+15	; 0x0f
    24be:	ec 81       	ldd	r30, Y+4	; 0x04
    24c0:	fd 81       	ldd	r31, Y+5	; 0x05
    24c2:	aa 81       	ldd	r26, Y+2	; 0x02
    24c4:	bb 81       	ldd	r27, Y+3	; 0x03
    24c6:	b9 01       	movw	r22, r18
    24c8:	9f 01       	movw	r18, r30
    24ca:	8d 01       	movw	r16, r26
    24cc:	0e 94 a7 12 	call	0x254e	; 0x254e <prvWriteMessageToBuffer>
    24d0:	9f 83       	std	Y+7, r25	; 0x07
    24d2:	8e 83       	std	Y+6, r24	; 0x06

    if( xReturn > ( size_t ) 0 )
    24d4:	8e 81       	ldd	r24, Y+6	; 0x06
    24d6:	9f 81       	ldd	r25, Y+7	; 0x07
    24d8:	00 97       	sbiw	r24, 0x00	; 0
    24da:	41 f1       	breq	.+80     	; 0x252c <xStreamBufferSendFromISR+0xe2>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    24dc:	88 85       	ldd	r24, Y+8	; 0x08
    24de:	99 85       	ldd	r25, Y+9	; 0x09
    24e0:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvBytesInBuffer>
    24e4:	9c 01       	movw	r18, r24
    24e6:	e8 85       	ldd	r30, Y+8	; 0x08
    24e8:	f9 85       	ldd	r31, Y+9	; 0x09
    24ea:	86 81       	ldd	r24, Z+6	; 0x06
    24ec:	97 81       	ldd	r25, Z+7	; 0x07
    24ee:	28 17       	cp	r18, r24
    24f0:	39 07       	cpc	r19, r25
    24f2:	e0 f0       	brcs	.+56     	; 0x252c <xStreamBufferSendFromISR+0xe2>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    24f4:	19 82       	std	Y+1, r1	; 0x01
    24f6:	e8 85       	ldd	r30, Y+8	; 0x08
    24f8:	f9 85       	ldd	r31, Y+9	; 0x09
    24fa:	80 85       	ldd	r24, Z+8	; 0x08
    24fc:	91 85       	ldd	r25, Z+9	; 0x09
    24fe:	00 97       	sbiw	r24, 0x00	; 0
    2500:	a9 f0       	breq	.+42     	; 0x252c <xStreamBufferSendFromISR+0xe2>
    2502:	e8 85       	ldd	r30, Y+8	; 0x08
    2504:	f9 85       	ldd	r31, Y+9	; 0x09
    2506:	80 85       	ldd	r24, Z+8	; 0x08
    2508:	91 85       	ldd	r25, Z+9	; 0x09
    250a:	e8 89       	ldd	r30, Y+16	; 0x10
    250c:	f9 89       	ldd	r31, Y+17	; 0x11
    250e:	60 e0       	ldi	r22, 0x00	; 0
    2510:	20 e0       	ldi	r18, 0x00	; 0
    2512:	30 e0       	ldi	r19, 0x00	; 0
    2514:	40 e0       	ldi	r20, 0x00	; 0
    2516:	50 e0       	ldi	r21, 0x00	; 0
    2518:	00 e0       	ldi	r16, 0x00	; 0
    251a:	ee 24       	eor	r14, r14
    251c:	ff 24       	eor	r15, r15
    251e:	6f 01       	movw	r12, r30
    2520:	0e 94 93 26 	call	0x4d26	; 0x4d26 <xTaskGenericNotifyFromISR>
    2524:	e8 85       	ldd	r30, Y+8	; 0x08
    2526:	f9 85       	ldd	r31, Y+9	; 0x09
    2528:	11 86       	std	Z+9, r1	; 0x09
    252a:	10 86       	std	Z+8, r1	; 0x08
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
    252c:	8e 81       	ldd	r24, Y+6	; 0x06
    252e:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2530:	61 96       	adiw	r28, 0x11	; 17
    2532:	0f b6       	in	r0, 0x3f	; 63
    2534:	f8 94       	cli
    2536:	de bf       	out	0x3e, r29	; 62
    2538:	0f be       	out	0x3f, r0	; 63
    253a:	cd bf       	out	0x3d, r28	; 61
    253c:	cf 91       	pop	r28
    253e:	df 91       	pop	r29
    2540:	1f 91       	pop	r17
    2542:	0f 91       	pop	r16
    2544:	ff 90       	pop	r15
    2546:	ef 90       	pop	r14
    2548:	df 90       	pop	r13
    254a:	cf 90       	pop	r12
    254c:	08 95       	ret

0000254e <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    254e:	0f 93       	push	r16
    2550:	1f 93       	push	r17
    2552:	df 93       	push	r29
    2554:	cf 93       	push	r28
    2556:	cd b7       	in	r28, 0x3d	; 61
    2558:	de b7       	in	r29, 0x3e	; 62
    255a:	62 97       	sbiw	r28, 0x12	; 18
    255c:	0f b6       	in	r0, 0x3f	; 63
    255e:	f8 94       	cli
    2560:	de bf       	out	0x3e, r29	; 62
    2562:	0f be       	out	0x3f, r0	; 63
    2564:	cd bf       	out	0x3d, r28	; 61
    2566:	9e 83       	std	Y+6, r25	; 0x06
    2568:	8d 83       	std	Y+5, r24	; 0x05
    256a:	78 87       	std	Y+8, r23	; 0x08
    256c:	6f 83       	std	Y+7, r22	; 0x07
    256e:	5a 87       	std	Y+10, r21	; 0x0a
    2570:	49 87       	std	Y+9, r20	; 0x09
    2572:	3c 87       	std	Y+12, r19	; 0x0c
    2574:	2b 87       	std	Y+11, r18	; 0x0b
    2576:	1e 87       	std	Y+14, r17	; 0x0e
    2578:	0d 87       	std	Y+13, r16	; 0x0d
    size_t xNextHead = pxStreamBuffer->xHead;
    257a:	ed 81       	ldd	r30, Y+5	; 0x05
    257c:	fe 81       	ldd	r31, Y+6	; 0x06
    257e:	82 81       	ldd	r24, Z+2	; 0x02
    2580:	93 81       	ldd	r25, Z+3	; 0x03
    2582:	9a 83       	std	Y+2, r25	; 0x02
    2584:	89 83       	std	Y+1, r24	; 0x01
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2586:	ed 81       	ldd	r30, Y+5	; 0x05
    2588:	fe 81       	ldd	r31, Y+6	; 0x06
    258a:	86 85       	ldd	r24, Z+14	; 0x0e
    258c:	88 2f       	mov	r24, r24
    258e:	90 e0       	ldi	r25, 0x00	; 0
    2590:	81 70       	andi	r24, 0x01	; 1
    2592:	90 70       	andi	r25, 0x00	; 0
    2594:	88 23       	and	r24, r24
    2596:	f1 f0       	breq	.+60     	; 0x25d4 <prvWriteMessageToBuffer+0x86>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
    2598:	89 85       	ldd	r24, Y+9	; 0x09
    259a:	9a 85       	ldd	r25, Y+10	; 0x0a
    259c:	9c 83       	std	Y+4, r25	; 0x04
    259e:	8b 83       	std	Y+3, r24	; 0x03

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
    25a0:	2b 85       	ldd	r18, Y+11	; 0x0b
    25a2:	3c 85       	ldd	r19, Y+12	; 0x0c
    25a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    25a6:	9e 85       	ldd	r25, Y+14	; 0x0e
    25a8:	28 17       	cp	r18, r24
    25aa:	39 07       	cpc	r19, r25
    25ac:	80 f0       	brcs	.+32     	; 0x25ce <prvWriteMessageToBuffer+0x80>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    25ae:	9e 01       	movw	r18, r28
    25b0:	2d 5f       	subi	r18, 0xFD	; 253
    25b2:	3f 4f       	sbci	r19, 0xFF	; 255
    25b4:	8d 81       	ldd	r24, Y+5	; 0x05
    25b6:	9e 81       	ldd	r25, Y+6	; 0x06
    25b8:	e9 81       	ldd	r30, Y+1	; 0x01
    25ba:	fa 81       	ldd	r31, Y+2	; 0x02
    25bc:	b9 01       	movw	r22, r18
    25be:	42 e0       	ldi	r20, 0x02	; 2
    25c0:	50 e0       	ldi	r21, 0x00	; 0
    25c2:	9f 01       	movw	r18, r30
    25c4:	0e 94 11 16 	call	0x2c22	; 0x2c22 <prvWriteBytesToBuffer>
    25c8:	9a 83       	std	Y+2, r25	; 0x02
    25ca:	89 83       	std	Y+1, r24	; 0x01
    25cc:	1a c0       	rjmp	.+52     	; 0x2602 <prvWriteMessageToBuffer+0xb4>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
    25ce:	1a 86       	std	Y+10, r1	; 0x0a
    25d0:	19 86       	std	Y+9, r1	; 0x09
    25d2:	17 c0       	rjmp	.+46     	; 0x2602 <prvWriteMessageToBuffer+0xb4>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    25d4:	29 85       	ldd	r18, Y+9	; 0x09
    25d6:	3a 85       	ldd	r19, Y+10	; 0x0a
    25d8:	3a 8b       	std	Y+18, r19	; 0x12
    25da:	29 8b       	std	Y+17, r18	; 0x11
    25dc:	8b 85       	ldd	r24, Y+11	; 0x0b
    25de:	9c 85       	ldd	r25, Y+12	; 0x0c
    25e0:	98 8b       	std	Y+16, r25	; 0x10
    25e2:	8f 87       	std	Y+15, r24	; 0x0f
    25e4:	2f 85       	ldd	r18, Y+15	; 0x0f
    25e6:	38 89       	ldd	r19, Y+16	; 0x10
    25e8:	89 89       	ldd	r24, Y+17	; 0x11
    25ea:	9a 89       	ldd	r25, Y+18	; 0x12
    25ec:	82 17       	cp	r24, r18
    25ee:	93 07       	cpc	r25, r19
    25f0:	20 f4       	brcc	.+8      	; 0x25fa <prvWriteMessageToBuffer+0xac>
    25f2:	29 89       	ldd	r18, Y+17	; 0x11
    25f4:	3a 89       	ldd	r19, Y+18	; 0x12
    25f6:	38 8b       	std	Y+16, r19	; 0x10
    25f8:	2f 87       	std	Y+15, r18	; 0x0f
    25fa:	8f 85       	ldd	r24, Y+15	; 0x0f
    25fc:	98 89       	ldd	r25, Y+16	; 0x10
    25fe:	9a 87       	std	Y+10, r25	; 0x0a
    2600:	89 87       	std	Y+9, r24	; 0x09
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    2602:	89 85       	ldd	r24, Y+9	; 0x09
    2604:	9a 85       	ldd	r25, Y+10	; 0x0a
    2606:	00 97       	sbiw	r24, 0x00	; 0
    2608:	89 f0       	breq	.+34     	; 0x262c <prvWriteMessageToBuffer+0xde>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    260a:	4f 81       	ldd	r20, Y+7	; 0x07
    260c:	58 85       	ldd	r21, Y+8	; 0x08
    260e:	8d 81       	ldd	r24, Y+5	; 0x05
    2610:	9e 81       	ldd	r25, Y+6	; 0x06
    2612:	29 85       	ldd	r18, Y+9	; 0x09
    2614:	3a 85       	ldd	r19, Y+10	; 0x0a
    2616:	e9 81       	ldd	r30, Y+1	; 0x01
    2618:	fa 81       	ldd	r31, Y+2	; 0x02
    261a:	ba 01       	movw	r22, r20
    261c:	a9 01       	movw	r20, r18
    261e:	9f 01       	movw	r18, r30
    2620:	0e 94 11 16 	call	0x2c22	; 0x2c22 <prvWriteBytesToBuffer>
    2624:	ed 81       	ldd	r30, Y+5	; 0x05
    2626:	fe 81       	ldd	r31, Y+6	; 0x06
    2628:	93 83       	std	Z+3, r25	; 0x03
    262a:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
    262c:	89 85       	ldd	r24, Y+9	; 0x09
    262e:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2630:	62 96       	adiw	r28, 0x12	; 18
    2632:	0f b6       	in	r0, 0x3f	; 63
    2634:	f8 94       	cli
    2636:	de bf       	out	0x3e, r29	; 62
    2638:	0f be       	out	0x3f, r0	; 63
    263a:	cd bf       	out	0x3d, r28	; 61
    263c:	cf 91       	pop	r28
    263e:	df 91       	pop	r29
    2640:	1f 91       	pop	r17
    2642:	0f 91       	pop	r16
    2644:	08 95       	ret

00002646 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    2646:	cf 92       	push	r12
    2648:	df 92       	push	r13
    264a:	ef 92       	push	r14
    264c:	ff 92       	push	r15
    264e:	0f 93       	push	r16
    2650:	1f 93       	push	r17
    2652:	df 93       	push	r29
    2654:	cf 93       	push	r28
    2656:	cd b7       	in	r28, 0x3d	; 61
    2658:	de b7       	in	r29, 0x3e	; 62
    265a:	60 97       	sbiw	r28, 0x10	; 16
    265c:	0f b6       	in	r0, 0x3f	; 63
    265e:	f8 94       	cli
    2660:	de bf       	out	0x3e, r29	; 62
    2662:	0f be       	out	0x3f, r0	; 63
    2664:	cd bf       	out	0x3d, r28	; 61
    2666:	9a 87       	std	Y+10, r25	; 0x0a
    2668:	89 87       	std	Y+9, r24	; 0x09
    266a:	7c 87       	std	Y+12, r23	; 0x0c
    266c:	6b 87       	std	Y+11, r22	; 0x0b
    266e:	5e 87       	std	Y+14, r21	; 0x0e
    2670:	4d 87       	std	Y+13, r20	; 0x0d
    2672:	38 8b       	std	Y+16, r19	; 0x10
    2674:	2f 87       	std	Y+15, r18	; 0x0f
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2676:	89 85       	ldd	r24, Y+9	; 0x09
    2678:	9a 85       	ldd	r25, Y+10	; 0x0a
    267a:	98 87       	std	Y+8, r25	; 0x08
    267c:	8f 83       	std	Y+7, r24	; 0x07
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    267e:	1e 82       	std	Y+6, r1	; 0x06
    2680:	1d 82       	std	Y+5, r1	; 0x05
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2682:	ef 81       	ldd	r30, Y+7	; 0x07
    2684:	f8 85       	ldd	r31, Y+8	; 0x08
    2686:	86 85       	ldd	r24, Z+14	; 0x0e
    2688:	88 2f       	mov	r24, r24
    268a:	90 e0       	ldi	r25, 0x00	; 0
    268c:	81 70       	andi	r24, 0x01	; 1
    268e:	90 70       	andi	r25, 0x00	; 0
    2690:	88 23       	and	r24, r24
    2692:	29 f0       	breq	.+10     	; 0x269e <xStreamBufferReceive+0x58>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2694:	82 e0       	ldi	r24, 0x02	; 2
    2696:	90 e0       	ldi	r25, 0x00	; 0
    2698:	9a 83       	std	Y+2, r25	; 0x02
    269a:	89 83       	std	Y+1, r24	; 0x01
    269c:	02 c0       	rjmp	.+4      	; 0x26a2 <xStreamBufferReceive+0x5c>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    269e:	1a 82       	std	Y+2, r1	; 0x02
    26a0:	19 82       	std	Y+1, r1	; 0x01
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    26a2:	8f 85       	ldd	r24, Y+15	; 0x0f
    26a4:	98 89       	ldd	r25, Y+16	; 0x10
    26a6:	00 97       	sbiw	r24, 0x00	; 0
    26a8:	09 f4       	brne	.+2      	; 0x26ac <xStreamBufferReceive+0x66>
    26aa:	3f c0       	rjmp	.+126    	; 0x272a <xStreamBufferReceive+0xe4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    26ac:	0f b6       	in	r0, 0x3f	; 63
    26ae:	f8 94       	cli
    26b0:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    26b2:	8f 81       	ldd	r24, Y+7	; 0x07
    26b4:	98 85       	ldd	r25, Y+8	; 0x08
    26b6:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvBytesInBuffer>
    26ba:	9c 83       	std	Y+4, r25	; 0x04
    26bc:	8b 83       	std	Y+3, r24	; 0x03
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    26be:	2b 81       	ldd	r18, Y+3	; 0x03
    26c0:	3c 81       	ldd	r19, Y+4	; 0x04
    26c2:	89 81       	ldd	r24, Y+1	; 0x01
    26c4:	9a 81       	ldd	r25, Y+2	; 0x02
    26c6:	82 17       	cp	r24, r18
    26c8:	93 07       	cpc	r25, r19
    26ca:	58 f0       	brcs	.+22     	; 0x26e2 <xStreamBufferReceive+0x9c>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    26cc:	80 e0       	ldi	r24, 0x00	; 0
    26ce:	90 e0       	ldi	r25, 0x00	; 0
    26d0:	60 e0       	ldi	r22, 0x00	; 0
    26d2:	0e 94 e2 29 	call	0x53c4	; 0x53c4 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    26d6:	0e 94 ef 22 	call	0x45de	; 0x45de <xTaskGetCurrentTaskHandle>
    26da:	ef 81       	ldd	r30, Y+7	; 0x07
    26dc:	f8 85       	ldd	r31, Y+8	; 0x08
    26de:	91 87       	std	Z+9, r25	; 0x09
    26e0:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    26e2:	0f 90       	pop	r0
    26e4:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    26e6:	2b 81       	ldd	r18, Y+3	; 0x03
    26e8:	3c 81       	ldd	r19, Y+4	; 0x04
    26ea:	89 81       	ldd	r24, Y+1	; 0x01
    26ec:	9a 81       	ldd	r25, Y+2	; 0x02
    26ee:	82 17       	cp	r24, r18
    26f0:	93 07       	cpc	r25, r19
    26f2:	08 f1       	brcs	.+66     	; 0x2736 <xStreamBufferReceive+0xf0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    26f4:	ef 85       	ldd	r30, Y+15	; 0x0f
    26f6:	f8 89       	ldd	r31, Y+16	; 0x10
    26f8:	80 e0       	ldi	r24, 0x00	; 0
    26fa:	40 e0       	ldi	r20, 0x00	; 0
    26fc:	50 e0       	ldi	r21, 0x00	; 0
    26fe:	60 e0       	ldi	r22, 0x00	; 0
    2700:	70 e0       	ldi	r23, 0x00	; 0
    2702:	00 e0       	ldi	r16, 0x00	; 0
    2704:	10 e0       	ldi	r17, 0x00	; 0
    2706:	20 e0       	ldi	r18, 0x00	; 0
    2708:	30 e0       	ldi	r19, 0x00	; 0
    270a:	ee 24       	eor	r14, r14
    270c:	ff 24       	eor	r15, r15
    270e:	6f 01       	movw	r12, r30
    2710:	0e 94 de 23 	call	0x47bc	; 0x47bc <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    2714:	ef 81       	ldd	r30, Y+7	; 0x07
    2716:	f8 85       	ldd	r31, Y+8	; 0x08
    2718:	11 86       	std	Z+9, r1	; 0x09
    271a:	10 86       	std	Z+8, r1	; 0x08

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    271c:	8f 81       	ldd	r24, Y+7	; 0x07
    271e:	98 85       	ldd	r25, Y+8	; 0x08
    2720:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvBytesInBuffer>
    2724:	9c 83       	std	Y+4, r25	; 0x04
    2726:	8b 83       	std	Y+3, r24	; 0x03
    2728:	06 c0       	rjmp	.+12     	; 0x2736 <xStreamBufferReceive+0xf0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    272a:	8f 81       	ldd	r24, Y+7	; 0x07
    272c:	98 85       	ldd	r25, Y+8	; 0x08
    272e:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvBytesInBuffer>
    2732:	9c 83       	std	Y+4, r25	; 0x04
    2734:	8b 83       	std	Y+3, r24	; 0x03
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    2736:	2b 81       	ldd	r18, Y+3	; 0x03
    2738:	3c 81       	ldd	r19, Y+4	; 0x04
    273a:	89 81       	ldd	r24, Y+1	; 0x01
    273c:	9a 81       	ldd	r25, Y+2	; 0x02
    273e:	82 17       	cp	r24, r18
    2740:	93 07       	cpc	r25, r19
    2742:	70 f5       	brcc	.+92     	; 0x27a0 <xStreamBufferReceive+0x15a>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    2744:	8f 81       	ldd	r24, Y+7	; 0x07
    2746:	98 85       	ldd	r25, Y+8	; 0x08
    2748:	2b 85       	ldd	r18, Y+11	; 0x0b
    274a:	3c 85       	ldd	r19, Y+12	; 0x0c
    274c:	4d 85       	ldd	r20, Y+13	; 0x0d
    274e:	5e 85       	ldd	r21, Y+14	; 0x0e
    2750:	eb 81       	ldd	r30, Y+3	; 0x03
    2752:	fc 81       	ldd	r31, Y+4	; 0x04
    2754:	b9 01       	movw	r22, r18
    2756:	9f 01       	movw	r18, r30
    2758:	0e 94 a2 14 	call	0x2944	; 0x2944 <prvReadMessageFromBuffer>
    275c:	9e 83       	std	Y+6, r25	; 0x06
    275e:	8d 83       	std	Y+5, r24	; 0x05

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    2760:	8d 81       	ldd	r24, Y+5	; 0x05
    2762:	9e 81       	ldd	r25, Y+6	; 0x06
    2764:	00 97       	sbiw	r24, 0x00	; 0
    2766:	e1 f0       	breq	.+56     	; 0x27a0 <xStreamBufferReceive+0x15a>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
    2768:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
    276c:	e9 85       	ldd	r30, Y+9	; 0x09
    276e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2770:	82 85       	ldd	r24, Z+10	; 0x0a
    2772:	93 85       	ldd	r25, Z+11	; 0x0b
    2774:	00 97       	sbiw	r24, 0x00	; 0
    2776:	91 f0       	breq	.+36     	; 0x279c <xStreamBufferReceive+0x156>
    2778:	e9 85       	ldd	r30, Y+9	; 0x09
    277a:	fa 85       	ldd	r31, Y+10	; 0x0a
    277c:	82 85       	ldd	r24, Z+10	; 0x0a
    277e:	93 85       	ldd	r25, Z+11	; 0x0b
    2780:	60 e0       	ldi	r22, 0x00	; 0
    2782:	20 e0       	ldi	r18, 0x00	; 0
    2784:	30 e0       	ldi	r19, 0x00	; 0
    2786:	40 e0       	ldi	r20, 0x00	; 0
    2788:	50 e0       	ldi	r21, 0x00	; 0
    278a:	00 e0       	ldi	r16, 0x00	; 0
    278c:	ee 24       	eor	r14, r14
    278e:	ff 24       	eor	r15, r15
    2790:	0e 94 d5 24 	call	0x49aa	; 0x49aa <xTaskGenericNotify>
    2794:	e9 85       	ldd	r30, Y+9	; 0x09
    2796:	fa 85       	ldd	r31, Y+10	; 0x0a
    2798:	13 86       	std	Z+11, r1	; 0x0b
    279a:	12 86       	std	Z+10, r1	; 0x0a
    279c:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
    27a0:	8d 81       	ldd	r24, Y+5	; 0x05
    27a2:	9e 81       	ldd	r25, Y+6	; 0x06
}
    27a4:	60 96       	adiw	r28, 0x10	; 16
    27a6:	0f b6       	in	r0, 0x3f	; 63
    27a8:	f8 94       	cli
    27aa:	de bf       	out	0x3e, r29	; 62
    27ac:	0f be       	out	0x3f, r0	; 63
    27ae:	cd bf       	out	0x3d, r28	; 61
    27b0:	cf 91       	pop	r28
    27b2:	df 91       	pop	r29
    27b4:	1f 91       	pop	r17
    27b6:	0f 91       	pop	r16
    27b8:	ff 90       	pop	r15
    27ba:	ef 90       	pop	r14
    27bc:	df 90       	pop	r13
    27be:	cf 90       	pop	r12
    27c0:	08 95       	ret

000027c2 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    27c2:	df 93       	push	r29
    27c4:	cf 93       	push	r28
    27c6:	cd b7       	in	r28, 0x3d	; 61
    27c8:	de b7       	in	r29, 0x3e	; 62
    27ca:	2a 97       	sbiw	r28, 0x0a	; 10
    27cc:	0f b6       	in	r0, 0x3f	; 63
    27ce:	f8 94       	cli
    27d0:	de bf       	out	0x3e, r29	; 62
    27d2:	0f be       	out	0x3f, r0	; 63
    27d4:	cd bf       	out	0x3d, r28	; 61
    27d6:	9a 87       	std	Y+10, r25	; 0x0a
    27d8:	89 87       	std	Y+9, r24	; 0x09
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    27da:	89 85       	ldd	r24, Y+9	; 0x09
    27dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    27de:	9e 83       	std	Y+6, r25	; 0x06
    27e0:	8d 83       	std	Y+5, r24	; 0x05
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    27e2:	ed 81       	ldd	r30, Y+5	; 0x05
    27e4:	fe 81       	ldd	r31, Y+6	; 0x06
    27e6:	86 85       	ldd	r24, Z+14	; 0x0e
    27e8:	88 2f       	mov	r24, r24
    27ea:	90 e0       	ldi	r25, 0x00	; 0
    27ec:	81 70       	andi	r24, 0x01	; 1
    27ee:	90 70       	andi	r25, 0x00	; 0
    27f0:	88 23       	and	r24, r24
    27f2:	19 f1       	breq	.+70     	; 0x283a <xStreamBufferNextMessageLengthBytes+0x78>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    27f4:	8d 81       	ldd	r24, Y+5	; 0x05
    27f6:	9e 81       	ldd	r25, Y+6	; 0x06
    27f8:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvBytesInBuffer>
    27fc:	9a 83       	std	Y+2, r25	; 0x02
    27fe:	89 83       	std	Y+1, r24	; 0x01

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    2800:	89 81       	ldd	r24, Y+1	; 0x01
    2802:	9a 81       	ldd	r25, Y+2	; 0x02
    2804:	83 30       	cpi	r24, 0x03	; 3
    2806:	91 05       	cpc	r25, r1
    2808:	a8 f0       	brcs	.+42     	; 0x2834 <xStreamBufferNextMessageLengthBytes+0x72>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    280a:	9e 01       	movw	r18, r28
    280c:	29 5f       	subi	r18, 0xF9	; 249
    280e:	3f 4f       	sbci	r19, 0xFF	; 255
    2810:	ed 81       	ldd	r30, Y+5	; 0x05
    2812:	fe 81       	ldd	r31, Y+6	; 0x06
    2814:	01 90       	ld	r0, Z+
    2816:	f0 81       	ld	r31, Z
    2818:	e0 2d       	mov	r30, r0
    281a:	8d 81       	ldd	r24, Y+5	; 0x05
    281c:	9e 81       	ldd	r25, Y+6	; 0x06
    281e:	b9 01       	movw	r22, r18
    2820:	42 e0       	ldi	r20, 0x02	; 2
    2822:	50 e0       	ldi	r21, 0x00	; 0
    2824:	9f 01       	movw	r18, r30
    2826:	0e 94 94 16 	call	0x2d28	; 0x2d28 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    282a:	8f 81       	ldd	r24, Y+7	; 0x07
    282c:	98 85       	ldd	r25, Y+8	; 0x08
    282e:	9c 83       	std	Y+4, r25	; 0x04
    2830:	8b 83       	std	Y+3, r24	; 0x03
    2832:	05 c0       	rjmp	.+10     	; 0x283e <xStreamBufferNextMessageLengthBytes+0x7c>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
    2834:	1c 82       	std	Y+4, r1	; 0x04
    2836:	1b 82       	std	Y+3, r1	; 0x03
    2838:	02 c0       	rjmp	.+4      	; 0x283e <xStreamBufferNextMessageLengthBytes+0x7c>
        }
    }
    else
    {
        xReturn = 0;
    283a:	1c 82       	std	Y+4, r1	; 0x04
    283c:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    283e:	8b 81       	ldd	r24, Y+3	; 0x03
    2840:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2842:	2a 96       	adiw	r28, 0x0a	; 10
    2844:	0f b6       	in	r0, 0x3f	; 63
    2846:	f8 94       	cli
    2848:	de bf       	out	0x3e, r29	; 62
    284a:	0f be       	out	0x3f, r0	; 63
    284c:	cd bf       	out	0x3d, r28	; 61
    284e:	cf 91       	pop	r28
    2850:	df 91       	pop	r29
    2852:	08 95       	ret

00002854 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    2854:	cf 92       	push	r12
    2856:	df 92       	push	r13
    2858:	ef 92       	push	r14
    285a:	ff 92       	push	r15
    285c:	0f 93       	push	r16
    285e:	df 93       	push	r29
    2860:	cf 93       	push	r28
    2862:	cd b7       	in	r28, 0x3d	; 61
    2864:	de b7       	in	r29, 0x3e	; 62
    2866:	61 97       	sbiw	r28, 0x11	; 17
    2868:	0f b6       	in	r0, 0x3f	; 63
    286a:	f8 94       	cli
    286c:	de bf       	out	0x3e, r29	; 62
    286e:	0f be       	out	0x3f, r0	; 63
    2870:	cd bf       	out	0x3d, r28	; 61
    2872:	9b 87       	std	Y+11, r25	; 0x0b
    2874:	8a 87       	std	Y+10, r24	; 0x0a
    2876:	7d 87       	std	Y+13, r23	; 0x0d
    2878:	6c 87       	std	Y+12, r22	; 0x0c
    287a:	5f 87       	std	Y+15, r21	; 0x0f
    287c:	4e 87       	std	Y+14, r20	; 0x0e
    287e:	39 8b       	std	Y+17, r19	; 0x11
    2880:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2882:	8a 85       	ldd	r24, Y+10	; 0x0a
    2884:	9b 85       	ldd	r25, Y+11	; 0x0b
    2886:	99 87       	std	Y+9, r25	; 0x09
    2888:	88 87       	std	Y+8, r24	; 0x08
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    288a:	1f 82       	std	Y+7, r1	; 0x07
    288c:	1e 82       	std	Y+6, r1	; 0x06
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    288e:	e8 85       	ldd	r30, Y+8	; 0x08
    2890:	f9 85       	ldd	r31, Y+9	; 0x09
    2892:	86 85       	ldd	r24, Z+14	; 0x0e
    2894:	88 2f       	mov	r24, r24
    2896:	90 e0       	ldi	r25, 0x00	; 0
    2898:	81 70       	andi	r24, 0x01	; 1
    289a:	90 70       	andi	r25, 0x00	; 0
    289c:	88 23       	and	r24, r24
    289e:	29 f0       	breq	.+10     	; 0x28aa <xStreamBufferReceiveFromISR+0x56>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    28a0:	82 e0       	ldi	r24, 0x02	; 2
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    28a4:	9b 83       	std	Y+3, r25	; 0x03
    28a6:	8a 83       	std	Y+2, r24	; 0x02
    28a8:	02 c0       	rjmp	.+4      	; 0x28ae <xStreamBufferReceiveFromISR+0x5a>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    28aa:	1b 82       	std	Y+3, r1	; 0x03
    28ac:	1a 82       	std	Y+2, r1	; 0x02
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    28ae:	88 85       	ldd	r24, Y+8	; 0x08
    28b0:	99 85       	ldd	r25, Y+9	; 0x09
    28b2:	0e 94 19 17 	call	0x2e32	; 0x2e32 <prvBytesInBuffer>
    28b6:	9d 83       	std	Y+5, r25	; 0x05
    28b8:	8c 83       	std	Y+4, r24	; 0x04
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    28ba:	2c 81       	ldd	r18, Y+4	; 0x04
    28bc:	3d 81       	ldd	r19, Y+5	; 0x05
    28be:	8a 81       	ldd	r24, Y+2	; 0x02
    28c0:	9b 81       	ldd	r25, Y+3	; 0x03
    28c2:	82 17       	cp	r24, r18
    28c4:	93 07       	cpc	r25, r19
    28c6:	70 f5       	brcc	.+92     	; 0x2924 <xStreamBufferReceiveFromISR+0xd0>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    28c8:	88 85       	ldd	r24, Y+8	; 0x08
    28ca:	99 85       	ldd	r25, Y+9	; 0x09
    28cc:	2c 85       	ldd	r18, Y+12	; 0x0c
    28ce:	3d 85       	ldd	r19, Y+13	; 0x0d
    28d0:	4e 85       	ldd	r20, Y+14	; 0x0e
    28d2:	5f 85       	ldd	r21, Y+15	; 0x0f
    28d4:	ec 81       	ldd	r30, Y+4	; 0x04
    28d6:	fd 81       	ldd	r31, Y+5	; 0x05
    28d8:	b9 01       	movw	r22, r18
    28da:	9f 01       	movw	r18, r30
    28dc:	0e 94 a2 14 	call	0x2944	; 0x2944 <prvReadMessageFromBuffer>
    28e0:	9f 83       	std	Y+7, r25	; 0x07
    28e2:	8e 83       	std	Y+6, r24	; 0x06

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    28e4:	8e 81       	ldd	r24, Y+6	; 0x06
    28e6:	9f 81       	ldd	r25, Y+7	; 0x07
    28e8:	00 97       	sbiw	r24, 0x00	; 0
    28ea:	e1 f0       	breq	.+56     	; 0x2924 <xStreamBufferReceiveFromISR+0xd0>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    28ec:	19 82       	std	Y+1, r1	; 0x01
    28ee:	e8 85       	ldd	r30, Y+8	; 0x08
    28f0:	f9 85       	ldd	r31, Y+9	; 0x09
    28f2:	82 85       	ldd	r24, Z+10	; 0x0a
    28f4:	93 85       	ldd	r25, Z+11	; 0x0b
    28f6:	00 97       	sbiw	r24, 0x00	; 0
    28f8:	a9 f0       	breq	.+42     	; 0x2924 <xStreamBufferReceiveFromISR+0xd0>
    28fa:	e8 85       	ldd	r30, Y+8	; 0x08
    28fc:	f9 85       	ldd	r31, Y+9	; 0x09
    28fe:	82 85       	ldd	r24, Z+10	; 0x0a
    2900:	93 85       	ldd	r25, Z+11	; 0x0b
    2902:	e8 89       	ldd	r30, Y+16	; 0x10
    2904:	f9 89       	ldd	r31, Y+17	; 0x11
    2906:	60 e0       	ldi	r22, 0x00	; 0
    2908:	20 e0       	ldi	r18, 0x00	; 0
    290a:	30 e0       	ldi	r19, 0x00	; 0
    290c:	40 e0       	ldi	r20, 0x00	; 0
    290e:	50 e0       	ldi	r21, 0x00	; 0
    2910:	00 e0       	ldi	r16, 0x00	; 0
    2912:	ee 24       	eor	r14, r14
    2914:	ff 24       	eor	r15, r15
    2916:	6f 01       	movw	r12, r30
    2918:	0e 94 93 26 	call	0x4d26	; 0x4d26 <xTaskGenericNotifyFromISR>
    291c:	e8 85       	ldd	r30, Y+8	; 0x08
    291e:	f9 85       	ldd	r31, Y+9	; 0x09
    2920:	13 86       	std	Z+11, r1	; 0x0b
    2922:	12 86       	std	Z+10, r1	; 0x0a
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
    2924:	8e 81       	ldd	r24, Y+6	; 0x06
    2926:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2928:	61 96       	adiw	r28, 0x11	; 17
    292a:	0f b6       	in	r0, 0x3f	; 63
    292c:	f8 94       	cli
    292e:	de bf       	out	0x3e, r29	; 62
    2930:	0f be       	out	0x3f, r0	; 63
    2932:	cd bf       	out	0x3d, r28	; 61
    2934:	cf 91       	pop	r28
    2936:	df 91       	pop	r29
    2938:	0f 91       	pop	r16
    293a:	ff 90       	pop	r15
    293c:	ef 90       	pop	r14
    293e:	df 90       	pop	r13
    2940:	cf 90       	pop	r12
    2942:	08 95       	ret

00002944 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    2944:	df 93       	push	r29
    2946:	cf 93       	push	r28
    2948:	cd b7       	in	r28, 0x3d	; 61
    294a:	de b7       	in	r29, 0x3e	; 62
    294c:	64 97       	sbiw	r28, 0x14	; 20
    294e:	0f b6       	in	r0, 0x3f	; 63
    2950:	f8 94       	cli
    2952:	de bf       	out	0x3e, r29	; 62
    2954:	0f be       	out	0x3f, r0	; 63
    2956:	cd bf       	out	0x3d, r28	; 61
    2958:	9a 87       	std	Y+10, r25	; 0x0a
    295a:	89 87       	std	Y+9, r24	; 0x09
    295c:	7c 87       	std	Y+12, r23	; 0x0c
    295e:	6b 87       	std	Y+11, r22	; 0x0b
    2960:	5e 87       	std	Y+14, r21	; 0x0e
    2962:	4d 87       	std	Y+13, r20	; 0x0d
    2964:	38 8b       	std	Y+16, r19	; 0x10
    2966:	2f 87       	std	Y+15, r18	; 0x0f
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    2968:	e9 85       	ldd	r30, Y+9	; 0x09
    296a:	fa 85       	ldd	r31, Y+10	; 0x0a
    296c:	80 81       	ld	r24, Z
    296e:	91 81       	ldd	r25, Z+1	; 0x01
    2970:	9a 83       	std	Y+2, r25	; 0x02
    2972:	89 83       	std	Y+1, r24	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2974:	e9 85       	ldd	r30, Y+9	; 0x09
    2976:	fa 85       	ldd	r31, Y+10	; 0x0a
    2978:	86 85       	ldd	r24, Z+14	; 0x0e
    297a:	88 2f       	mov	r24, r24
    297c:	90 e0       	ldi	r25, 0x00	; 0
    297e:	81 70       	andi	r24, 0x01	; 1
    2980:	90 70       	andi	r25, 0x00	; 0
    2982:	88 23       	and	r24, r24
    2984:	11 f1       	breq	.+68     	; 0x29ca <prvReadMessageFromBuffer+0x86>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    2986:	9e 01       	movw	r18, r28
    2988:	29 5f       	subi	r18, 0xF9	; 249
    298a:	3f 4f       	sbci	r19, 0xFF	; 255
    298c:	89 85       	ldd	r24, Y+9	; 0x09
    298e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2990:	e9 81       	ldd	r30, Y+1	; 0x01
    2992:	fa 81       	ldd	r31, Y+2	; 0x02
    2994:	b9 01       	movw	r22, r18
    2996:	42 e0       	ldi	r20, 0x02	; 2
    2998:	50 e0       	ldi	r21, 0x00	; 0
    299a:	9f 01       	movw	r18, r30
    299c:	0e 94 94 16 	call	0x2d28	; 0x2d28 <prvReadBytesFromBuffer>
    29a0:	9a 83       	std	Y+2, r25	; 0x02
    29a2:	89 83       	std	Y+1, r24	; 0x01
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    29a4:	8f 81       	ldd	r24, Y+7	; 0x07
    29a6:	98 85       	ldd	r25, Y+8	; 0x08
    29a8:	9c 83       	std	Y+4, r25	; 0x04
    29aa:	8b 83       	std	Y+3, r24	; 0x03

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    29ac:	8f 85       	ldd	r24, Y+15	; 0x0f
    29ae:	98 89       	ldd	r25, Y+16	; 0x10
    29b0:	02 97       	sbiw	r24, 0x02	; 2
    29b2:	98 8b       	std	Y+16, r25	; 0x10
    29b4:	8f 87       	std	Y+15, r24	; 0x0f

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    29b6:	2b 81       	ldd	r18, Y+3	; 0x03
    29b8:	3c 81       	ldd	r19, Y+4	; 0x04
    29ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    29bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    29be:	82 17       	cp	r24, r18
    29c0:	93 07       	cpc	r25, r19
    29c2:	38 f4       	brcc	.+14     	; 0x29d2 <prvReadMessageFromBuffer+0x8e>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
    29c4:	1c 82       	std	Y+4, r1	; 0x04
    29c6:	1b 82       	std	Y+3, r1	; 0x03
    29c8:	04 c0       	rjmp	.+8      	; 0x29d2 <prvReadMessageFromBuffer+0x8e>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    29ca:	8d 85       	ldd	r24, Y+13	; 0x0d
    29cc:	9e 85       	ldd	r25, Y+14	; 0x0e
    29ce:	9c 83       	std	Y+4, r25	; 0x04
    29d0:	8b 83       	std	Y+3, r24	; 0x03
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    29d2:	2b 81       	ldd	r18, Y+3	; 0x03
    29d4:	3c 81       	ldd	r19, Y+4	; 0x04
    29d6:	3c 8b       	std	Y+20, r19	; 0x14
    29d8:	2b 8b       	std	Y+19, r18	; 0x13
    29da:	8f 85       	ldd	r24, Y+15	; 0x0f
    29dc:	98 89       	ldd	r25, Y+16	; 0x10
    29de:	9a 8b       	std	Y+18, r25	; 0x12
    29e0:	89 8b       	std	Y+17, r24	; 0x11
    29e2:	29 89       	ldd	r18, Y+17	; 0x11
    29e4:	3a 89       	ldd	r19, Y+18	; 0x12
    29e6:	8b 89       	ldd	r24, Y+19	; 0x13
    29e8:	9c 89       	ldd	r25, Y+20	; 0x14
    29ea:	82 17       	cp	r24, r18
    29ec:	93 07       	cpc	r25, r19
    29ee:	20 f4       	brcc	.+8      	; 0x29f8 <prvReadMessageFromBuffer+0xb4>
    29f0:	2b 89       	ldd	r18, Y+19	; 0x13
    29f2:	3c 89       	ldd	r19, Y+20	; 0x14
    29f4:	3a 8b       	std	Y+18, r19	; 0x12
    29f6:	29 8b       	std	Y+17, r18	; 0x11
    29f8:	89 89       	ldd	r24, Y+17	; 0x11
    29fa:	9a 89       	ldd	r25, Y+18	; 0x12
    29fc:	9e 83       	std	Y+6, r25	; 0x06
    29fe:	8d 83       	std	Y+5, r24	; 0x05

    if( xCount != ( size_t ) 0 )
    2a00:	8d 81       	ldd	r24, Y+5	; 0x05
    2a02:	9e 81       	ldd	r25, Y+6	; 0x06
    2a04:	00 97       	sbiw	r24, 0x00	; 0
    2a06:	89 f0       	breq	.+34     	; 0x2a2a <prvReadMessageFromBuffer+0xe6>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    2a08:	4b 85       	ldd	r20, Y+11	; 0x0b
    2a0a:	5c 85       	ldd	r21, Y+12	; 0x0c
    2a0c:	89 85       	ldd	r24, Y+9	; 0x09
    2a0e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a10:	2d 81       	ldd	r18, Y+5	; 0x05
    2a12:	3e 81       	ldd	r19, Y+6	; 0x06
    2a14:	e9 81       	ldd	r30, Y+1	; 0x01
    2a16:	fa 81       	ldd	r31, Y+2	; 0x02
    2a18:	ba 01       	movw	r22, r20
    2a1a:	a9 01       	movw	r20, r18
    2a1c:	9f 01       	movw	r18, r30
    2a1e:	0e 94 94 16 	call	0x2d28	; 0x2d28 <prvReadBytesFromBuffer>
    2a22:	e9 85       	ldd	r30, Y+9	; 0x09
    2a24:	fa 85       	ldd	r31, Y+10	; 0x0a
    2a26:	91 83       	std	Z+1, r25	; 0x01
    2a28:	80 83       	st	Z, r24
    }

    return xCount;
    2a2a:	8d 81       	ldd	r24, Y+5	; 0x05
    2a2c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2a2e:	64 96       	adiw	r28, 0x14	; 20
    2a30:	0f b6       	in	r0, 0x3f	; 63
    2a32:	f8 94       	cli
    2a34:	de bf       	out	0x3e, r29	; 62
    2a36:	0f be       	out	0x3f, r0	; 63
    2a38:	cd bf       	out	0x3d, r28	; 61
    2a3a:	cf 91       	pop	r28
    2a3c:	df 91       	pop	r29
    2a3e:	08 95       	ret

00002a40 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    2a40:	df 93       	push	r29
    2a42:	cf 93       	push	r28
    2a44:	cd b7       	in	r28, 0x3d	; 61
    2a46:	de b7       	in	r29, 0x3e	; 62
    2a48:	27 97       	sbiw	r28, 0x07	; 7
    2a4a:	0f b6       	in	r0, 0x3f	; 63
    2a4c:	f8 94       	cli
    2a4e:	de bf       	out	0x3e, r29	; 62
    2a50:	0f be       	out	0x3f, r0	; 63
    2a52:	cd bf       	out	0x3d, r28	; 61
    2a54:	9f 83       	std	Y+7, r25	; 0x07
    2a56:	8e 83       	std	Y+6, r24	; 0x06
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2a58:	8e 81       	ldd	r24, Y+6	; 0x06
    2a5a:	9f 81       	ldd	r25, Y+7	; 0x07
    2a5c:	9d 83       	std	Y+5, r25	; 0x05
    2a5e:	8c 83       	std	Y+4, r24	; 0x04
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    2a60:	ec 81       	ldd	r30, Y+4	; 0x04
    2a62:	fd 81       	ldd	r31, Y+5	; 0x05
    2a64:	80 81       	ld	r24, Z
    2a66:	91 81       	ldd	r25, Z+1	; 0x01
    2a68:	9a 83       	std	Y+2, r25	; 0x02
    2a6a:	89 83       	std	Y+1, r24	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    2a6c:	ec 81       	ldd	r30, Y+4	; 0x04
    2a6e:	fd 81       	ldd	r31, Y+5	; 0x05
    2a70:	22 81       	ldd	r18, Z+2	; 0x02
    2a72:	33 81       	ldd	r19, Z+3	; 0x03
    2a74:	89 81       	ldd	r24, Y+1	; 0x01
    2a76:	9a 81       	ldd	r25, Y+2	; 0x02
    2a78:	28 17       	cp	r18, r24
    2a7a:	39 07       	cpc	r19, r25
    2a7c:	19 f4       	brne	.+6      	; 0x2a84 <xStreamBufferIsEmpty+0x44>
    {
        xReturn = pdTRUE;
    2a7e:	81 e0       	ldi	r24, 0x01	; 1
    2a80:	8b 83       	std	Y+3, r24	; 0x03
    2a82:	01 c0       	rjmp	.+2      	; 0x2a86 <xStreamBufferIsEmpty+0x46>
    }
    else
    {
        xReturn = pdFALSE;
    2a84:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2a86:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2a88:	27 96       	adiw	r28, 0x07	; 7
    2a8a:	0f b6       	in	r0, 0x3f	; 63
    2a8c:	f8 94       	cli
    2a8e:	de bf       	out	0x3e, r29	; 62
    2a90:	0f be       	out	0x3f, r0	; 63
    2a92:	cd bf       	out	0x3d, r28	; 61
    2a94:	cf 91       	pop	r28
    2a96:	df 91       	pop	r29
    2a98:	08 95       	ret

00002a9a <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    2a9a:	df 93       	push	r29
    2a9c:	cf 93       	push	r28
    2a9e:	cd b7       	in	r28, 0x3d	; 61
    2aa0:	de b7       	in	r29, 0x3e	; 62
    2aa2:	27 97       	sbiw	r28, 0x07	; 7
    2aa4:	0f b6       	in	r0, 0x3f	; 63
    2aa6:	f8 94       	cli
    2aa8:	de bf       	out	0x3e, r29	; 62
    2aaa:	0f be       	out	0x3f, r0	; 63
    2aac:	cd bf       	out	0x3d, r28	; 61
    2aae:	9f 83       	std	Y+7, r25	; 0x07
    2ab0:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2ab2:	8e 81       	ldd	r24, Y+6	; 0x06
    2ab4:	9f 81       	ldd	r25, Y+7	; 0x07
    2ab6:	9a 83       	std	Y+2, r25	; 0x02
    2ab8:	89 83       	std	Y+1, r24	; 0x01

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2aba:	e9 81       	ldd	r30, Y+1	; 0x01
    2abc:	fa 81       	ldd	r31, Y+2	; 0x02
    2abe:	86 85       	ldd	r24, Z+14	; 0x0e
    2ac0:	88 2f       	mov	r24, r24
    2ac2:	90 e0       	ldi	r25, 0x00	; 0
    2ac4:	81 70       	andi	r24, 0x01	; 1
    2ac6:	90 70       	andi	r25, 0x00	; 0
    2ac8:	88 23       	and	r24, r24
    2aca:	29 f0       	breq	.+10     	; 0x2ad6 <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2acc:	82 e0       	ldi	r24, 0x02	; 2
    2ace:	90 e0       	ldi	r25, 0x00	; 0
    2ad0:	9c 83       	std	Y+4, r25	; 0x04
    2ad2:	8b 83       	std	Y+3, r24	; 0x03
    2ad4:	02 c0       	rjmp	.+4      	; 0x2ada <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    2ad6:	1c 82       	std	Y+4, r1	; 0x04
    2ad8:	1b 82       	std	Y+3, r1	; 0x03
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    2ada:	8e 81       	ldd	r24, Y+6	; 0x06
    2adc:	9f 81       	ldd	r25, Y+7	; 0x07
    2ade:	0e 94 c1 10 	call	0x2182	; 0x2182 <xStreamBufferSpacesAvailable>
    2ae2:	9c 01       	movw	r18, r24
    2ae4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae8:	82 17       	cp	r24, r18
    2aea:	93 07       	cpc	r25, r19
    2aec:	18 f0       	brcs	.+6      	; 0x2af4 <xStreamBufferIsFull+0x5a>
    {
        xReturn = pdTRUE;
    2aee:	81 e0       	ldi	r24, 0x01	; 1
    2af0:	8d 83       	std	Y+5, r24	; 0x05
    2af2:	01 c0       	rjmp	.+2      	; 0x2af6 <xStreamBufferIsFull+0x5c>
    }
    else
    {
        xReturn = pdFALSE;
    2af4:	1d 82       	std	Y+5, r1	; 0x05
    }

    return xReturn;
    2af6:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2af8:	27 96       	adiw	r28, 0x07	; 7
    2afa:	0f b6       	in	r0, 0x3f	; 63
    2afc:	f8 94       	cli
    2afe:	de bf       	out	0x3e, r29	; 62
    2b00:	0f be       	out	0x3f, r0	; 63
    2b02:	cd bf       	out	0x3d, r28	; 61
    2b04:	cf 91       	pop	r28
    2b06:	df 91       	pop	r29
    2b08:	08 95       	ret

00002b0a <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    2b0a:	cf 92       	push	r12
    2b0c:	df 92       	push	r13
    2b0e:	ef 92       	push	r14
    2b10:	ff 92       	push	r15
    2b12:	0f 93       	push	r16
    2b14:	df 93       	push	r29
    2b16:	cf 93       	push	r28
    2b18:	cd b7       	in	r28, 0x3d	; 61
    2b1a:	de b7       	in	r29, 0x3e	; 62
    2b1c:	28 97       	sbiw	r28, 0x08	; 8
    2b1e:	0f b6       	in	r0, 0x3f	; 63
    2b20:	f8 94       	cli
    2b22:	de bf       	out	0x3e, r29	; 62
    2b24:	0f be       	out	0x3f, r0	; 63
    2b26:	cd bf       	out	0x3d, r28	; 61
    2b28:	9e 83       	std	Y+6, r25	; 0x06
    2b2a:	8d 83       	std	Y+5, r24	; 0x05
    2b2c:	78 87       	std	Y+8, r23	; 0x08
    2b2e:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2b30:	8d 81       	ldd	r24, Y+5	; 0x05
    2b32:	9e 81       	ldd	r25, Y+6	; 0x06
    2b34:	9c 83       	std	Y+4, r25	; 0x04
    2b36:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2b38:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    2b3a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b3c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b3e:	80 85       	ldd	r24, Z+8	; 0x08
    2b40:	91 85       	ldd	r25, Z+9	; 0x09
    2b42:	00 97       	sbiw	r24, 0x00	; 0
    2b44:	c1 f0       	breq	.+48     	; 0x2b76 <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    2b46:	eb 81       	ldd	r30, Y+3	; 0x03
    2b48:	fc 81       	ldd	r31, Y+4	; 0x04
    2b4a:	80 85       	ldd	r24, Z+8	; 0x08
    2b4c:	91 85       	ldd	r25, Z+9	; 0x09
    2b4e:	ef 81       	ldd	r30, Y+7	; 0x07
    2b50:	f8 85       	ldd	r31, Y+8	; 0x08
    2b52:	60 e0       	ldi	r22, 0x00	; 0
    2b54:	20 e0       	ldi	r18, 0x00	; 0
    2b56:	30 e0       	ldi	r19, 0x00	; 0
    2b58:	40 e0       	ldi	r20, 0x00	; 0
    2b5a:	50 e0       	ldi	r21, 0x00	; 0
    2b5c:	00 e0       	ldi	r16, 0x00	; 0
    2b5e:	ee 24       	eor	r14, r14
    2b60:	ff 24       	eor	r15, r15
    2b62:	6f 01       	movw	r12, r30
    2b64:	0e 94 93 26 	call	0x4d26	; 0x4d26 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    2b68:	eb 81       	ldd	r30, Y+3	; 0x03
    2b6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b6c:	11 86       	std	Z+9, r1	; 0x09
    2b6e:	10 86       	std	Z+8, r1	; 0x08
            xReturn = pdTRUE;
    2b70:	81 e0       	ldi	r24, 0x01	; 1
    2b72:	8a 83       	std	Y+2, r24	; 0x02
    2b74:	01 c0       	rjmp	.+2      	; 0x2b78 <xStreamBufferSendCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    2b76:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2b78:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2b7a:	28 96       	adiw	r28, 0x08	; 8
    2b7c:	0f b6       	in	r0, 0x3f	; 63
    2b7e:	f8 94       	cli
    2b80:	de bf       	out	0x3e, r29	; 62
    2b82:	0f be       	out	0x3f, r0	; 63
    2b84:	cd bf       	out	0x3d, r28	; 61
    2b86:	cf 91       	pop	r28
    2b88:	df 91       	pop	r29
    2b8a:	0f 91       	pop	r16
    2b8c:	ff 90       	pop	r15
    2b8e:	ef 90       	pop	r14
    2b90:	df 90       	pop	r13
    2b92:	cf 90       	pop	r12
    2b94:	08 95       	ret

00002b96 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    2b96:	cf 92       	push	r12
    2b98:	df 92       	push	r13
    2b9a:	ef 92       	push	r14
    2b9c:	ff 92       	push	r15
    2b9e:	0f 93       	push	r16
    2ba0:	df 93       	push	r29
    2ba2:	cf 93       	push	r28
    2ba4:	cd b7       	in	r28, 0x3d	; 61
    2ba6:	de b7       	in	r29, 0x3e	; 62
    2ba8:	28 97       	sbiw	r28, 0x08	; 8
    2baa:	0f b6       	in	r0, 0x3f	; 63
    2bac:	f8 94       	cli
    2bae:	de bf       	out	0x3e, r29	; 62
    2bb0:	0f be       	out	0x3f, r0	; 63
    2bb2:	cd bf       	out	0x3d, r28	; 61
    2bb4:	9e 83       	std	Y+6, r25	; 0x06
    2bb6:	8d 83       	std	Y+5, r24	; 0x05
    2bb8:	78 87       	std	Y+8, r23	; 0x08
    2bba:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2bbc:	8d 81       	ldd	r24, Y+5	; 0x05
    2bbe:	9e 81       	ldd	r25, Y+6	; 0x06
    2bc0:	9c 83       	std	Y+4, r25	; 0x04
    2bc2:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2bc4:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    2bc6:	eb 81       	ldd	r30, Y+3	; 0x03
    2bc8:	fc 81       	ldd	r31, Y+4	; 0x04
    2bca:	82 85       	ldd	r24, Z+10	; 0x0a
    2bcc:	93 85       	ldd	r25, Z+11	; 0x0b
    2bce:	00 97       	sbiw	r24, 0x00	; 0
    2bd0:	c1 f0       	breq	.+48     	; 0x2c02 <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    2bd2:	eb 81       	ldd	r30, Y+3	; 0x03
    2bd4:	fc 81       	ldd	r31, Y+4	; 0x04
    2bd6:	82 85       	ldd	r24, Z+10	; 0x0a
    2bd8:	93 85       	ldd	r25, Z+11	; 0x0b
    2bda:	ef 81       	ldd	r30, Y+7	; 0x07
    2bdc:	f8 85       	ldd	r31, Y+8	; 0x08
    2bde:	60 e0       	ldi	r22, 0x00	; 0
    2be0:	20 e0       	ldi	r18, 0x00	; 0
    2be2:	30 e0       	ldi	r19, 0x00	; 0
    2be4:	40 e0       	ldi	r20, 0x00	; 0
    2be6:	50 e0       	ldi	r21, 0x00	; 0
    2be8:	00 e0       	ldi	r16, 0x00	; 0
    2bea:	ee 24       	eor	r14, r14
    2bec:	ff 24       	eor	r15, r15
    2bee:	6f 01       	movw	r12, r30
    2bf0:	0e 94 93 26 	call	0x4d26	; 0x4d26 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    2bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    2bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    2bf8:	13 86       	std	Z+11, r1	; 0x0b
    2bfa:	12 86       	std	Z+10, r1	; 0x0a
            xReturn = pdTRUE;
    2bfc:	81 e0       	ldi	r24, 0x01	; 1
    2bfe:	8a 83       	std	Y+2, r24	; 0x02
    2c00:	01 c0       	rjmp	.+2      	; 0x2c04 <xStreamBufferReceiveCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    2c02:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2c04:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2c06:	28 96       	adiw	r28, 0x08	; 8
    2c08:	0f b6       	in	r0, 0x3f	; 63
    2c0a:	f8 94       	cli
    2c0c:	de bf       	out	0x3e, r29	; 62
    2c0e:	0f be       	out	0x3f, r0	; 63
    2c10:	cd bf       	out	0x3d, r28	; 61
    2c12:	cf 91       	pop	r28
    2c14:	df 91       	pop	r29
    2c16:	0f 91       	pop	r16
    2c18:	ff 90       	pop	r15
    2c1a:	ef 90       	pop	r14
    2c1c:	df 90       	pop	r13
    2c1e:	cf 90       	pop	r12
    2c20:	08 95       	ret

00002c22 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    2c22:	df 93       	push	r29
    2c24:	cf 93       	push	r28
    2c26:	cd b7       	in	r28, 0x3d	; 61
    2c28:	de b7       	in	r29, 0x3e	; 62
    2c2a:	2e 97       	sbiw	r28, 0x0e	; 14
    2c2c:	0f b6       	in	r0, 0x3f	; 63
    2c2e:	f8 94       	cli
    2c30:	de bf       	out	0x3e, r29	; 62
    2c32:	0f be       	out	0x3f, r0	; 63
    2c34:	cd bf       	out	0x3d, r28	; 61
    2c36:	9c 83       	std	Y+4, r25	; 0x04
    2c38:	8b 83       	std	Y+3, r24	; 0x03
    2c3a:	7e 83       	std	Y+6, r23	; 0x06
    2c3c:	6d 83       	std	Y+5, r22	; 0x05
    2c3e:	58 87       	std	Y+8, r21	; 0x08
    2c40:	4f 83       	std	Y+7, r20	; 0x07
    2c42:	3a 87       	std	Y+10, r19	; 0x0a
    2c44:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    2c46:	eb 81       	ldd	r30, Y+3	; 0x03
    2c48:	fc 81       	ldd	r31, Y+4	; 0x04
    2c4a:	24 81       	ldd	r18, Z+4	; 0x04
    2c4c:	35 81       	ldd	r19, Z+5	; 0x05
    2c4e:	89 85       	ldd	r24, Y+9	; 0x09
    2c50:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c52:	a9 01       	movw	r20, r18
    2c54:	48 1b       	sub	r20, r24
    2c56:	59 0b       	sbc	r21, r25
    2c58:	ca 01       	movw	r24, r20
    2c5a:	2f 81       	ldd	r18, Y+7	; 0x07
    2c5c:	38 85       	ldd	r19, Y+8	; 0x08
    2c5e:	3e 87       	std	Y+14, r19	; 0x0e
    2c60:	2d 87       	std	Y+13, r18	; 0x0d
    2c62:	9c 87       	std	Y+12, r25	; 0x0c
    2c64:	8b 87       	std	Y+11, r24	; 0x0b
    2c66:	4b 85       	ldd	r20, Y+11	; 0x0b
    2c68:	5c 85       	ldd	r21, Y+12	; 0x0c
    2c6a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c6c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c6e:	84 17       	cp	r24, r20
    2c70:	95 07       	cpc	r25, r21
    2c72:	20 f4       	brcc	.+8      	; 0x2c7c <prvWriteBytesToBuffer+0x5a>
    2c74:	2d 85       	ldd	r18, Y+13	; 0x0d
    2c76:	3e 85       	ldd	r19, Y+14	; 0x0e
    2c78:	3c 87       	std	Y+12, r19	; 0x0c
    2c7a:	2b 87       	std	Y+11, r18	; 0x0b
    2c7c:	4b 85       	ldd	r20, Y+11	; 0x0b
    2c7e:	5c 85       	ldd	r21, Y+12	; 0x0c
    2c80:	5a 83       	std	Y+2, r21	; 0x02
    2c82:	49 83       	std	Y+1, r20	; 0x01

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2c84:	eb 81       	ldd	r30, Y+3	; 0x03
    2c86:	fc 81       	ldd	r31, Y+4	; 0x04
    2c88:	24 85       	ldd	r18, Z+12	; 0x0c
    2c8a:	35 85       	ldd	r19, Z+13	; 0x0d
    2c8c:	89 85       	ldd	r24, Y+9	; 0x09
    2c8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c90:	82 0f       	add	r24, r18
    2c92:	93 1f       	adc	r25, r19
    2c94:	2d 81       	ldd	r18, Y+5	; 0x05
    2c96:	3e 81       	ldd	r19, Y+6	; 0x06
    2c98:	49 81       	ldd	r20, Y+1	; 0x01
    2c9a:	5a 81       	ldd	r21, Y+2	; 0x02
    2c9c:	b9 01       	movw	r22, r18
    2c9e:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    2ca2:	2f 81       	ldd	r18, Y+7	; 0x07
    2ca4:	38 85       	ldd	r19, Y+8	; 0x08
    2ca6:	89 81       	ldd	r24, Y+1	; 0x01
    2ca8:	9a 81       	ldd	r25, Y+2	; 0x02
    2caa:	82 17       	cp	r24, r18
    2cac:	93 07       	cpc	r25, r19
    2cae:	b0 f4       	brcc	.+44     	; 0x2cdc <prvWriteBytesToBuffer+0xba>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2cb0:	eb 81       	ldd	r30, Y+3	; 0x03
    2cb2:	fc 81       	ldd	r31, Y+4	; 0x04
    2cb4:	64 85       	ldd	r22, Z+12	; 0x0c
    2cb6:	75 85       	ldd	r23, Z+13	; 0x0d
    2cb8:	2d 81       	ldd	r18, Y+5	; 0x05
    2cba:	3e 81       	ldd	r19, Y+6	; 0x06
    2cbc:	89 81       	ldd	r24, Y+1	; 0x01
    2cbe:	9a 81       	ldd	r25, Y+2	; 0x02
    2cc0:	a9 01       	movw	r20, r18
    2cc2:	48 0f       	add	r20, r24
    2cc4:	59 1f       	adc	r21, r25
    2cc6:	2f 81       	ldd	r18, Y+7	; 0x07
    2cc8:	38 85       	ldd	r19, Y+8	; 0x08
    2cca:	89 81       	ldd	r24, Y+1	; 0x01
    2ccc:	9a 81       	ldd	r25, Y+2	; 0x02
    2cce:	28 1b       	sub	r18, r24
    2cd0:	39 0b       	sbc	r19, r25
    2cd2:	cb 01       	movw	r24, r22
    2cd4:	ba 01       	movw	r22, r20
    2cd6:	a9 01       	movw	r20, r18
    2cd8:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    2cdc:	29 85       	ldd	r18, Y+9	; 0x09
    2cde:	3a 85       	ldd	r19, Y+10	; 0x0a
    2ce0:	8f 81       	ldd	r24, Y+7	; 0x07
    2ce2:	98 85       	ldd	r25, Y+8	; 0x08
    2ce4:	82 0f       	add	r24, r18
    2ce6:	93 1f       	adc	r25, r19
    2ce8:	9a 87       	std	Y+10, r25	; 0x0a
    2cea:	89 87       	std	Y+9, r24	; 0x09

    if( xHead >= pxStreamBuffer->xLength )
    2cec:	eb 81       	ldd	r30, Y+3	; 0x03
    2cee:	fc 81       	ldd	r31, Y+4	; 0x04
    2cf0:	24 81       	ldd	r18, Z+4	; 0x04
    2cf2:	35 81       	ldd	r19, Z+5	; 0x05
    2cf4:	89 85       	ldd	r24, Y+9	; 0x09
    2cf6:	9a 85       	ldd	r25, Y+10	; 0x0a
    2cf8:	82 17       	cp	r24, r18
    2cfa:	93 07       	cpc	r25, r19
    2cfc:	50 f0       	brcs	.+20     	; 0x2d12 <prvWriteBytesToBuffer+0xf0>
    {
        xHead -= pxStreamBuffer->xLength;
    2cfe:	eb 81       	ldd	r30, Y+3	; 0x03
    2d00:	fc 81       	ldd	r31, Y+4	; 0x04
    2d02:	24 81       	ldd	r18, Z+4	; 0x04
    2d04:	35 81       	ldd	r19, Z+5	; 0x05
    2d06:	89 85       	ldd	r24, Y+9	; 0x09
    2d08:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d0a:	82 1b       	sub	r24, r18
    2d0c:	93 0b       	sbc	r25, r19
    2d0e:	9a 87       	std	Y+10, r25	; 0x0a
    2d10:	89 87       	std	Y+9, r24	; 0x09
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
    2d12:	89 85       	ldd	r24, Y+9	; 0x09
    2d14:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2d16:	2e 96       	adiw	r28, 0x0e	; 14
    2d18:	0f b6       	in	r0, 0x3f	; 63
    2d1a:	f8 94       	cli
    2d1c:	de bf       	out	0x3e, r29	; 62
    2d1e:	0f be       	out	0x3f, r0	; 63
    2d20:	cd bf       	out	0x3d, r28	; 61
    2d22:	cf 91       	pop	r28
    2d24:	df 91       	pop	r29
    2d26:	08 95       	ret

00002d28 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    2d28:	df 93       	push	r29
    2d2a:	cf 93       	push	r28
    2d2c:	cd b7       	in	r28, 0x3d	; 61
    2d2e:	de b7       	in	r29, 0x3e	; 62
    2d30:	2e 97       	sbiw	r28, 0x0e	; 14
    2d32:	0f b6       	in	r0, 0x3f	; 63
    2d34:	f8 94       	cli
    2d36:	de bf       	out	0x3e, r29	; 62
    2d38:	0f be       	out	0x3f, r0	; 63
    2d3a:	cd bf       	out	0x3d, r28	; 61
    2d3c:	9c 83       	std	Y+4, r25	; 0x04
    2d3e:	8b 83       	std	Y+3, r24	; 0x03
    2d40:	7e 83       	std	Y+6, r23	; 0x06
    2d42:	6d 83       	std	Y+5, r22	; 0x05
    2d44:	58 87       	std	Y+8, r21	; 0x08
    2d46:	4f 83       	std	Y+7, r20	; 0x07
    2d48:	3a 87       	std	Y+10, r19	; 0x0a
    2d4a:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    2d4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2d4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2d50:	24 81       	ldd	r18, Z+4	; 0x04
    2d52:	35 81       	ldd	r19, Z+5	; 0x05
    2d54:	89 85       	ldd	r24, Y+9	; 0x09
    2d56:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d58:	a9 01       	movw	r20, r18
    2d5a:	48 1b       	sub	r20, r24
    2d5c:	59 0b       	sbc	r21, r25
    2d5e:	ca 01       	movw	r24, r20
    2d60:	2f 81       	ldd	r18, Y+7	; 0x07
    2d62:	38 85       	ldd	r19, Y+8	; 0x08
    2d64:	3e 87       	std	Y+14, r19	; 0x0e
    2d66:	2d 87       	std	Y+13, r18	; 0x0d
    2d68:	9c 87       	std	Y+12, r25	; 0x0c
    2d6a:	8b 87       	std	Y+11, r24	; 0x0b
    2d6c:	4b 85       	ldd	r20, Y+11	; 0x0b
    2d6e:	5c 85       	ldd	r21, Y+12	; 0x0c
    2d70:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d72:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d74:	84 17       	cp	r24, r20
    2d76:	95 07       	cpc	r25, r21
    2d78:	20 f4       	brcc	.+8      	; 0x2d82 <prvReadBytesFromBuffer+0x5a>
    2d7a:	2d 85       	ldd	r18, Y+13	; 0x0d
    2d7c:	3e 85       	ldd	r19, Y+14	; 0x0e
    2d7e:	3c 87       	std	Y+12, r19	; 0x0c
    2d80:	2b 87       	std	Y+11, r18	; 0x0b
    2d82:	4b 85       	ldd	r20, Y+11	; 0x0b
    2d84:	5c 85       	ldd	r21, Y+12	; 0x0c
    2d86:	5a 83       	std	Y+2, r21	; 0x02
    2d88:	49 83       	std	Y+1, r20	; 0x01

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2d8a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d8c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d8e:	24 85       	ldd	r18, Z+12	; 0x0c
    2d90:	35 85       	ldd	r19, Z+13	; 0x0d
    2d92:	89 85       	ldd	r24, Y+9	; 0x09
    2d94:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d96:	a9 01       	movw	r20, r18
    2d98:	48 0f       	add	r20, r24
    2d9a:	59 1f       	adc	r21, r25
    2d9c:	8d 81       	ldd	r24, Y+5	; 0x05
    2d9e:	9e 81       	ldd	r25, Y+6	; 0x06
    2da0:	29 81       	ldd	r18, Y+1	; 0x01
    2da2:	3a 81       	ldd	r19, Y+2	; 0x02
    2da4:	ba 01       	movw	r22, r20
    2da6:	a9 01       	movw	r20, r18
    2da8:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    2dac:	2f 81       	ldd	r18, Y+7	; 0x07
    2dae:	38 85       	ldd	r19, Y+8	; 0x08
    2db0:	89 81       	ldd	r24, Y+1	; 0x01
    2db2:	9a 81       	ldd	r25, Y+2	; 0x02
    2db4:	82 17       	cp	r24, r18
    2db6:	93 07       	cpc	r25, r19
    2db8:	b0 f4       	brcc	.+44     	; 0x2de6 <prvReadBytesFromBuffer+0xbe>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2dba:	2d 81       	ldd	r18, Y+5	; 0x05
    2dbc:	3e 81       	ldd	r19, Y+6	; 0x06
    2dbe:	89 81       	ldd	r24, Y+1	; 0x01
    2dc0:	9a 81       	ldd	r25, Y+2	; 0x02
    2dc2:	b9 01       	movw	r22, r18
    2dc4:	68 0f       	add	r22, r24
    2dc6:	79 1f       	adc	r23, r25
    2dc8:	eb 81       	ldd	r30, Y+3	; 0x03
    2dca:	fc 81       	ldd	r31, Y+4	; 0x04
    2dcc:	44 85       	ldd	r20, Z+12	; 0x0c
    2dce:	55 85       	ldd	r21, Z+13	; 0x0d
    2dd0:	2f 81       	ldd	r18, Y+7	; 0x07
    2dd2:	38 85       	ldd	r19, Y+8	; 0x08
    2dd4:	89 81       	ldd	r24, Y+1	; 0x01
    2dd6:	9a 81       	ldd	r25, Y+2	; 0x02
    2dd8:	28 1b       	sub	r18, r24
    2dda:	39 0b       	sbc	r19, r25
    2ddc:	cb 01       	movw	r24, r22
    2dde:	ba 01       	movw	r22, r20
    2de0:	a9 01       	movw	r20, r18
    2de2:	0e 94 6c 2b 	call	0x56d8	; 0x56d8 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    2de6:	29 85       	ldd	r18, Y+9	; 0x09
    2de8:	3a 85       	ldd	r19, Y+10	; 0x0a
    2dea:	8f 81       	ldd	r24, Y+7	; 0x07
    2dec:	98 85       	ldd	r25, Y+8	; 0x08
    2dee:	82 0f       	add	r24, r18
    2df0:	93 1f       	adc	r25, r19
    2df2:	9a 87       	std	Y+10, r25	; 0x0a
    2df4:	89 87       	std	Y+9, r24	; 0x09

    if( xTail >= pxStreamBuffer->xLength )
    2df6:	eb 81       	ldd	r30, Y+3	; 0x03
    2df8:	fc 81       	ldd	r31, Y+4	; 0x04
    2dfa:	24 81       	ldd	r18, Z+4	; 0x04
    2dfc:	35 81       	ldd	r19, Z+5	; 0x05
    2dfe:	89 85       	ldd	r24, Y+9	; 0x09
    2e00:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e02:	82 17       	cp	r24, r18
    2e04:	93 07       	cpc	r25, r19
    2e06:	50 f0       	brcs	.+20     	; 0x2e1c <prvReadBytesFromBuffer+0xf4>
    {
        xTail -= pxStreamBuffer->xLength;
    2e08:	eb 81       	ldd	r30, Y+3	; 0x03
    2e0a:	fc 81       	ldd	r31, Y+4	; 0x04
    2e0c:	24 81       	ldd	r18, Z+4	; 0x04
    2e0e:	35 81       	ldd	r19, Z+5	; 0x05
    2e10:	89 85       	ldd	r24, Y+9	; 0x09
    2e12:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e14:	82 1b       	sub	r24, r18
    2e16:	93 0b       	sbc	r25, r19
    2e18:	9a 87       	std	Y+10, r25	; 0x0a
    2e1a:	89 87       	std	Y+9, r24	; 0x09
    }

    return xTail;
    2e1c:	89 85       	ldd	r24, Y+9	; 0x09
    2e1e:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2e20:	2e 96       	adiw	r28, 0x0e	; 14
    2e22:	0f b6       	in	r0, 0x3f	; 63
    2e24:	f8 94       	cli
    2e26:	de bf       	out	0x3e, r29	; 62
    2e28:	0f be       	out	0x3f, r0	; 63
    2e2a:	cd bf       	out	0x3d, r28	; 61
    2e2c:	cf 91       	pop	r28
    2e2e:	df 91       	pop	r29
    2e30:	08 95       	ret

00002e32 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    2e32:	df 93       	push	r29
    2e34:	cf 93       	push	r28
    2e36:	00 d0       	rcall	.+0      	; 0x2e38 <prvBytesInBuffer+0x6>
    2e38:	00 d0       	rcall	.+0      	; 0x2e3a <prvBytesInBuffer+0x8>
    2e3a:	cd b7       	in	r28, 0x3d	; 61
    2e3c:	de b7       	in	r29, 0x3e	; 62
    2e3e:	9c 83       	std	Y+4, r25	; 0x04
    2e40:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2e42:	eb 81       	ldd	r30, Y+3	; 0x03
    2e44:	fc 81       	ldd	r31, Y+4	; 0x04
    2e46:	24 81       	ldd	r18, Z+4	; 0x04
    2e48:	35 81       	ldd	r19, Z+5	; 0x05
    2e4a:	eb 81       	ldd	r30, Y+3	; 0x03
    2e4c:	fc 81       	ldd	r31, Y+4	; 0x04
    2e4e:	82 81       	ldd	r24, Z+2	; 0x02
    2e50:	93 81       	ldd	r25, Z+3	; 0x03
    2e52:	82 0f       	add	r24, r18
    2e54:	93 1f       	adc	r25, r19
    2e56:	9a 83       	std	Y+2, r25	; 0x02
    2e58:	89 83       	std	Y+1, r24	; 0x01
    xCount -= pxStreamBuffer->xTail;
    2e5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2e5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2e5e:	20 81       	ld	r18, Z
    2e60:	31 81       	ldd	r19, Z+1	; 0x01
    2e62:	89 81       	ldd	r24, Y+1	; 0x01
    2e64:	9a 81       	ldd	r25, Y+2	; 0x02
    2e66:	82 1b       	sub	r24, r18
    2e68:	93 0b       	sbc	r25, r19
    2e6a:	9a 83       	std	Y+2, r25	; 0x02
    2e6c:	89 83       	std	Y+1, r24	; 0x01

    if( xCount >= pxStreamBuffer->xLength )
    2e6e:	eb 81       	ldd	r30, Y+3	; 0x03
    2e70:	fc 81       	ldd	r31, Y+4	; 0x04
    2e72:	24 81       	ldd	r18, Z+4	; 0x04
    2e74:	35 81       	ldd	r19, Z+5	; 0x05
    2e76:	89 81       	ldd	r24, Y+1	; 0x01
    2e78:	9a 81       	ldd	r25, Y+2	; 0x02
    2e7a:	82 17       	cp	r24, r18
    2e7c:	93 07       	cpc	r25, r19
    2e7e:	50 f0       	brcs	.+20     	; 0x2e94 <prvBytesInBuffer+0x62>
    {
        xCount -= pxStreamBuffer->xLength;
    2e80:	eb 81       	ldd	r30, Y+3	; 0x03
    2e82:	fc 81       	ldd	r31, Y+4	; 0x04
    2e84:	24 81       	ldd	r18, Z+4	; 0x04
    2e86:	35 81       	ldd	r19, Z+5	; 0x05
    2e88:	89 81       	ldd	r24, Y+1	; 0x01
    2e8a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e8c:	82 1b       	sub	r24, r18
    2e8e:	93 0b       	sbc	r25, r19
    2e90:	9a 83       	std	Y+2, r25	; 0x02
    2e92:	89 83       	std	Y+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
    2e94:	89 81       	ldd	r24, Y+1	; 0x01
    2e96:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2e98:	0f 90       	pop	r0
    2e9a:	0f 90       	pop	r0
    2e9c:	0f 90       	pop	r0
    2e9e:	0f 90       	pop	r0
    2ea0:	cf 91       	pop	r28
    2ea2:	df 91       	pop	r29
    2ea4:	08 95       	ret

00002ea6 <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
    2ea6:	cf 92       	push	r12
    2ea8:	df 92       	push	r13
    2eaa:	ef 92       	push	r14
    2eac:	ff 92       	push	r15
    2eae:	0f 93       	push	r16
    2eb0:	df 93       	push	r29
    2eb2:	cf 93       	push	r28
    2eb4:	cd b7       	in	r28, 0x3d	; 61
    2eb6:	de b7       	in	r29, 0x3e	; 62
    2eb8:	2d 97       	sbiw	r28, 0x0d	; 13
    2eba:	0f b6       	in	r0, 0x3f	; 63
    2ebc:	f8 94       	cli
    2ebe:	de bf       	out	0x3e, r29	; 62
    2ec0:	0f be       	out	0x3f, r0	; 63
    2ec2:	cd bf       	out	0x3d, r28	; 61
    2ec4:	9a 83       	std	Y+2, r25	; 0x02
    2ec6:	89 83       	std	Y+1, r24	; 0x01
    2ec8:	7c 83       	std	Y+4, r23	; 0x04
    2eca:	6b 83       	std	Y+3, r22	; 0x03
    2ecc:	5e 83       	std	Y+6, r21	; 0x06
    2ece:	4d 83       	std	Y+5, r20	; 0x05
    2ed0:	38 87       	std	Y+8, r19	; 0x08
    2ed2:	2f 83       	std	Y+7, r18	; 0x07
    2ed4:	09 87       	std	Y+9, r16	; 0x09
    2ed6:	fb 86       	std	Y+11, r15	; 0x0b
    2ed8:	ea 86       	std	Y+10, r14	; 0x0a
    2eda:	dd 86       	std	Y+13, r13	; 0x0d
    2edc:	cc 86       	std	Y+12, r12	; 0x0c
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    2ede:	89 81       	ldd	r24, Y+1	; 0x01
    2ee0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ee2:	60 e0       	ldi	r22, 0x00	; 0
    2ee4:	70 e0       	ldi	r23, 0x00	; 0
    2ee6:	4f e0       	ldi	r20, 0x0F	; 15
    2ee8:	50 e0       	ldi	r21, 0x00	; 0
    2eea:	0e 94 75 2b 	call	0x56ea	; 0x56ea <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
    2eee:	e9 81       	ldd	r30, Y+1	; 0x01
    2ef0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ef2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ef4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ef6:	95 87       	std	Z+13, r25	; 0x0d
    2ef8:	84 87       	std	Z+12, r24	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    2efa:	e9 81       	ldd	r30, Y+1	; 0x01
    2efc:	fa 81       	ldd	r31, Y+2	; 0x02
    2efe:	8d 81       	ldd	r24, Y+5	; 0x05
    2f00:	9e 81       	ldd	r25, Y+6	; 0x06
    2f02:	95 83       	std	Z+5, r25	; 0x05
    2f04:	84 83       	std	Z+4, r24	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    2f06:	e9 81       	ldd	r30, Y+1	; 0x01
    2f08:	fa 81       	ldd	r31, Y+2	; 0x02
    2f0a:	8f 81       	ldd	r24, Y+7	; 0x07
    2f0c:	98 85       	ldd	r25, Y+8	; 0x08
    2f0e:	97 83       	std	Z+7, r25	; 0x07
    2f10:	86 83       	std	Z+6, r24	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    2f12:	e9 81       	ldd	r30, Y+1	; 0x01
    2f14:	fa 81       	ldd	r31, Y+2	; 0x02
    2f16:	89 85       	ldd	r24, Y+9	; 0x09
    2f18:	86 87       	std	Z+14, r24	; 0x0e
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
    2f1a:	2d 96       	adiw	r28, 0x0d	; 13
    2f1c:	0f b6       	in	r0, 0x3f	; 63
    2f1e:	f8 94       	cli
    2f20:	de bf       	out	0x3e, r29	; 62
    2f22:	0f be       	out	0x3f, r0	; 63
    2f24:	cd bf       	out	0x3d, r28	; 61
    2f26:	cf 91       	pop	r28
    2f28:	df 91       	pop	r29
    2f2a:	0f 91       	pop	r16
    2f2c:	ff 90       	pop	r15
    2f2e:	ef 90       	pop	r14
    2f30:	df 90       	pop	r13
    2f32:	cf 90       	pop	r12
    2f34:	08 95       	ret

00002f36 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    2f36:	8f 92       	push	r8
    2f38:	9f 92       	push	r9
    2f3a:	af 92       	push	r10
    2f3c:	bf 92       	push	r11
    2f3e:	cf 92       	push	r12
    2f40:	df 92       	push	r13
    2f42:	ef 92       	push	r14
    2f44:	ff 92       	push	r15
    2f46:	0f 93       	push	r16
    2f48:	1f 93       	push	r17
    2f4a:	df 93       	push	r29
    2f4c:	cf 93       	push	r28
    2f4e:	cd b7       	in	r28, 0x3d	; 61
    2f50:	de b7       	in	r29, 0x3e	; 62
    2f52:	60 97       	sbiw	r28, 0x10	; 16
    2f54:	0f b6       	in	r0, 0x3f	; 63
    2f56:	f8 94       	cli
    2f58:	de bf       	out	0x3e, r29	; 62
    2f5a:	0f be       	out	0x3f, r0	; 63
    2f5c:	cd bf       	out	0x3d, r28	; 61
    2f5e:	9f 83       	std	Y+7, r25	; 0x07
    2f60:	8e 83       	std	Y+6, r24	; 0x06
    2f62:	79 87       	std	Y+9, r23	; 0x09
    2f64:	68 87       	std	Y+8, r22	; 0x08
    2f66:	5b 87       	std	Y+11, r21	; 0x0b
    2f68:	4a 87       	std	Y+10, r20	; 0x0a
    2f6a:	3d 87       	std	Y+13, r19	; 0x0d
    2f6c:	2c 87       	std	Y+12, r18	; 0x0c
    2f6e:	0e 87       	std	Y+14, r16	; 0x0e
    2f70:	f8 8a       	std	Y+16, r15	; 0x10
    2f72:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2f74:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f76:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f78:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    2f7c:	9a 83       	std	Y+2, r25	; 0x02
    2f7e:	89 83       	std	Y+1, r24	; 0x01

            if( pxStack != NULL )
    2f80:	89 81       	ldd	r24, Y+1	; 0x01
    2f82:	9a 81       	ldd	r25, Y+2	; 0x02
    2f84:	00 97       	sbiw	r24, 0x00	; 0
    2f86:	f1 f0       	breq	.+60     	; 0x2fc4 <xTaskCreate+0x8e>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2f88:	86 e2       	ldi	r24, 0x26	; 38
    2f8a:	90 e0       	ldi	r25, 0x00	; 0
    2f8c:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    2f90:	9d 83       	std	Y+5, r25	; 0x05
    2f92:	8c 83       	std	Y+4, r24	; 0x04

                if( pxNewTCB != NULL )
    2f94:	8c 81       	ldd	r24, Y+4	; 0x04
    2f96:	9d 81       	ldd	r25, Y+5	; 0x05
    2f98:	00 97       	sbiw	r24, 0x00	; 0
    2f9a:	79 f0       	breq	.+30     	; 0x2fba <xTaskCreate+0x84>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    2f9c:	8c 81       	ldd	r24, Y+4	; 0x04
    2f9e:	9d 81       	ldd	r25, Y+5	; 0x05
    2fa0:	60 e0       	ldi	r22, 0x00	; 0
    2fa2:	70 e0       	ldi	r23, 0x00	; 0
    2fa4:	46 e2       	ldi	r20, 0x26	; 38
    2fa6:	50 e0       	ldi	r21, 0x00	; 0
    2fa8:	0e 94 75 2b 	call	0x56ea	; 0x56ea <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    2fac:	ec 81       	ldd	r30, Y+4	; 0x04
    2fae:	fd 81       	ldd	r31, Y+5	; 0x05
    2fb0:	89 81       	ldd	r24, Y+1	; 0x01
    2fb2:	9a 81       	ldd	r25, Y+2	; 0x02
    2fb4:	90 8f       	std	Z+24, r25	; 0x18
    2fb6:	87 8b       	std	Z+23, r24	; 0x17
    2fb8:	07 c0       	rjmp	.+14     	; 0x2fc8 <xTaskCreate+0x92>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    2fba:	89 81       	ldd	r24, Y+1	; 0x01
    2fbc:	9a 81       	ldd	r25, Y+2	; 0x02
    2fbe:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    2fc2:	02 c0       	rjmp	.+4      	; 0x2fc8 <xTaskCreate+0x92>
                }
            }
            else
            {
                pxNewTCB = NULL;
    2fc4:	1d 82       	std	Y+5, r1	; 0x05
    2fc6:	1c 82       	std	Y+4, r1	; 0x04
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    2fc8:	8c 81       	ldd	r24, Y+4	; 0x04
    2fca:	9d 81       	ldd	r25, Y+5	; 0x05
    2fcc:	00 97       	sbiw	r24, 0x00	; 0
    2fce:	e9 f0       	breq	.+58     	; 0x300a <xTaskCreate+0xd4>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2fd0:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fd2:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fd4:	9c 01       	movw	r18, r24
    2fd6:	40 e0       	ldi	r20, 0x00	; 0
    2fd8:	50 e0       	ldi	r21, 0x00	; 0
    2fda:	8e 81       	ldd	r24, Y+6	; 0x06
    2fdc:	9f 81       	ldd	r25, Y+7	; 0x07
    2fde:	68 85       	ldd	r22, Y+8	; 0x08
    2fe0:	79 85       	ldd	r23, Y+9	; 0x09
    2fe2:	ec 85       	ldd	r30, Y+12	; 0x0c
    2fe4:	fd 85       	ldd	r31, Y+13	; 0x0d
    2fe6:	af 85       	ldd	r26, Y+15	; 0x0f
    2fe8:	b8 89       	ldd	r27, Y+16	; 0x10
    2fea:	ac 80       	ldd	r10, Y+4	; 0x04
    2fec:	bd 80       	ldd	r11, Y+5	; 0x05
    2fee:	8f 01       	movw	r16, r30
    2ff0:	ee 84       	ldd	r14, Y+14	; 0x0e
    2ff2:	6d 01       	movw	r12, r26
    2ff4:	88 24       	eor	r8, r8
    2ff6:	99 24       	eor	r9, r9
    2ff8:	0e 94 1b 18 	call	0x3036	; 0x3036 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    2ffc:	8c 81       	ldd	r24, Y+4	; 0x04
    2ffe:	9d 81       	ldd	r25, Y+5	; 0x05
    3000:	0e 94 ca 18 	call	0x3194	; 0x3194 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    3004:	81 e0       	ldi	r24, 0x01	; 1
    3006:	8b 83       	std	Y+3, r24	; 0x03
    3008:	02 c0       	rjmp	.+4      	; 0x300e <xTaskCreate+0xd8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    300a:	8f ef       	ldi	r24, 0xFF	; 255
    300c:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    300e:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3010:	60 96       	adiw	r28, 0x10	; 16
    3012:	0f b6       	in	r0, 0x3f	; 63
    3014:	f8 94       	cli
    3016:	de bf       	out	0x3e, r29	; 62
    3018:	0f be       	out	0x3f, r0	; 63
    301a:	cd bf       	out	0x3d, r28	; 61
    301c:	cf 91       	pop	r28
    301e:	df 91       	pop	r29
    3020:	1f 91       	pop	r17
    3022:	0f 91       	pop	r16
    3024:	ff 90       	pop	r15
    3026:	ef 90       	pop	r14
    3028:	df 90       	pop	r13
    302a:	cf 90       	pop	r12
    302c:	bf 90       	pop	r11
    302e:	af 90       	pop	r10
    3030:	9f 90       	pop	r9
    3032:	8f 90       	pop	r8
    3034:	08 95       	ret

00003036 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    3036:	8f 92       	push	r8
    3038:	9f 92       	push	r9
    303a:	af 92       	push	r10
    303c:	bf 92       	push	r11
    303e:	cf 92       	push	r12
    3040:	df 92       	push	r13
    3042:	ef 92       	push	r14
    3044:	0f 93       	push	r16
    3046:	1f 93       	push	r17
    3048:	df 93       	push	r29
    304a:	cf 93       	push	r28
    304c:	cd b7       	in	r28, 0x3d	; 61
    304e:	de b7       	in	r29, 0x3e	; 62
    3050:	64 97       	sbiw	r28, 0x14	; 20
    3052:	0f b6       	in	r0, 0x3f	; 63
    3054:	f8 94       	cli
    3056:	de bf       	out	0x3e, r29	; 62
    3058:	0f be       	out	0x3f, r0	; 63
    305a:	cd bf       	out	0x3d, r28	; 61
    305c:	9d 83       	std	Y+5, r25	; 0x05
    305e:	8c 83       	std	Y+4, r24	; 0x04
    3060:	7f 83       	std	Y+7, r23	; 0x07
    3062:	6e 83       	std	Y+6, r22	; 0x06
    3064:	28 87       	std	Y+8, r18	; 0x08
    3066:	39 87       	std	Y+9, r19	; 0x09
    3068:	4a 87       	std	Y+10, r20	; 0x0a
    306a:	5b 87       	std	Y+11, r21	; 0x0b
    306c:	1d 87       	std	Y+13, r17	; 0x0d
    306e:	0c 87       	std	Y+12, r16	; 0x0c
    3070:	ee 86       	std	Y+14, r14	; 0x0e
    3072:	d8 8a       	std	Y+16, r13	; 0x10
    3074:	cf 86       	std	Y+15, r12	; 0x0f
    3076:	ba 8a       	std	Y+18, r11	; 0x12
    3078:	a9 8a       	std	Y+17, r10	; 0x11
    307a:	9c 8a       	std	Y+20, r9	; 0x14
    307c:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    307e:	e9 89       	ldd	r30, Y+17	; 0x11
    3080:	fa 89       	ldd	r31, Y+18	; 0x12
    3082:	27 89       	ldd	r18, Z+23	; 0x17
    3084:	30 8d       	ldd	r19, Z+24	; 0x18
    3086:	88 85       	ldd	r24, Y+8	; 0x08
    3088:	99 85       	ldd	r25, Y+9	; 0x09
    308a:	01 97       	sbiw	r24, 0x01	; 1
    308c:	82 0f       	add	r24, r18
    308e:	93 1f       	adc	r25, r19
    3090:	9b 83       	std	Y+3, r25	; 0x03
    3092:	8a 83       	std	Y+2, r24	; 0x02
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    3094:	8e 81       	ldd	r24, Y+6	; 0x06
    3096:	9f 81       	ldd	r25, Y+7	; 0x07
    3098:	00 97       	sbiw	r24, 0x00	; 0
    309a:	49 f1       	breq	.+82     	; 0x30ee <prvInitialiseNewTask+0xb8>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    309c:	19 82       	std	Y+1, r1	; 0x01
    309e:	21 c0       	rjmp	.+66     	; 0x30e2 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    30a0:	89 81       	ldd	r24, Y+1	; 0x01
    30a2:	48 2f       	mov	r20, r24
    30a4:	50 e0       	ldi	r21, 0x00	; 0
    30a6:	89 81       	ldd	r24, Y+1	; 0x01
    30a8:	28 2f       	mov	r18, r24
    30aa:	30 e0       	ldi	r19, 0x00	; 0
    30ac:	8e 81       	ldd	r24, Y+6	; 0x06
    30ae:	9f 81       	ldd	r25, Y+7	; 0x07
    30b0:	fc 01       	movw	r30, r24
    30b2:	e2 0f       	add	r30, r18
    30b4:	f3 1f       	adc	r31, r19
    30b6:	20 81       	ld	r18, Z
    30b8:	89 89       	ldd	r24, Y+17	; 0x11
    30ba:	9a 89       	ldd	r25, Y+18	; 0x12
    30bc:	84 0f       	add	r24, r20
    30be:	95 1f       	adc	r25, r21
    30c0:	fc 01       	movw	r30, r24
    30c2:	79 96       	adiw	r30, 0x19	; 25
    30c4:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    30c6:	89 81       	ldd	r24, Y+1	; 0x01
    30c8:	28 2f       	mov	r18, r24
    30ca:	30 e0       	ldi	r19, 0x00	; 0
    30cc:	8e 81       	ldd	r24, Y+6	; 0x06
    30ce:	9f 81       	ldd	r25, Y+7	; 0x07
    30d0:	fc 01       	movw	r30, r24
    30d2:	e2 0f       	add	r30, r18
    30d4:	f3 1f       	adc	r31, r19
    30d6:	80 81       	ld	r24, Z
    30d8:	88 23       	and	r24, r24
    30da:	31 f0       	breq	.+12     	; 0x30e8 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    30dc:	89 81       	ldd	r24, Y+1	; 0x01
    30de:	8f 5f       	subi	r24, 0xFF	; 255
    30e0:	89 83       	std	Y+1, r24	; 0x01
    30e2:	89 81       	ldd	r24, Y+1	; 0x01
    30e4:	88 30       	cpi	r24, 0x08	; 8
    30e6:	e0 f2       	brcs	.-72     	; 0x30a0 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    30e8:	e9 89       	ldd	r30, Y+17	; 0x11
    30ea:	fa 89       	ldd	r31, Y+18	; 0x12
    30ec:	10 a2       	std	Z+32, r1	; 0x20
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    30ee:	8e 85       	ldd	r24, Y+14	; 0x0e
    30f0:	84 30       	cpi	r24, 0x04	; 4
    30f2:	10 f0       	brcs	.+4      	; 0x30f8 <prvInitialiseNewTask+0xc2>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    30f4:	83 e0       	ldi	r24, 0x03	; 3
    30f6:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    30f8:	e9 89       	ldd	r30, Y+17	; 0x11
    30fa:	fa 89       	ldd	r31, Y+18	; 0x12
    30fc:	8e 85       	ldd	r24, Y+14	; 0x0e
    30fe:	86 8b       	std	Z+22, r24	; 0x16
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3100:	89 89       	ldd	r24, Y+17	; 0x11
    3102:	9a 89       	ldd	r25, Y+18	; 0x12
    3104:	02 96       	adiw	r24, 0x02	; 2
    3106:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    310a:	89 89       	ldd	r24, Y+17	; 0x11
    310c:	9a 89       	ldd	r25, Y+18	; 0x12
    310e:	0c 96       	adiw	r24, 0x0c	; 12
    3110:	0e 94 0c 07 	call	0xe18	; 0xe18 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3114:	e9 89       	ldd	r30, Y+17	; 0x11
    3116:	fa 89       	ldd	r31, Y+18	; 0x12
    3118:	89 89       	ldd	r24, Y+17	; 0x11
    311a:	9a 89       	ldd	r25, Y+18	; 0x12
    311c:	91 87       	std	Z+9, r25	; 0x09
    311e:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3120:	8e 85       	ldd	r24, Y+14	; 0x0e
    3122:	28 2f       	mov	r18, r24
    3124:	30 e0       	ldi	r19, 0x00	; 0
    3126:	84 e0       	ldi	r24, 0x04	; 4
    3128:	90 e0       	ldi	r25, 0x00	; 0
    312a:	82 1b       	sub	r24, r18
    312c:	93 0b       	sbc	r25, r19
    312e:	e9 89       	ldd	r30, Y+17	; 0x11
    3130:	fa 89       	ldd	r31, Y+18	; 0x12
    3132:	95 87       	std	Z+13, r25	; 0x0d
    3134:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3136:	e9 89       	ldd	r30, Y+17	; 0x11
    3138:	fa 89       	ldd	r31, Y+18	; 0x12
    313a:	89 89       	ldd	r24, Y+17	; 0x11
    313c:	9a 89       	ldd	r25, Y+18	; 0x12
    313e:	93 8b       	std	Z+19, r25	; 0x13
    3140:	82 8b       	std	Z+18, r24	; 0x12
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3142:	8a 81       	ldd	r24, Y+2	; 0x02
    3144:	9b 81       	ldd	r25, Y+3	; 0x03
    3146:	2c 81       	ldd	r18, Y+4	; 0x04
    3148:	3d 81       	ldd	r19, Y+5	; 0x05
    314a:	4c 85       	ldd	r20, Y+12	; 0x0c
    314c:	5d 85       	ldd	r21, Y+13	; 0x0d
    314e:	b9 01       	movw	r22, r18
    3150:	0e 94 c9 00 	call	0x192	; 0x192 <pxPortInitialiseStack>
    3154:	e9 89       	ldd	r30, Y+17	; 0x11
    3156:	fa 89       	ldd	r31, Y+18	; 0x12
    3158:	91 83       	std	Z+1, r25	; 0x01
    315a:	80 83       	st	Z, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    315c:	8f 85       	ldd	r24, Y+15	; 0x0f
    315e:	98 89       	ldd	r25, Y+16	; 0x10
    3160:	00 97       	sbiw	r24, 0x00	; 0
    3162:	31 f0       	breq	.+12     	; 0x3170 <prvInitialiseNewTask+0x13a>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3164:	ef 85       	ldd	r30, Y+15	; 0x0f
    3166:	f8 89       	ldd	r31, Y+16	; 0x10
    3168:	89 89       	ldd	r24, Y+17	; 0x11
    316a:	9a 89       	ldd	r25, Y+18	; 0x12
    316c:	91 83       	std	Z+1, r25	; 0x01
    316e:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3170:	64 96       	adiw	r28, 0x14	; 20
    3172:	0f b6       	in	r0, 0x3f	; 63
    3174:	f8 94       	cli
    3176:	de bf       	out	0x3e, r29	; 62
    3178:	0f be       	out	0x3f, r0	; 63
    317a:	cd bf       	out	0x3d, r28	; 61
    317c:	cf 91       	pop	r28
    317e:	df 91       	pop	r29
    3180:	1f 91       	pop	r17
    3182:	0f 91       	pop	r16
    3184:	ef 90       	pop	r14
    3186:	df 90       	pop	r13
    3188:	cf 90       	pop	r12
    318a:	bf 90       	pop	r11
    318c:	af 90       	pop	r10
    318e:	9f 90       	pop	r9
    3190:	8f 90       	pop	r8
    3192:	08 95       	ret

00003194 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    3194:	df 93       	push	r29
    3196:	cf 93       	push	r28
    3198:	00 d0       	rcall	.+0      	; 0x319a <prvAddNewTaskToReadyList+0x6>
    319a:	00 d0       	rcall	.+0      	; 0x319c <prvAddNewTaskToReadyList+0x8>
    319c:	cd b7       	in	r28, 0x3d	; 61
    319e:	de b7       	in	r29, 0x3e	; 62
    31a0:	9c 83       	std	Y+4, r25	; 0x04
    31a2:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    31a4:	0f b6       	in	r0, 0x3f	; 63
    31a6:	f8 94       	cli
    31a8:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    31aa:	80 91 4f 06 	lds	r24, 0x064F
    31ae:	8f 5f       	subi	r24, 0xFF	; 255
    31b0:	80 93 4f 06 	sts	0x064F, r24

        if( pxCurrentTCB == NULL )
    31b4:	80 91 4c 06 	lds	r24, 0x064C
    31b8:	90 91 4d 06 	lds	r25, 0x064D
    31bc:	00 97       	sbiw	r24, 0x00	; 0
    31be:	69 f4       	brne	.+26     	; 0x31da <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    31c0:	8b 81       	ldd	r24, Y+3	; 0x03
    31c2:	9c 81       	ldd	r25, Y+4	; 0x04
    31c4:	90 93 4d 06 	sts	0x064D, r25
    31c8:	80 93 4c 06 	sts	0x064C, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    31cc:	80 91 4f 06 	lds	r24, 0x064F
    31d0:	81 30       	cpi	r24, 0x01	; 1
    31d2:	b9 f4       	brne	.+46     	; 0x3202 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    31d4:	0e 94 4b 22 	call	0x4496	; 0x4496 <prvInitialiseTaskLists>
    31d8:	14 c0       	rjmp	.+40     	; 0x3202 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    31da:	80 91 53 06 	lds	r24, 0x0653
    31de:	88 23       	and	r24, r24
    31e0:	81 f4       	brne	.+32     	; 0x3202 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    31e2:	e0 91 4c 06 	lds	r30, 0x064C
    31e6:	f0 91 4d 06 	lds	r31, 0x064D
    31ea:	96 89       	ldd	r25, Z+22	; 0x16
    31ec:	eb 81       	ldd	r30, Y+3	; 0x03
    31ee:	fc 81       	ldd	r31, Y+4	; 0x04
    31f0:	86 89       	ldd	r24, Z+22	; 0x16
    31f2:	89 17       	cp	r24, r25
    31f4:	30 f0       	brcs	.+12     	; 0x3202 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    31f6:	8b 81       	ldd	r24, Y+3	; 0x03
    31f8:	9c 81       	ldd	r25, Y+4	; 0x04
    31fa:	90 93 4d 06 	sts	0x064D, r25
    31fe:	80 93 4c 06 	sts	0x064C, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    3202:	80 91 58 06 	lds	r24, 0x0658
    3206:	8f 5f       	subi	r24, 0xFF	; 255
    3208:	80 93 58 06 	sts	0x0658, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    320c:	eb 81       	ldd	r30, Y+3	; 0x03
    320e:	fc 81       	ldd	r31, Y+4	; 0x04
    3210:	96 89       	ldd	r25, Z+22	; 0x16
    3212:	80 91 52 06 	lds	r24, 0x0652
    3216:	89 17       	cp	r24, r25
    3218:	28 f4       	brcc	.+10     	; 0x3224 <prvAddNewTaskToReadyList+0x90>
    321a:	eb 81       	ldd	r30, Y+3	; 0x03
    321c:	fc 81       	ldd	r31, Y+4	; 0x04
    321e:	86 89       	ldd	r24, Z+22	; 0x16
    3220:	80 93 52 06 	sts	0x0652, r24
    3224:	eb 81       	ldd	r30, Y+3	; 0x03
    3226:	fc 81       	ldd	r31, Y+4	; 0x04
    3228:	86 89       	ldd	r24, Z+22	; 0x16
    322a:	28 2f       	mov	r18, r24
    322c:	30 e0       	ldi	r19, 0x00	; 0
    322e:	c9 01       	movw	r24, r18
    3230:	88 0f       	add	r24, r24
    3232:	99 1f       	adc	r25, r25
    3234:	88 0f       	add	r24, r24
    3236:	99 1f       	adc	r25, r25
    3238:	88 0f       	add	r24, r24
    323a:	99 1f       	adc	r25, r25
    323c:	82 0f       	add	r24, r18
    323e:	93 1f       	adc	r25, r19
    3240:	fc 01       	movw	r30, r24
    3242:	e2 5a       	subi	r30, 0xA2	; 162
    3244:	f9 4f       	sbci	r31, 0xF9	; 249
    3246:	81 81       	ldd	r24, Z+1	; 0x01
    3248:	92 81       	ldd	r25, Z+2	; 0x02
    324a:	9a 83       	std	Y+2, r25	; 0x02
    324c:	89 83       	std	Y+1, r24	; 0x01
    324e:	eb 81       	ldd	r30, Y+3	; 0x03
    3250:	fc 81       	ldd	r31, Y+4	; 0x04
    3252:	89 81       	ldd	r24, Y+1	; 0x01
    3254:	9a 81       	ldd	r25, Y+2	; 0x02
    3256:	95 83       	std	Z+5, r25	; 0x05
    3258:	84 83       	std	Z+4, r24	; 0x04
    325a:	e9 81       	ldd	r30, Y+1	; 0x01
    325c:	fa 81       	ldd	r31, Y+2	; 0x02
    325e:	84 81       	ldd	r24, Z+4	; 0x04
    3260:	95 81       	ldd	r25, Z+5	; 0x05
    3262:	eb 81       	ldd	r30, Y+3	; 0x03
    3264:	fc 81       	ldd	r31, Y+4	; 0x04
    3266:	97 83       	std	Z+7, r25	; 0x07
    3268:	86 83       	std	Z+6, r24	; 0x06
    326a:	e9 81       	ldd	r30, Y+1	; 0x01
    326c:	fa 81       	ldd	r31, Y+2	; 0x02
    326e:	04 80       	ldd	r0, Z+4	; 0x04
    3270:	f5 81       	ldd	r31, Z+5	; 0x05
    3272:	e0 2d       	mov	r30, r0
    3274:	8b 81       	ldd	r24, Y+3	; 0x03
    3276:	9c 81       	ldd	r25, Y+4	; 0x04
    3278:	02 96       	adiw	r24, 0x02	; 2
    327a:	93 83       	std	Z+3, r25	; 0x03
    327c:	82 83       	std	Z+2, r24	; 0x02
    327e:	8b 81       	ldd	r24, Y+3	; 0x03
    3280:	9c 81       	ldd	r25, Y+4	; 0x04
    3282:	02 96       	adiw	r24, 0x02	; 2
    3284:	e9 81       	ldd	r30, Y+1	; 0x01
    3286:	fa 81       	ldd	r31, Y+2	; 0x02
    3288:	95 83       	std	Z+5, r25	; 0x05
    328a:	84 83       	std	Z+4, r24	; 0x04
    328c:	eb 81       	ldd	r30, Y+3	; 0x03
    328e:	fc 81       	ldd	r31, Y+4	; 0x04
    3290:	86 89       	ldd	r24, Z+22	; 0x16
    3292:	28 2f       	mov	r18, r24
    3294:	30 e0       	ldi	r19, 0x00	; 0
    3296:	c9 01       	movw	r24, r18
    3298:	88 0f       	add	r24, r24
    329a:	99 1f       	adc	r25, r25
    329c:	88 0f       	add	r24, r24
    329e:	99 1f       	adc	r25, r25
    32a0:	88 0f       	add	r24, r24
    32a2:	99 1f       	adc	r25, r25
    32a4:	82 0f       	add	r24, r18
    32a6:	93 1f       	adc	r25, r19
    32a8:	82 5a       	subi	r24, 0xA2	; 162
    32aa:	99 4f       	sbci	r25, 0xF9	; 249
    32ac:	eb 81       	ldd	r30, Y+3	; 0x03
    32ae:	fc 81       	ldd	r31, Y+4	; 0x04
    32b0:	93 87       	std	Z+11, r25	; 0x0b
    32b2:	82 87       	std	Z+10, r24	; 0x0a
    32b4:	eb 81       	ldd	r30, Y+3	; 0x03
    32b6:	fc 81       	ldd	r31, Y+4	; 0x04
    32b8:	86 89       	ldd	r24, Z+22	; 0x16
    32ba:	28 2f       	mov	r18, r24
    32bc:	30 e0       	ldi	r19, 0x00	; 0
    32be:	c9 01       	movw	r24, r18
    32c0:	88 0f       	add	r24, r24
    32c2:	99 1f       	adc	r25, r25
    32c4:	88 0f       	add	r24, r24
    32c6:	99 1f       	adc	r25, r25
    32c8:	88 0f       	add	r24, r24
    32ca:	99 1f       	adc	r25, r25
    32cc:	82 0f       	add	r24, r18
    32ce:	93 1f       	adc	r25, r19
    32d0:	fc 01       	movw	r30, r24
    32d2:	e2 5a       	subi	r30, 0xA2	; 162
    32d4:	f9 4f       	sbci	r31, 0xF9	; 249
    32d6:	80 81       	ld	r24, Z
    32d8:	8f 5f       	subi	r24, 0xFF	; 255
    32da:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    32dc:	0f 90       	pop	r0
    32de:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    32e0:	80 91 53 06 	lds	r24, 0x0653
    32e4:	88 23       	and	r24, r24
    32e6:	61 f0       	breq	.+24     	; 0x3300 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    32e8:	e0 91 4c 06 	lds	r30, 0x064C
    32ec:	f0 91 4d 06 	lds	r31, 0x064D
    32f0:	96 89       	ldd	r25, Z+22	; 0x16
    32f2:	eb 81       	ldd	r30, Y+3	; 0x03
    32f4:	fc 81       	ldd	r31, Y+4	; 0x04
    32f6:	86 89       	ldd	r24, Z+22	; 0x16
    32f8:	98 17       	cp	r25, r24
    32fa:	10 f4       	brcc	.+4      	; 0x3300 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    32fc:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3300:	0f 90       	pop	r0
    3302:	0f 90       	pop	r0
    3304:	0f 90       	pop	r0
    3306:	0f 90       	pop	r0
    3308:	cf 91       	pop	r28
    330a:	df 91       	pop	r29
    330c:	08 95       	ret

0000330e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    330e:	df 93       	push	r29
    3310:	cf 93       	push	r28
    3312:	00 d0       	rcall	.+0      	; 0x3314 <vTaskDelete+0x6>
    3314:	00 d0       	rcall	.+0      	; 0x3316 <vTaskDelete+0x8>
    3316:	00 d0       	rcall	.+0      	; 0x3318 <vTaskDelete+0xa>
    3318:	cd b7       	in	r28, 0x3d	; 61
    331a:	de b7       	in	r29, 0x3e	; 62
    331c:	9c 83       	std	Y+4, r25	; 0x04
    331e:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    3320:	0f b6       	in	r0, 0x3f	; 63
    3322:	f8 94       	cli
    3324:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3326:	8b 81       	ldd	r24, Y+3	; 0x03
    3328:	9c 81       	ldd	r25, Y+4	; 0x04
    332a:	00 97       	sbiw	r24, 0x00	; 0
    332c:	39 f4       	brne	.+14     	; 0x333c <vTaskDelete+0x2e>
    332e:	80 91 4c 06 	lds	r24, 0x064C
    3332:	90 91 4d 06 	lds	r25, 0x064D
    3336:	9e 83       	std	Y+6, r25	; 0x06
    3338:	8d 83       	std	Y+5, r24	; 0x05
    333a:	04 c0       	rjmp	.+8      	; 0x3344 <vTaskDelete+0x36>
    333c:	8b 81       	ldd	r24, Y+3	; 0x03
    333e:	9c 81       	ldd	r25, Y+4	; 0x04
    3340:	9e 83       	std	Y+6, r25	; 0x06
    3342:	8d 83       	std	Y+5, r24	; 0x05
    3344:	8d 81       	ldd	r24, Y+5	; 0x05
    3346:	9e 81       	ldd	r25, Y+6	; 0x06
    3348:	9a 83       	std	Y+2, r25	; 0x02
    334a:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    334c:	89 81       	ldd	r24, Y+1	; 0x01
    334e:	9a 81       	ldd	r25, Y+2	; 0x02
    3350:	02 96       	adiw	r24, 0x02	; 2
    3352:	0e 94 cc 07 	call	0xf98	; 0xf98 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3356:	e9 81       	ldd	r30, Y+1	; 0x01
    3358:	fa 81       	ldd	r31, Y+2	; 0x02
    335a:	84 89       	ldd	r24, Z+20	; 0x14
    335c:	95 89       	ldd	r25, Z+21	; 0x15
    335e:	00 97       	sbiw	r24, 0x00	; 0
    3360:	29 f0       	breq	.+10     	; 0x336c <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3362:	89 81       	ldd	r24, Y+1	; 0x01
    3364:	9a 81       	ldd	r25, Y+2	; 0x02
    3366:	0c 96       	adiw	r24, 0x0c	; 12
    3368:	0e 94 cc 07 	call	0xf98	; 0xf98 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    336c:	80 91 58 06 	lds	r24, 0x0658
    3370:	8f 5f       	subi	r24, 0xFF	; 255
    3372:	80 93 58 06 	sts	0x0658, r24

            if( pxTCB == pxCurrentTCB )
    3376:	20 91 4c 06 	lds	r18, 0x064C
    337a:	30 91 4d 06 	lds	r19, 0x064D
    337e:	89 81       	ldd	r24, Y+1	; 0x01
    3380:	9a 81       	ldd	r25, Y+2	; 0x02
    3382:	82 17       	cp	r24, r18
    3384:	93 07       	cpc	r25, r19
    3386:	81 f4       	brne	.+32     	; 0x33a8 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3388:	89 81       	ldd	r24, Y+1	; 0x01
    338a:	9a 81       	ldd	r25, Y+2	; 0x02
    338c:	9c 01       	movw	r18, r24
    338e:	2e 5f       	subi	r18, 0xFE	; 254
    3390:	3f 4f       	sbci	r19, 0xFF	; 255
    3392:	81 ea       	ldi	r24, 0xA1	; 161
    3394:	96 e0       	ldi	r25, 0x06	; 6
    3396:	b9 01       	movw	r22, r18
    3398:	0e 94 1c 07 	call	0xe38	; 0xe38 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    339c:	80 91 4e 06 	lds	r24, 0x064E
    33a0:	8f 5f       	subi	r24, 0xFF	; 255
    33a2:	80 93 4e 06 	sts	0x064E, r24
    33a6:	07 c0       	rjmp	.+14     	; 0x33b6 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    33a8:	80 91 4f 06 	lds	r24, 0x064F
    33ac:	81 50       	subi	r24, 0x01	; 1
    33ae:	80 93 4f 06 	sts	0x064F, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    33b2:	0e 94 cd 22 	call	0x459a	; 0x459a <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    33b6:	0f 90       	pop	r0
    33b8:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    33ba:	20 91 4c 06 	lds	r18, 0x064C
    33be:	30 91 4d 06 	lds	r19, 0x064D
    33c2:	89 81       	ldd	r24, Y+1	; 0x01
    33c4:	9a 81       	ldd	r25, Y+2	; 0x02
    33c6:	82 17       	cp	r24, r18
    33c8:	93 07       	cpc	r25, r19
    33ca:	21 f0       	breq	.+8      	; 0x33d4 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    33cc:	89 81       	ldd	r24, Y+1	; 0x01
    33ce:	9a 81       	ldd	r25, Y+2	; 0x02
    33d0:	0e 94 b7 22 	call	0x456e	; 0x456e <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    33d4:	80 91 53 06 	lds	r24, 0x0653
    33d8:	88 23       	and	r24, r24
    33da:	59 f0       	breq	.+22     	; 0x33f2 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    33dc:	20 91 4c 06 	lds	r18, 0x064C
    33e0:	30 91 4d 06 	lds	r19, 0x064D
    33e4:	89 81       	ldd	r24, Y+1	; 0x01
    33e6:	9a 81       	ldd	r25, Y+2	; 0x02
    33e8:	82 17       	cp	r24, r18
    33ea:	93 07       	cpc	r25, r19
    33ec:	11 f4       	brne	.+4      	; 0x33f2 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    33ee:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    33f2:	26 96       	adiw	r28, 0x06	; 6
    33f4:	0f b6       	in	r0, 0x3f	; 63
    33f6:	f8 94       	cli
    33f8:	de bf       	out	0x3e, r29	; 62
    33fa:	0f be       	out	0x3f, r0	; 63
    33fc:	cd bf       	out	0x3d, r28	; 61
    33fe:	cf 91       	pop	r28
    3400:	df 91       	pop	r29
    3402:	08 95       	ret

00003404 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    3404:	df 93       	push	r29
    3406:	cf 93       	push	r28
    3408:	cd b7       	in	r28, 0x3d	; 61
    340a:	de b7       	in	r29, 0x3e	; 62
    340c:	2a 97       	sbiw	r28, 0x0a	; 10
    340e:	0f b6       	in	r0, 0x3f	; 63
    3410:	f8 94       	cli
    3412:	de bf       	out	0x3e, r29	; 62
    3414:	0f be       	out	0x3f, r0	; 63
    3416:	cd bf       	out	0x3d, r28	; 61
    3418:	98 87       	std	Y+8, r25	; 0x08
    341a:	8f 83       	std	Y+7, r24	; 0x07
    341c:	7a 87       	std	Y+10, r23	; 0x0a
    341e:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3420:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    3422:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    3426:	80 91 50 06 	lds	r24, 0x0650
    342a:	90 91 51 06 	lds	r25, 0x0651
    342e:	9a 83       	std	Y+2, r25	; 0x02
    3430:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3432:	ef 81       	ldd	r30, Y+7	; 0x07
    3434:	f8 85       	ldd	r31, Y+8	; 0x08
    3436:	20 81       	ld	r18, Z
    3438:	31 81       	ldd	r19, Z+1	; 0x01
    343a:	89 85       	ldd	r24, Y+9	; 0x09
    343c:	9a 85       	ldd	r25, Y+10	; 0x0a
    343e:	82 0f       	add	r24, r18
    3440:	93 1f       	adc	r25, r19
    3442:	9e 83       	std	Y+6, r25	; 0x06
    3444:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    3446:	ef 81       	ldd	r30, Y+7	; 0x07
    3448:	f8 85       	ldd	r31, Y+8	; 0x08
    344a:	20 81       	ld	r18, Z
    344c:	31 81       	ldd	r19, Z+1	; 0x01
    344e:	89 81       	ldd	r24, Y+1	; 0x01
    3450:	9a 81       	ldd	r25, Y+2	; 0x02
    3452:	82 17       	cp	r24, r18
    3454:	93 07       	cpc	r25, r19
    3456:	98 f4       	brcc	.+38     	; 0x347e <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3458:	ef 81       	ldd	r30, Y+7	; 0x07
    345a:	f8 85       	ldd	r31, Y+8	; 0x08
    345c:	20 81       	ld	r18, Z
    345e:	31 81       	ldd	r19, Z+1	; 0x01
    3460:	8d 81       	ldd	r24, Y+5	; 0x05
    3462:	9e 81       	ldd	r25, Y+6	; 0x06
    3464:	82 17       	cp	r24, r18
    3466:	93 07       	cpc	r25, r19
    3468:	e0 f4       	brcc	.+56     	; 0x34a2 <xTaskDelayUntil+0x9e>
    346a:	2d 81       	ldd	r18, Y+5	; 0x05
    346c:	3e 81       	ldd	r19, Y+6	; 0x06
    346e:	89 81       	ldd	r24, Y+1	; 0x01
    3470:	9a 81       	ldd	r25, Y+2	; 0x02
    3472:	82 17       	cp	r24, r18
    3474:	93 07       	cpc	r25, r19
    3476:	a8 f4       	brcc	.+42     	; 0x34a2 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3478:	81 e0       	ldi	r24, 0x01	; 1
    347a:	8b 83       	std	Y+3, r24	; 0x03
    347c:	12 c0       	rjmp	.+36     	; 0x34a2 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    347e:	ef 81       	ldd	r30, Y+7	; 0x07
    3480:	f8 85       	ldd	r31, Y+8	; 0x08
    3482:	20 81       	ld	r18, Z
    3484:	31 81       	ldd	r19, Z+1	; 0x01
    3486:	8d 81       	ldd	r24, Y+5	; 0x05
    3488:	9e 81       	ldd	r25, Y+6	; 0x06
    348a:	82 17       	cp	r24, r18
    348c:	93 07       	cpc	r25, r19
    348e:	38 f0       	brcs	.+14     	; 0x349e <xTaskDelayUntil+0x9a>
    3490:	2d 81       	ldd	r18, Y+5	; 0x05
    3492:	3e 81       	ldd	r19, Y+6	; 0x06
    3494:	89 81       	ldd	r24, Y+1	; 0x01
    3496:	9a 81       	ldd	r25, Y+2	; 0x02
    3498:	82 17       	cp	r24, r18
    349a:	93 07       	cpc	r25, r19
    349c:	10 f4       	brcc	.+4      	; 0x34a2 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    349e:	81 e0       	ldi	r24, 0x01	; 1
    34a0:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    34a2:	ef 81       	ldd	r30, Y+7	; 0x07
    34a4:	f8 85       	ldd	r31, Y+8	; 0x08
    34a6:	8d 81       	ldd	r24, Y+5	; 0x05
    34a8:	9e 81       	ldd	r25, Y+6	; 0x06
    34aa:	91 83       	std	Z+1, r25	; 0x01
    34ac:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    34ae:	8b 81       	ldd	r24, Y+3	; 0x03
    34b0:	88 23       	and	r24, r24
    34b2:	49 f0       	breq	.+18     	; 0x34c6 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    34b4:	8d 81       	ldd	r24, Y+5	; 0x05
    34b6:	9e 81       	ldd	r25, Y+6	; 0x06
    34b8:	29 81       	ldd	r18, Y+1	; 0x01
    34ba:	3a 81       	ldd	r19, Y+2	; 0x02
    34bc:	82 1b       	sub	r24, r18
    34be:	93 0b       	sbc	r25, r19
    34c0:	60 e0       	ldi	r22, 0x00	; 0
    34c2:	0e 94 ad 2a 	call	0x555a	; 0x555a <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    34c6:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    34ca:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    34cc:	8c 81       	ldd	r24, Y+4	; 0x04
    34ce:	88 23       	and	r24, r24
    34d0:	11 f4       	brne	.+4      	; 0x34d6 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    34d2:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    34d6:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    34d8:	2a 96       	adiw	r28, 0x0a	; 10
    34da:	0f b6       	in	r0, 0x3f	; 63
    34dc:	f8 94       	cli
    34de:	de bf       	out	0x3e, r29	; 62
    34e0:	0f be       	out	0x3f, r0	; 63
    34e2:	cd bf       	out	0x3d, r28	; 61
    34e4:	cf 91       	pop	r28
    34e6:	df 91       	pop	r29
    34e8:	08 95       	ret

000034ea <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    34ea:	df 93       	push	r29
    34ec:	cf 93       	push	r28
    34ee:	00 d0       	rcall	.+0      	; 0x34f0 <vTaskDelay+0x6>
    34f0:	0f 92       	push	r0
    34f2:	cd b7       	in	r28, 0x3d	; 61
    34f4:	de b7       	in	r29, 0x3e	; 62
    34f6:	9b 83       	std	Y+3, r25	; 0x03
    34f8:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    34fa:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    34fc:	8a 81       	ldd	r24, Y+2	; 0x02
    34fe:	9b 81       	ldd	r25, Y+3	; 0x03
    3500:	00 97       	sbiw	r24, 0x00	; 0
    3502:	51 f0       	breq	.+20     	; 0x3518 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    3504:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3508:	8a 81       	ldd	r24, Y+2	; 0x02
    350a:	9b 81       	ldd	r25, Y+3	; 0x03
    350c:	60 e0       	ldi	r22, 0x00	; 0
    350e:	0e 94 ad 2a 	call	0x555a	; 0x555a <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    3512:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    3516:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3518:	89 81       	ldd	r24, Y+1	; 0x01
    351a:	88 23       	and	r24, r24
    351c:	11 f4       	brne	.+4      	; 0x3522 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    351e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    3522:	0f 90       	pop	r0
    3524:	0f 90       	pop	r0
    3526:	0f 90       	pop	r0
    3528:	cf 91       	pop	r28
    352a:	df 91       	pop	r29
    352c:	08 95       	ret

0000352e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    352e:	ef 92       	push	r14
    3530:	ff 92       	push	r15
    3532:	0f 93       	push	r16
    3534:	df 93       	push	r29
    3536:	cf 93       	push	r28
    3538:	00 d0       	rcall	.+0      	; 0x353a <vTaskStartScheduler+0xc>
    353a:	cd b7       	in	r28, 0x3d	; 61
    353c:	de b7       	in	r29, 0x3e	; 62
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    353e:	8b e3       	ldi	r24, 0x3B	; 59
    3540:	92 e2       	ldi	r25, 0x22	; 34
    3542:	20 e6       	ldi	r18, 0x60	; 96
    3544:	30 e0       	ldi	r19, 0x00	; 0
    3546:	eb e5       	ldi	r30, 0x5B	; 91
    3548:	f6 e0       	ldi	r31, 0x06	; 6
    354a:	b9 01       	movw	r22, r18
    354c:	45 e5       	ldi	r20, 0x55	; 85
    354e:	50 e0       	ldi	r21, 0x00	; 0
    3550:	20 e0       	ldi	r18, 0x00	; 0
    3552:	30 e0       	ldi	r19, 0x00	; 0
    3554:	00 e0       	ldi	r16, 0x00	; 0
    3556:	7f 01       	movw	r14, r30
    3558:	0e 94 9b 17 	call	0x2f36	; 0x2f36 <xTaskCreate>
    355c:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    355e:	89 81       	ldd	r24, Y+1	; 0x01
    3560:	81 30       	cpi	r24, 0x01	; 1
    3562:	81 f4       	brne	.+32     	; 0x3584 <vTaskStartScheduler+0x56>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    3564:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    3566:	8f ef       	ldi	r24, 0xFF	; 255
    3568:	9f ef       	ldi	r25, 0xFF	; 255
    356a:	90 93 5a 06 	sts	0x065A, r25
    356e:	80 93 59 06 	sts	0x0659, r24
        xSchedulerRunning = pdTRUE;
    3572:	81 e0       	ldi	r24, 0x01	; 1
    3574:	80 93 53 06 	sts	0x0653, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3578:	10 92 51 06 	sts	0x0651, r1
    357c:	10 92 50 06 	sts	0x0650, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    3580:	0e 94 4c 02 	call	0x498	; 0x498 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3584:	80 91 6b 00 	lds	r24, 0x006B
}
    3588:	0f 90       	pop	r0
    358a:	0f 90       	pop	r0
    358c:	cf 91       	pop	r28
    358e:	df 91       	pop	r29
    3590:	0f 91       	pop	r16
    3592:	ff 90       	pop	r15
    3594:	ef 90       	pop	r14
    3596:	08 95       	ret

00003598 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3598:	df 93       	push	r29
    359a:	cf 93       	push	r28
    359c:	cd b7       	in	r28, 0x3d	; 61
    359e:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    35a0:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    35a2:	10 92 53 06 	sts	0x0653, r1
    vPortEndScheduler();
    35a6:	0e 94 81 02 	call	0x502	; 0x502 <vPortEndScheduler>
}
    35aa:	cf 91       	pop	r28
    35ac:	df 91       	pop	r29
    35ae:	08 95       	ret

000035b0 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    35b0:	df 93       	push	r29
    35b2:	cf 93       	push	r28
    35b4:	cd b7       	in	r28, 0x3d	; 61
    35b6:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    35b8:	80 91 5d 06 	lds	r24, 0x065D
    35bc:	8f 5f       	subi	r24, 0xFF	; 255
    35be:	80 93 5d 06 	sts	0x065D, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    35c2:	cf 91       	pop	r28
    35c4:	df 91       	pop	r29
    35c6:	08 95       	ret

000035c8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    35c8:	df 93       	push	r29
    35ca:	cf 93       	push	r28
    35cc:	cd b7       	in	r28, 0x3d	; 61
    35ce:	de b7       	in	r29, 0x3e	; 62
    35d0:	2b 97       	sbiw	r28, 0x0b	; 11
    35d2:	0f b6       	in	r0, 0x3f	; 63
    35d4:	f8 94       	cli
    35d6:	de bf       	out	0x3e, r29	; 62
    35d8:	0f be       	out	0x3f, r0	; 63
    35da:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    35dc:	1b 86       	std	Y+11, r1	; 0x0b
    35de:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    35e0:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    35e2:	0f b6       	in	r0, 0x3f	; 63
    35e4:	f8 94       	cli
    35e6:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    35e8:	80 91 5d 06 	lds	r24, 0x065D
    35ec:	81 50       	subi	r24, 0x01	; 1
    35ee:	80 93 5d 06 	sts	0x065D, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    35f2:	80 91 5d 06 	lds	r24, 0x065D
    35f6:	88 23       	and	r24, r24
    35f8:	09 f0       	breq	.+2      	; 0x35fc <xTaskResumeAll+0x34>
    35fa:	2a c1       	rjmp	.+596    	; 0x3850 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    35fc:	80 91 4f 06 	lds	r24, 0x064F
    3600:	88 23       	and	r24, r24
    3602:	09 f4       	brne	.+2      	; 0x3606 <xTaskResumeAll+0x3e>
    3604:	25 c1       	rjmp	.+586    	; 0x3850 <xTaskResumeAll+0x288>
    3606:	f3 c0       	rjmp	.+486    	; 0x37ee <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3608:	e0 91 9d 06 	lds	r30, 0x069D
    360c:	f0 91 9e 06 	lds	r31, 0x069E
    3610:	86 81       	ldd	r24, Z+6	; 0x06
    3612:	97 81       	ldd	r25, Z+7	; 0x07
    3614:	9b 87       	std	Y+11, r25	; 0x0b
    3616:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3618:	ea 85       	ldd	r30, Y+10	; 0x0a
    361a:	fb 85       	ldd	r31, Y+11	; 0x0b
    361c:	84 89       	ldd	r24, Z+20	; 0x14
    361e:	95 89       	ldd	r25, Z+21	; 0x15
    3620:	98 87       	std	Y+8, r25	; 0x08
    3622:	8f 83       	std	Y+7, r24	; 0x07
    3624:	ea 85       	ldd	r30, Y+10	; 0x0a
    3626:	fb 85       	ldd	r31, Y+11	; 0x0b
    3628:	a6 85       	ldd	r26, Z+14	; 0x0e
    362a:	b7 85       	ldd	r27, Z+15	; 0x0f
    362c:	ea 85       	ldd	r30, Y+10	; 0x0a
    362e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3630:	80 89       	ldd	r24, Z+16	; 0x10
    3632:	91 89       	ldd	r25, Z+17	; 0x11
    3634:	15 96       	adiw	r26, 0x05	; 5
    3636:	9c 93       	st	X, r25
    3638:	8e 93       	st	-X, r24
    363a:	14 97       	sbiw	r26, 0x04	; 4
    363c:	ea 85       	ldd	r30, Y+10	; 0x0a
    363e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3640:	a0 89       	ldd	r26, Z+16	; 0x10
    3642:	b1 89       	ldd	r27, Z+17	; 0x11
    3644:	ea 85       	ldd	r30, Y+10	; 0x0a
    3646:	fb 85       	ldd	r31, Y+11	; 0x0b
    3648:	86 85       	ldd	r24, Z+14	; 0x0e
    364a:	97 85       	ldd	r25, Z+15	; 0x0f
    364c:	13 96       	adiw	r26, 0x03	; 3
    364e:	9c 93       	st	X, r25
    3650:	8e 93       	st	-X, r24
    3652:	12 97       	sbiw	r26, 0x02	; 2
    3654:	ef 81       	ldd	r30, Y+7	; 0x07
    3656:	f8 85       	ldd	r31, Y+8	; 0x08
    3658:	21 81       	ldd	r18, Z+1	; 0x01
    365a:	32 81       	ldd	r19, Z+2	; 0x02
    365c:	8a 85       	ldd	r24, Y+10	; 0x0a
    365e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3660:	0c 96       	adiw	r24, 0x0c	; 12
    3662:	28 17       	cp	r18, r24
    3664:	39 07       	cpc	r19, r25
    3666:	41 f4       	brne	.+16     	; 0x3678 <xTaskResumeAll+0xb0>
    3668:	ea 85       	ldd	r30, Y+10	; 0x0a
    366a:	fb 85       	ldd	r31, Y+11	; 0x0b
    366c:	80 89       	ldd	r24, Z+16	; 0x10
    366e:	91 89       	ldd	r25, Z+17	; 0x11
    3670:	ef 81       	ldd	r30, Y+7	; 0x07
    3672:	f8 85       	ldd	r31, Y+8	; 0x08
    3674:	92 83       	std	Z+2, r25	; 0x02
    3676:	81 83       	std	Z+1, r24	; 0x01
    3678:	ea 85       	ldd	r30, Y+10	; 0x0a
    367a:	fb 85       	ldd	r31, Y+11	; 0x0b
    367c:	15 8a       	std	Z+21, r1	; 0x15
    367e:	14 8a       	std	Z+20, r1	; 0x14
    3680:	ef 81       	ldd	r30, Y+7	; 0x07
    3682:	f8 85       	ldd	r31, Y+8	; 0x08
    3684:	80 81       	ld	r24, Z
    3686:	81 50       	subi	r24, 0x01	; 1
    3688:	ef 81       	ldd	r30, Y+7	; 0x07
    368a:	f8 85       	ldd	r31, Y+8	; 0x08
    368c:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    368e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3690:	fb 85       	ldd	r31, Y+11	; 0x0b
    3692:	82 85       	ldd	r24, Z+10	; 0x0a
    3694:	93 85       	ldd	r25, Z+11	; 0x0b
    3696:	9e 83       	std	Y+6, r25	; 0x06
    3698:	8d 83       	std	Y+5, r24	; 0x05
    369a:	ea 85       	ldd	r30, Y+10	; 0x0a
    369c:	fb 85       	ldd	r31, Y+11	; 0x0b
    369e:	a4 81       	ldd	r26, Z+4	; 0x04
    36a0:	b5 81       	ldd	r27, Z+5	; 0x05
    36a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    36a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    36a6:	86 81       	ldd	r24, Z+6	; 0x06
    36a8:	97 81       	ldd	r25, Z+7	; 0x07
    36aa:	15 96       	adiw	r26, 0x05	; 5
    36ac:	9c 93       	st	X, r25
    36ae:	8e 93       	st	-X, r24
    36b0:	14 97       	sbiw	r26, 0x04	; 4
    36b2:	ea 85       	ldd	r30, Y+10	; 0x0a
    36b4:	fb 85       	ldd	r31, Y+11	; 0x0b
    36b6:	a6 81       	ldd	r26, Z+6	; 0x06
    36b8:	b7 81       	ldd	r27, Z+7	; 0x07
    36ba:	ea 85       	ldd	r30, Y+10	; 0x0a
    36bc:	fb 85       	ldd	r31, Y+11	; 0x0b
    36be:	84 81       	ldd	r24, Z+4	; 0x04
    36c0:	95 81       	ldd	r25, Z+5	; 0x05
    36c2:	13 96       	adiw	r26, 0x03	; 3
    36c4:	9c 93       	st	X, r25
    36c6:	8e 93       	st	-X, r24
    36c8:	12 97       	sbiw	r26, 0x02	; 2
    36ca:	ed 81       	ldd	r30, Y+5	; 0x05
    36cc:	fe 81       	ldd	r31, Y+6	; 0x06
    36ce:	21 81       	ldd	r18, Z+1	; 0x01
    36d0:	32 81       	ldd	r19, Z+2	; 0x02
    36d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    36d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    36d6:	02 96       	adiw	r24, 0x02	; 2
    36d8:	28 17       	cp	r18, r24
    36da:	39 07       	cpc	r19, r25
    36dc:	41 f4       	brne	.+16     	; 0x36ee <xTaskResumeAll+0x126>
    36de:	ea 85       	ldd	r30, Y+10	; 0x0a
    36e0:	fb 85       	ldd	r31, Y+11	; 0x0b
    36e2:	86 81       	ldd	r24, Z+6	; 0x06
    36e4:	97 81       	ldd	r25, Z+7	; 0x07
    36e6:	ed 81       	ldd	r30, Y+5	; 0x05
    36e8:	fe 81       	ldd	r31, Y+6	; 0x06
    36ea:	92 83       	std	Z+2, r25	; 0x02
    36ec:	81 83       	std	Z+1, r24	; 0x01
    36ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    36f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    36f2:	13 86       	std	Z+11, r1	; 0x0b
    36f4:	12 86       	std	Z+10, r1	; 0x0a
    36f6:	ed 81       	ldd	r30, Y+5	; 0x05
    36f8:	fe 81       	ldd	r31, Y+6	; 0x06
    36fa:	80 81       	ld	r24, Z
    36fc:	81 50       	subi	r24, 0x01	; 1
    36fe:	ed 81       	ldd	r30, Y+5	; 0x05
    3700:	fe 81       	ldd	r31, Y+6	; 0x06
    3702:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    3704:	ea 85       	ldd	r30, Y+10	; 0x0a
    3706:	fb 85       	ldd	r31, Y+11	; 0x0b
    3708:	96 89       	ldd	r25, Z+22	; 0x16
    370a:	80 91 52 06 	lds	r24, 0x0652
    370e:	89 17       	cp	r24, r25
    3710:	28 f4       	brcc	.+10     	; 0x371c <xTaskResumeAll+0x154>
    3712:	ea 85       	ldd	r30, Y+10	; 0x0a
    3714:	fb 85       	ldd	r31, Y+11	; 0x0b
    3716:	86 89       	ldd	r24, Z+22	; 0x16
    3718:	80 93 52 06 	sts	0x0652, r24
    371c:	ea 85       	ldd	r30, Y+10	; 0x0a
    371e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3720:	86 89       	ldd	r24, Z+22	; 0x16
    3722:	28 2f       	mov	r18, r24
    3724:	30 e0       	ldi	r19, 0x00	; 0
    3726:	c9 01       	movw	r24, r18
    3728:	88 0f       	add	r24, r24
    372a:	99 1f       	adc	r25, r25
    372c:	88 0f       	add	r24, r24
    372e:	99 1f       	adc	r25, r25
    3730:	88 0f       	add	r24, r24
    3732:	99 1f       	adc	r25, r25
    3734:	82 0f       	add	r24, r18
    3736:	93 1f       	adc	r25, r19
    3738:	fc 01       	movw	r30, r24
    373a:	e2 5a       	subi	r30, 0xA2	; 162
    373c:	f9 4f       	sbci	r31, 0xF9	; 249
    373e:	81 81       	ldd	r24, Z+1	; 0x01
    3740:	92 81       	ldd	r25, Z+2	; 0x02
    3742:	9c 83       	std	Y+4, r25	; 0x04
    3744:	8b 83       	std	Y+3, r24	; 0x03
    3746:	ea 85       	ldd	r30, Y+10	; 0x0a
    3748:	fb 85       	ldd	r31, Y+11	; 0x0b
    374a:	8b 81       	ldd	r24, Y+3	; 0x03
    374c:	9c 81       	ldd	r25, Y+4	; 0x04
    374e:	95 83       	std	Z+5, r25	; 0x05
    3750:	84 83       	std	Z+4, r24	; 0x04
    3752:	eb 81       	ldd	r30, Y+3	; 0x03
    3754:	fc 81       	ldd	r31, Y+4	; 0x04
    3756:	84 81       	ldd	r24, Z+4	; 0x04
    3758:	95 81       	ldd	r25, Z+5	; 0x05
    375a:	ea 85       	ldd	r30, Y+10	; 0x0a
    375c:	fb 85       	ldd	r31, Y+11	; 0x0b
    375e:	97 83       	std	Z+7, r25	; 0x07
    3760:	86 83       	std	Z+6, r24	; 0x06
    3762:	eb 81       	ldd	r30, Y+3	; 0x03
    3764:	fc 81       	ldd	r31, Y+4	; 0x04
    3766:	04 80       	ldd	r0, Z+4	; 0x04
    3768:	f5 81       	ldd	r31, Z+5	; 0x05
    376a:	e0 2d       	mov	r30, r0
    376c:	8a 85       	ldd	r24, Y+10	; 0x0a
    376e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3770:	02 96       	adiw	r24, 0x02	; 2
    3772:	93 83       	std	Z+3, r25	; 0x03
    3774:	82 83       	std	Z+2, r24	; 0x02
    3776:	8a 85       	ldd	r24, Y+10	; 0x0a
    3778:	9b 85       	ldd	r25, Y+11	; 0x0b
    377a:	02 96       	adiw	r24, 0x02	; 2
    377c:	eb 81       	ldd	r30, Y+3	; 0x03
    377e:	fc 81       	ldd	r31, Y+4	; 0x04
    3780:	95 83       	std	Z+5, r25	; 0x05
    3782:	84 83       	std	Z+4, r24	; 0x04
    3784:	ea 85       	ldd	r30, Y+10	; 0x0a
    3786:	fb 85       	ldd	r31, Y+11	; 0x0b
    3788:	86 89       	ldd	r24, Z+22	; 0x16
    378a:	28 2f       	mov	r18, r24
    378c:	30 e0       	ldi	r19, 0x00	; 0
    378e:	c9 01       	movw	r24, r18
    3790:	88 0f       	add	r24, r24
    3792:	99 1f       	adc	r25, r25
    3794:	88 0f       	add	r24, r24
    3796:	99 1f       	adc	r25, r25
    3798:	88 0f       	add	r24, r24
    379a:	99 1f       	adc	r25, r25
    379c:	82 0f       	add	r24, r18
    379e:	93 1f       	adc	r25, r19
    37a0:	82 5a       	subi	r24, 0xA2	; 162
    37a2:	99 4f       	sbci	r25, 0xF9	; 249
    37a4:	ea 85       	ldd	r30, Y+10	; 0x0a
    37a6:	fb 85       	ldd	r31, Y+11	; 0x0b
    37a8:	93 87       	std	Z+11, r25	; 0x0b
    37aa:	82 87       	std	Z+10, r24	; 0x0a
    37ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    37ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    37b0:	86 89       	ldd	r24, Z+22	; 0x16
    37b2:	28 2f       	mov	r18, r24
    37b4:	30 e0       	ldi	r19, 0x00	; 0
    37b6:	c9 01       	movw	r24, r18
    37b8:	88 0f       	add	r24, r24
    37ba:	99 1f       	adc	r25, r25
    37bc:	88 0f       	add	r24, r24
    37be:	99 1f       	adc	r25, r25
    37c0:	88 0f       	add	r24, r24
    37c2:	99 1f       	adc	r25, r25
    37c4:	82 0f       	add	r24, r18
    37c6:	93 1f       	adc	r25, r19
    37c8:	fc 01       	movw	r30, r24
    37ca:	e2 5a       	subi	r30, 0xA2	; 162
    37cc:	f9 4f       	sbci	r31, 0xF9	; 249
    37ce:	80 81       	ld	r24, Z
    37d0:	8f 5f       	subi	r24, 0xFF	; 255
    37d2:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    37d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    37d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    37d8:	96 89       	ldd	r25, Z+22	; 0x16
    37da:	e0 91 4c 06 	lds	r30, 0x064C
    37de:	f0 91 4d 06 	lds	r31, 0x064D
    37e2:	86 89       	ldd	r24, Z+22	; 0x16
    37e4:	98 17       	cp	r25, r24
    37e6:	18 f0       	brcs	.+6      	; 0x37ee <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    37e8:	81 e0       	ldi	r24, 0x01	; 1
    37ea:	80 93 56 06 	sts	0x0656, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    37ee:	80 91 98 06 	lds	r24, 0x0698
    37f2:	88 23       	and	r24, r24
    37f4:	09 f0       	breq	.+2      	; 0x37f8 <xTaskResumeAll+0x230>
    37f6:	08 cf       	rjmp	.-496    	; 0x3608 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    37f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    37fa:	9b 85       	ldd	r25, Y+11	; 0x0b
    37fc:	00 97       	sbiw	r24, 0x00	; 0
    37fe:	11 f0       	breq	.+4      	; 0x3804 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3800:	0e 94 cd 22 	call	0x459a	; 0x459a <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3804:	80 91 54 06 	lds	r24, 0x0654
    3808:	90 91 55 06 	lds	r25, 0x0655
    380c:	9a 83       	std	Y+2, r25	; 0x02
    380e:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    3810:	89 81       	ldd	r24, Y+1	; 0x01
    3812:	9a 81       	ldd	r25, Y+2	; 0x02
    3814:	00 97       	sbiw	r24, 0x00	; 0
    3816:	a1 f0       	breq	.+40     	; 0x3840 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    3818:	0e 94 b6 1c 	call	0x396c	; 0x396c <xTaskIncrementTick>
    381c:	88 23       	and	r24, r24
    381e:	19 f0       	breq	.+6      	; 0x3826 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    3820:	81 e0       	ldi	r24, 0x01	; 1
    3822:	80 93 56 06 	sts	0x0656, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    3826:	89 81       	ldd	r24, Y+1	; 0x01
    3828:	9a 81       	ldd	r25, Y+2	; 0x02
    382a:	01 97       	sbiw	r24, 0x01	; 1
    382c:	9a 83       	std	Y+2, r25	; 0x02
    382e:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3830:	89 81       	ldd	r24, Y+1	; 0x01
    3832:	9a 81       	ldd	r25, Y+2	; 0x02
    3834:	00 97       	sbiw	r24, 0x00	; 0
    3836:	81 f7       	brne	.-32     	; 0x3818 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    3838:	10 92 55 06 	sts	0x0655, r1
    383c:	10 92 54 06 	sts	0x0654, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3840:	80 91 56 06 	lds	r24, 0x0656
    3844:	88 23       	and	r24, r24
    3846:	21 f0       	breq	.+8      	; 0x3850 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
    3848:	81 e0       	ldi	r24, 0x01	; 1
    384a:	89 87       	std	Y+9, r24	; 0x09
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    384c:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3850:	0f 90       	pop	r0
    3852:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    3854:	89 85       	ldd	r24, Y+9	; 0x09
}
    3856:	2b 96       	adiw	r28, 0x0b	; 11
    3858:	0f b6       	in	r0, 0x3f	; 63
    385a:	f8 94       	cli
    385c:	de bf       	out	0x3e, r29	; 62
    385e:	0f be       	out	0x3f, r0	; 63
    3860:	cd bf       	out	0x3d, r28	; 61
    3862:	cf 91       	pop	r28
    3864:	df 91       	pop	r29
    3866:	08 95       	ret

00003868 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3868:	df 93       	push	r29
    386a:	cf 93       	push	r28
    386c:	00 d0       	rcall	.+0      	; 0x386e <xTaskGetTickCount+0x6>
    386e:	cd b7       	in	r28, 0x3d	; 61
    3870:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    3872:	0f b6       	in	r0, 0x3f	; 63
    3874:	f8 94       	cli
    3876:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3878:	80 91 50 06 	lds	r24, 0x0650
    387c:	90 91 51 06 	lds	r25, 0x0651
    3880:	9a 83       	std	Y+2, r25	; 0x02
    3882:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3884:	0f 90       	pop	r0
    3886:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    3888:	89 81       	ldd	r24, Y+1	; 0x01
    388a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    388c:	0f 90       	pop	r0
    388e:	0f 90       	pop	r0
    3890:	cf 91       	pop	r28
    3892:	df 91       	pop	r29
    3894:	08 95       	ret

00003896 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3896:	df 93       	push	r29
    3898:	cf 93       	push	r28
    389a:	00 d0       	rcall	.+0      	; 0x389c <xTaskGetTickCountFromISR+0x6>
    389c:	0f 92       	push	r0
    389e:	cd b7       	in	r28, 0x3d	; 61
    38a0:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    38a2:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    38a4:	80 91 50 06 	lds	r24, 0x0650
    38a8:	90 91 51 06 	lds	r25, 0x0651
    38ac:	9b 83       	std	Y+3, r25	; 0x03
    38ae:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    38b0:	8a 81       	ldd	r24, Y+2	; 0x02
    38b2:	9b 81       	ldd	r25, Y+3	; 0x03
}
    38b4:	0f 90       	pop	r0
    38b6:	0f 90       	pop	r0
    38b8:	0f 90       	pop	r0
    38ba:	cf 91       	pop	r28
    38bc:	df 91       	pop	r29
    38be:	08 95       	ret

000038c0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    38c0:	df 93       	push	r29
    38c2:	cf 93       	push	r28
    38c4:	cd b7       	in	r28, 0x3d	; 61
    38c6:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    38c8:	80 91 4f 06 	lds	r24, 0x064F
}
    38cc:	cf 91       	pop	r28
    38ce:	df 91       	pop	r29
    38d0:	08 95       	ret

000038d2 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    38d2:	df 93       	push	r29
    38d4:	cf 93       	push	r28
    38d6:	00 d0       	rcall	.+0      	; 0x38d8 <pcTaskGetName+0x6>
    38d8:	00 d0       	rcall	.+0      	; 0x38da <pcTaskGetName+0x8>
    38da:	00 d0       	rcall	.+0      	; 0x38dc <pcTaskGetName+0xa>
    38dc:	cd b7       	in	r28, 0x3d	; 61
    38de:	de b7       	in	r29, 0x3e	; 62
    38e0:	9c 83       	std	Y+4, r25	; 0x04
    38e2:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    38e4:	8b 81       	ldd	r24, Y+3	; 0x03
    38e6:	9c 81       	ldd	r25, Y+4	; 0x04
    38e8:	00 97       	sbiw	r24, 0x00	; 0
    38ea:	39 f4       	brne	.+14     	; 0x38fa <pcTaskGetName+0x28>
    38ec:	80 91 4c 06 	lds	r24, 0x064C
    38f0:	90 91 4d 06 	lds	r25, 0x064D
    38f4:	9e 83       	std	Y+6, r25	; 0x06
    38f6:	8d 83       	std	Y+5, r24	; 0x05
    38f8:	04 c0       	rjmp	.+8      	; 0x3902 <pcTaskGetName+0x30>
    38fa:	8b 81       	ldd	r24, Y+3	; 0x03
    38fc:	9c 81       	ldd	r25, Y+4	; 0x04
    38fe:	9e 83       	std	Y+6, r25	; 0x06
    3900:	8d 83       	std	Y+5, r24	; 0x05
    3902:	8d 81       	ldd	r24, Y+5	; 0x05
    3904:	9e 81       	ldd	r25, Y+6	; 0x06
    3906:	9a 83       	std	Y+2, r25	; 0x02
    3908:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    390a:	89 81       	ldd	r24, Y+1	; 0x01
    390c:	9a 81       	ldd	r25, Y+2	; 0x02
    390e:	49 96       	adiw	r24, 0x19	; 25
}
    3910:	26 96       	adiw	r28, 0x06	; 6
    3912:	0f b6       	in	r0, 0x3f	; 63
    3914:	f8 94       	cli
    3916:	de bf       	out	0x3e, r29	; 62
    3918:	0f be       	out	0x3f, r0	; 63
    391a:	cd bf       	out	0x3d, r28	; 61
    391c:	cf 91       	pop	r28
    391e:	df 91       	pop	r29
    3920:	08 95       	ret

00003922 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    3922:	df 93       	push	r29
    3924:	cf 93       	push	r28
    3926:	00 d0       	rcall	.+0      	; 0x3928 <xTaskCatchUpTicks+0x6>
    3928:	0f 92       	push	r0
    392a:	cd b7       	in	r28, 0x3d	; 61
    392c:	de b7       	in	r29, 0x3e	; 62
    392e:	9b 83       	std	Y+3, r25	; 0x03
    3930:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    3932:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    3936:	0f b6       	in	r0, 0x3f	; 63
    3938:	f8 94       	cli
    393a:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    393c:	20 91 54 06 	lds	r18, 0x0654
    3940:	30 91 55 06 	lds	r19, 0x0655
    3944:	8a 81       	ldd	r24, Y+2	; 0x02
    3946:	9b 81       	ldd	r25, Y+3	; 0x03
    3948:	82 0f       	add	r24, r18
    394a:	93 1f       	adc	r25, r19
    394c:	90 93 55 06 	sts	0x0655, r25
    3950:	80 93 54 06 	sts	0x0654, r24
    }
    taskEXIT_CRITICAL();
    3954:	0f 90       	pop	r0
    3956:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    3958:	0e 94 e4 1a 	call	0x35c8	; 0x35c8 <xTaskResumeAll>
    395c:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    395e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3960:	0f 90       	pop	r0
    3962:	0f 90       	pop	r0
    3964:	0f 90       	pop	r0
    3966:	cf 91       	pop	r28
    3968:	df 91       	pop	r29
    396a:	08 95       	ret

0000396c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    396c:	df 93       	push	r29
    396e:	cf 93       	push	r28
    3970:	cd b7       	in	r28, 0x3d	; 61
    3972:	de b7       	in	r29, 0x3e	; 62
    3974:	2f 97       	sbiw	r28, 0x0f	; 15
    3976:	0f b6       	in	r0, 0x3f	; 63
    3978:	f8 94       	cli
    397a:	de bf       	out	0x3e, r29	; 62
    397c:	0f be       	out	0x3f, r0	; 63
    397e:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    3980:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3982:	80 91 5d 06 	lds	r24, 0x065D
    3986:	88 23       	and	r24, r24
    3988:	09 f0       	breq	.+2      	; 0x398c <xTaskIncrementTick+0x20>
    398a:	74 c1       	rjmp	.+744    	; 0x3c74 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    398c:	80 91 50 06 	lds	r24, 0x0650
    3990:	90 91 51 06 	lds	r25, 0x0651
    3994:	01 96       	adiw	r24, 0x01	; 1
    3996:	9a 87       	std	Y+10, r25	; 0x0a
    3998:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    399a:	89 85       	ldd	r24, Y+9	; 0x09
    399c:	9a 85       	ldd	r25, Y+10	; 0x0a
    399e:	90 93 51 06 	sts	0x0651, r25
    39a2:	80 93 50 06 	sts	0x0650, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    39a6:	89 85       	ldd	r24, Y+9	; 0x09
    39a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    39aa:	00 97       	sbiw	r24, 0x00	; 0
    39ac:	d9 f4       	brne	.+54     	; 0x39e4 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    39ae:	80 91 94 06 	lds	r24, 0x0694
    39b2:	90 91 95 06 	lds	r25, 0x0695
    39b6:	98 87       	std	Y+8, r25	; 0x08
    39b8:	8f 83       	std	Y+7, r24	; 0x07
    39ba:	80 91 96 06 	lds	r24, 0x0696
    39be:	90 91 97 06 	lds	r25, 0x0697
    39c2:	90 93 95 06 	sts	0x0695, r25
    39c6:	80 93 94 06 	sts	0x0694, r24
    39ca:	8f 81       	ldd	r24, Y+7	; 0x07
    39cc:	98 85       	ldd	r25, Y+8	; 0x08
    39ce:	90 93 97 06 	sts	0x0697, r25
    39d2:	80 93 96 06 	sts	0x0696, r24
    39d6:	80 91 57 06 	lds	r24, 0x0657
    39da:	8f 5f       	subi	r24, 0xFF	; 255
    39dc:	80 93 57 06 	sts	0x0657, r24
    39e0:	0e 94 cd 22 	call	0x459a	; 0x459a <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    39e4:	20 91 59 06 	lds	r18, 0x0659
    39e8:	30 91 5a 06 	lds	r19, 0x065A
    39ec:	89 85       	ldd	r24, Y+9	; 0x09
    39ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    39f0:	82 17       	cp	r24, r18
    39f2:	93 07       	cpc	r25, r19
    39f4:	08 f4       	brcc	.+2      	; 0x39f8 <xTaskIncrementTick+0x8c>
    39f6:	1f c1       	rjmp	.+574    	; 0x3c36 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    39f8:	e0 91 94 06 	lds	r30, 0x0694
    39fc:	f0 91 95 06 	lds	r31, 0x0695
    3a00:	80 81       	ld	r24, Z
    3a02:	88 23       	and	r24, r24
    3a04:	39 f4       	brne	.+14     	; 0x3a14 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3a06:	8f ef       	ldi	r24, 0xFF	; 255
    3a08:	9f ef       	ldi	r25, 0xFF	; 255
    3a0a:	90 93 5a 06 	sts	0x065A, r25
    3a0e:	80 93 59 06 	sts	0x0659, r24
    3a12:	11 c1       	rjmp	.+546    	; 0x3c36 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3a14:	e0 91 94 06 	lds	r30, 0x0694
    3a18:	f0 91 95 06 	lds	r31, 0x0695
    3a1c:	05 80       	ldd	r0, Z+5	; 0x05
    3a1e:	f6 81       	ldd	r31, Z+6	; 0x06
    3a20:	e0 2d       	mov	r30, r0
    3a22:	86 81       	ldd	r24, Z+6	; 0x06
    3a24:	97 81       	ldd	r25, Z+7	; 0x07
    3a26:	9f 87       	std	Y+15, r25	; 0x0f
    3a28:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3a2a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a2c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a2e:	82 81       	ldd	r24, Z+2	; 0x02
    3a30:	93 81       	ldd	r25, Z+3	; 0x03
    3a32:	9d 87       	std	Y+13, r25	; 0x0d
    3a34:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    3a36:	29 85       	ldd	r18, Y+9	; 0x09
    3a38:	3a 85       	ldd	r19, Y+10	; 0x0a
    3a3a:	8c 85       	ldd	r24, Y+12	; 0x0c
    3a3c:	9d 85       	ldd	r25, Y+13	; 0x0d
    3a3e:	28 17       	cp	r18, r24
    3a40:	39 07       	cpc	r19, r25
    3a42:	38 f4       	brcc	.+14     	; 0x3a52 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    3a44:	8c 85       	ldd	r24, Y+12	; 0x0c
    3a46:	9d 85       	ldd	r25, Y+13	; 0x0d
    3a48:	90 93 5a 06 	sts	0x065A, r25
    3a4c:	80 93 59 06 	sts	0x0659, r24
    3a50:	f2 c0       	rjmp	.+484    	; 0x3c36 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3a52:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a54:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a56:	82 85       	ldd	r24, Z+10	; 0x0a
    3a58:	93 85       	ldd	r25, Z+11	; 0x0b
    3a5a:	9e 83       	std	Y+6, r25	; 0x06
    3a5c:	8d 83       	std	Y+5, r24	; 0x05
    3a5e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a60:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a62:	a4 81       	ldd	r26, Z+4	; 0x04
    3a64:	b5 81       	ldd	r27, Z+5	; 0x05
    3a66:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a68:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a6a:	86 81       	ldd	r24, Z+6	; 0x06
    3a6c:	97 81       	ldd	r25, Z+7	; 0x07
    3a6e:	15 96       	adiw	r26, 0x05	; 5
    3a70:	9c 93       	st	X, r25
    3a72:	8e 93       	st	-X, r24
    3a74:	14 97       	sbiw	r26, 0x04	; 4
    3a76:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a78:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a7a:	a6 81       	ldd	r26, Z+6	; 0x06
    3a7c:	b7 81       	ldd	r27, Z+7	; 0x07
    3a7e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a80:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a82:	84 81       	ldd	r24, Z+4	; 0x04
    3a84:	95 81       	ldd	r25, Z+5	; 0x05
    3a86:	13 96       	adiw	r26, 0x03	; 3
    3a88:	9c 93       	st	X, r25
    3a8a:	8e 93       	st	-X, r24
    3a8c:	12 97       	sbiw	r26, 0x02	; 2
    3a8e:	ed 81       	ldd	r30, Y+5	; 0x05
    3a90:	fe 81       	ldd	r31, Y+6	; 0x06
    3a92:	21 81       	ldd	r18, Z+1	; 0x01
    3a94:	32 81       	ldd	r19, Z+2	; 0x02
    3a96:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a98:	9f 85       	ldd	r25, Y+15	; 0x0f
    3a9a:	02 96       	adiw	r24, 0x02	; 2
    3a9c:	28 17       	cp	r18, r24
    3a9e:	39 07       	cpc	r19, r25
    3aa0:	41 f4       	brne	.+16     	; 0x3ab2 <xTaskIncrementTick+0x146>
    3aa2:	ee 85       	ldd	r30, Y+14	; 0x0e
    3aa4:	ff 85       	ldd	r31, Y+15	; 0x0f
    3aa6:	86 81       	ldd	r24, Z+6	; 0x06
    3aa8:	97 81       	ldd	r25, Z+7	; 0x07
    3aaa:	ed 81       	ldd	r30, Y+5	; 0x05
    3aac:	fe 81       	ldd	r31, Y+6	; 0x06
    3aae:	92 83       	std	Z+2, r25	; 0x02
    3ab0:	81 83       	std	Z+1, r24	; 0x01
    3ab2:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ab4:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ab6:	13 86       	std	Z+11, r1	; 0x0b
    3ab8:	12 86       	std	Z+10, r1	; 0x0a
    3aba:	ed 81       	ldd	r30, Y+5	; 0x05
    3abc:	fe 81       	ldd	r31, Y+6	; 0x06
    3abe:	80 81       	ld	r24, Z
    3ac0:	81 50       	subi	r24, 0x01	; 1
    3ac2:	ed 81       	ldd	r30, Y+5	; 0x05
    3ac4:	fe 81       	ldd	r31, Y+6	; 0x06
    3ac6:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3ac8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3aca:	ff 85       	ldd	r31, Y+15	; 0x0f
    3acc:	84 89       	ldd	r24, Z+20	; 0x14
    3ace:	95 89       	ldd	r25, Z+21	; 0x15
    3ad0:	00 97       	sbiw	r24, 0x00	; 0
    3ad2:	d9 f1       	breq	.+118    	; 0x3b4a <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3ad4:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ad6:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ad8:	84 89       	ldd	r24, Z+20	; 0x14
    3ada:	95 89       	ldd	r25, Z+21	; 0x15
    3adc:	9c 83       	std	Y+4, r25	; 0x04
    3ade:	8b 83       	std	Y+3, r24	; 0x03
    3ae0:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ae2:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ae4:	a6 85       	ldd	r26, Z+14	; 0x0e
    3ae6:	b7 85       	ldd	r27, Z+15	; 0x0f
    3ae8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3aea:	ff 85       	ldd	r31, Y+15	; 0x0f
    3aec:	80 89       	ldd	r24, Z+16	; 0x10
    3aee:	91 89       	ldd	r25, Z+17	; 0x11
    3af0:	15 96       	adiw	r26, 0x05	; 5
    3af2:	9c 93       	st	X, r25
    3af4:	8e 93       	st	-X, r24
    3af6:	14 97       	sbiw	r26, 0x04	; 4
    3af8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3afa:	ff 85       	ldd	r31, Y+15	; 0x0f
    3afc:	a0 89       	ldd	r26, Z+16	; 0x10
    3afe:	b1 89       	ldd	r27, Z+17	; 0x11
    3b00:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b02:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b04:	86 85       	ldd	r24, Z+14	; 0x0e
    3b06:	97 85       	ldd	r25, Z+15	; 0x0f
    3b08:	13 96       	adiw	r26, 0x03	; 3
    3b0a:	9c 93       	st	X, r25
    3b0c:	8e 93       	st	-X, r24
    3b0e:	12 97       	sbiw	r26, 0x02	; 2
    3b10:	eb 81       	ldd	r30, Y+3	; 0x03
    3b12:	fc 81       	ldd	r31, Y+4	; 0x04
    3b14:	21 81       	ldd	r18, Z+1	; 0x01
    3b16:	32 81       	ldd	r19, Z+2	; 0x02
    3b18:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b1a:	9f 85       	ldd	r25, Y+15	; 0x0f
    3b1c:	0c 96       	adiw	r24, 0x0c	; 12
    3b1e:	28 17       	cp	r18, r24
    3b20:	39 07       	cpc	r19, r25
    3b22:	41 f4       	brne	.+16     	; 0x3b34 <xTaskIncrementTick+0x1c8>
    3b24:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b26:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b28:	80 89       	ldd	r24, Z+16	; 0x10
    3b2a:	91 89       	ldd	r25, Z+17	; 0x11
    3b2c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b2e:	fc 81       	ldd	r31, Y+4	; 0x04
    3b30:	92 83       	std	Z+2, r25	; 0x02
    3b32:	81 83       	std	Z+1, r24	; 0x01
    3b34:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b36:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b38:	15 8a       	std	Z+21, r1	; 0x15
    3b3a:	14 8a       	std	Z+20, r1	; 0x14
    3b3c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b3e:	fc 81       	ldd	r31, Y+4	; 0x04
    3b40:	80 81       	ld	r24, Z
    3b42:	81 50       	subi	r24, 0x01	; 1
    3b44:	eb 81       	ldd	r30, Y+3	; 0x03
    3b46:	fc 81       	ldd	r31, Y+4	; 0x04
    3b48:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    3b4a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b4c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b4e:	96 89       	ldd	r25, Z+22	; 0x16
    3b50:	80 91 52 06 	lds	r24, 0x0652
    3b54:	89 17       	cp	r24, r25
    3b56:	28 f4       	brcc	.+10     	; 0x3b62 <xTaskIncrementTick+0x1f6>
    3b58:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b5a:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b5c:	86 89       	ldd	r24, Z+22	; 0x16
    3b5e:	80 93 52 06 	sts	0x0652, r24
    3b62:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b64:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b66:	86 89       	ldd	r24, Z+22	; 0x16
    3b68:	28 2f       	mov	r18, r24
    3b6a:	30 e0       	ldi	r19, 0x00	; 0
    3b6c:	c9 01       	movw	r24, r18
    3b6e:	88 0f       	add	r24, r24
    3b70:	99 1f       	adc	r25, r25
    3b72:	88 0f       	add	r24, r24
    3b74:	99 1f       	adc	r25, r25
    3b76:	88 0f       	add	r24, r24
    3b78:	99 1f       	adc	r25, r25
    3b7a:	82 0f       	add	r24, r18
    3b7c:	93 1f       	adc	r25, r19
    3b7e:	fc 01       	movw	r30, r24
    3b80:	e2 5a       	subi	r30, 0xA2	; 162
    3b82:	f9 4f       	sbci	r31, 0xF9	; 249
    3b84:	81 81       	ldd	r24, Z+1	; 0x01
    3b86:	92 81       	ldd	r25, Z+2	; 0x02
    3b88:	9a 83       	std	Y+2, r25	; 0x02
    3b8a:	89 83       	std	Y+1, r24	; 0x01
    3b8c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b8e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b90:	89 81       	ldd	r24, Y+1	; 0x01
    3b92:	9a 81       	ldd	r25, Y+2	; 0x02
    3b94:	95 83       	std	Z+5, r25	; 0x05
    3b96:	84 83       	std	Z+4, r24	; 0x04
    3b98:	e9 81       	ldd	r30, Y+1	; 0x01
    3b9a:	fa 81       	ldd	r31, Y+2	; 0x02
    3b9c:	84 81       	ldd	r24, Z+4	; 0x04
    3b9e:	95 81       	ldd	r25, Z+5	; 0x05
    3ba0:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ba2:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ba4:	97 83       	std	Z+7, r25	; 0x07
    3ba6:	86 83       	std	Z+6, r24	; 0x06
    3ba8:	e9 81       	ldd	r30, Y+1	; 0x01
    3baa:	fa 81       	ldd	r31, Y+2	; 0x02
    3bac:	04 80       	ldd	r0, Z+4	; 0x04
    3bae:	f5 81       	ldd	r31, Z+5	; 0x05
    3bb0:	e0 2d       	mov	r30, r0
    3bb2:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bb4:	9f 85       	ldd	r25, Y+15	; 0x0f
    3bb6:	02 96       	adiw	r24, 0x02	; 2
    3bb8:	93 83       	std	Z+3, r25	; 0x03
    3bba:	82 83       	std	Z+2, r24	; 0x02
    3bbc:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bbe:	9f 85       	ldd	r25, Y+15	; 0x0f
    3bc0:	02 96       	adiw	r24, 0x02	; 2
    3bc2:	e9 81       	ldd	r30, Y+1	; 0x01
    3bc4:	fa 81       	ldd	r31, Y+2	; 0x02
    3bc6:	95 83       	std	Z+5, r25	; 0x05
    3bc8:	84 83       	std	Z+4, r24	; 0x04
    3bca:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bcc:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bce:	86 89       	ldd	r24, Z+22	; 0x16
    3bd0:	28 2f       	mov	r18, r24
    3bd2:	30 e0       	ldi	r19, 0x00	; 0
    3bd4:	c9 01       	movw	r24, r18
    3bd6:	88 0f       	add	r24, r24
    3bd8:	99 1f       	adc	r25, r25
    3bda:	88 0f       	add	r24, r24
    3bdc:	99 1f       	adc	r25, r25
    3bde:	88 0f       	add	r24, r24
    3be0:	99 1f       	adc	r25, r25
    3be2:	82 0f       	add	r24, r18
    3be4:	93 1f       	adc	r25, r19
    3be6:	82 5a       	subi	r24, 0xA2	; 162
    3be8:	99 4f       	sbci	r25, 0xF9	; 249
    3bea:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bec:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bee:	93 87       	std	Z+11, r25	; 0x0b
    3bf0:	82 87       	std	Z+10, r24	; 0x0a
    3bf2:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bf4:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bf6:	86 89       	ldd	r24, Z+22	; 0x16
    3bf8:	28 2f       	mov	r18, r24
    3bfa:	30 e0       	ldi	r19, 0x00	; 0
    3bfc:	c9 01       	movw	r24, r18
    3bfe:	88 0f       	add	r24, r24
    3c00:	99 1f       	adc	r25, r25
    3c02:	88 0f       	add	r24, r24
    3c04:	99 1f       	adc	r25, r25
    3c06:	88 0f       	add	r24, r24
    3c08:	99 1f       	adc	r25, r25
    3c0a:	82 0f       	add	r24, r18
    3c0c:	93 1f       	adc	r25, r19
    3c0e:	fc 01       	movw	r30, r24
    3c10:	e2 5a       	subi	r30, 0xA2	; 162
    3c12:	f9 4f       	sbci	r31, 0xF9	; 249
    3c14:	80 81       	ld	r24, Z
    3c16:	8f 5f       	subi	r24, 0xFF	; 255
    3c18:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3c1a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c1c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c1e:	96 89       	ldd	r25, Z+22	; 0x16
    3c20:	e0 91 4c 06 	lds	r30, 0x064C
    3c24:	f0 91 4d 06 	lds	r31, 0x064D
    3c28:	86 89       	ldd	r24, Z+22	; 0x16
    3c2a:	89 17       	cp	r24, r25
    3c2c:	08 f0       	brcs	.+2      	; 0x3c30 <xTaskIncrementTick+0x2c4>
    3c2e:	e4 ce       	rjmp	.-568    	; 0x39f8 <xTaskIncrementTick+0x8c>
                        {
                            xSwitchRequired = pdTRUE;
    3c30:	81 e0       	ldi	r24, 0x01	; 1
    3c32:	8b 87       	std	Y+11, r24	; 0x0b
    3c34:	e1 ce       	rjmp	.-574    	; 0x39f8 <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3c36:	e0 91 4c 06 	lds	r30, 0x064C
    3c3a:	f0 91 4d 06 	lds	r31, 0x064D
    3c3e:	86 89       	ldd	r24, Z+22	; 0x16
    3c40:	28 2f       	mov	r18, r24
    3c42:	30 e0       	ldi	r19, 0x00	; 0
    3c44:	c9 01       	movw	r24, r18
    3c46:	88 0f       	add	r24, r24
    3c48:	99 1f       	adc	r25, r25
    3c4a:	88 0f       	add	r24, r24
    3c4c:	99 1f       	adc	r25, r25
    3c4e:	88 0f       	add	r24, r24
    3c50:	99 1f       	adc	r25, r25
    3c52:	82 0f       	add	r24, r18
    3c54:	93 1f       	adc	r25, r19
    3c56:	fc 01       	movw	r30, r24
    3c58:	e2 5a       	subi	r30, 0xA2	; 162
    3c5a:	f9 4f       	sbci	r31, 0xF9	; 249
    3c5c:	80 81       	ld	r24, Z
    3c5e:	82 30       	cpi	r24, 0x02	; 2
    3c60:	10 f0       	brcs	.+4      	; 0x3c66 <xTaskIncrementTick+0x2fa>
            {
                xSwitchRequired = pdTRUE;
    3c62:	81 e0       	ldi	r24, 0x01	; 1
    3c64:	8b 87       	std	Y+11, r24	; 0x0b
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    3c66:	80 91 56 06 	lds	r24, 0x0656
    3c6a:	88 23       	and	r24, r24
    3c6c:	61 f0       	breq	.+24     	; 0x3c86 <xTaskIncrementTick+0x31a>
            {
                xSwitchRequired = pdTRUE;
    3c6e:	81 e0       	ldi	r24, 0x01	; 1
    3c70:	8b 87       	std	Y+11, r24	; 0x0b
    3c72:	09 c0       	rjmp	.+18     	; 0x3c86 <xTaskIncrementTick+0x31a>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    3c74:	80 91 54 06 	lds	r24, 0x0654
    3c78:	90 91 55 06 	lds	r25, 0x0655
    3c7c:	01 96       	adiw	r24, 0x01	; 1
    3c7e:	90 93 55 06 	sts	0x0655, r25
    3c82:	80 93 54 06 	sts	0x0654, r24
            vApplicationTickHook();
        }
        #endif
    }

    return xSwitchRequired;
    3c86:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    3c88:	2f 96       	adiw	r28, 0x0f	; 15
    3c8a:	0f b6       	in	r0, 0x3f	; 63
    3c8c:	f8 94       	cli
    3c8e:	de bf       	out	0x3e, r29	; 62
    3c90:	0f be       	out	0x3f, r0	; 63
    3c92:	cd bf       	out	0x3d, r28	; 61
    3c94:	cf 91       	pop	r28
    3c96:	df 91       	pop	r29
    3c98:	08 95       	ret

00003c9a <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3c9a:	df 93       	push	r29
    3c9c:	cf 93       	push	r28
    3c9e:	00 d0       	rcall	.+0      	; 0x3ca0 <vTaskSwitchContext+0x6>
    3ca0:	0f 92       	push	r0
    3ca2:	cd b7       	in	r28, 0x3d	; 61
    3ca4:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3ca6:	80 91 5d 06 	lds	r24, 0x065D
    3caa:	88 23       	and	r24, r24
    3cac:	21 f0       	breq	.+8      	; 0x3cb6 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    3cae:	81 e0       	ldi	r24, 0x01	; 1
    3cb0:	80 93 56 06 	sts	0x0656, r24
    3cb4:	59 c0       	rjmp	.+178    	; 0x3d68 <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    3cb6:	10 92 56 06 	sts	0x0656, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3cba:	80 91 52 06 	lds	r24, 0x0652
    3cbe:	8b 83       	std	Y+3, r24	; 0x03
    3cc0:	03 c0       	rjmp	.+6      	; 0x3cc8 <vTaskSwitchContext+0x2e>
    3cc2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc4:	81 50       	subi	r24, 0x01	; 1
    3cc6:	8b 83       	std	Y+3, r24	; 0x03
    3cc8:	8b 81       	ldd	r24, Y+3	; 0x03
    3cca:	28 2f       	mov	r18, r24
    3ccc:	30 e0       	ldi	r19, 0x00	; 0
    3cce:	c9 01       	movw	r24, r18
    3cd0:	88 0f       	add	r24, r24
    3cd2:	99 1f       	adc	r25, r25
    3cd4:	88 0f       	add	r24, r24
    3cd6:	99 1f       	adc	r25, r25
    3cd8:	88 0f       	add	r24, r24
    3cda:	99 1f       	adc	r25, r25
    3cdc:	82 0f       	add	r24, r18
    3cde:	93 1f       	adc	r25, r19
    3ce0:	fc 01       	movw	r30, r24
    3ce2:	e2 5a       	subi	r30, 0xA2	; 162
    3ce4:	f9 4f       	sbci	r31, 0xF9	; 249
    3ce6:	80 81       	ld	r24, Z
    3ce8:	88 23       	and	r24, r24
    3cea:	59 f3       	breq	.-42     	; 0x3cc2 <vTaskSwitchContext+0x28>
    3cec:	8b 81       	ldd	r24, Y+3	; 0x03
    3cee:	28 2f       	mov	r18, r24
    3cf0:	30 e0       	ldi	r19, 0x00	; 0
    3cf2:	c9 01       	movw	r24, r18
    3cf4:	88 0f       	add	r24, r24
    3cf6:	99 1f       	adc	r25, r25
    3cf8:	88 0f       	add	r24, r24
    3cfa:	99 1f       	adc	r25, r25
    3cfc:	88 0f       	add	r24, r24
    3cfe:	99 1f       	adc	r25, r25
    3d00:	82 0f       	add	r24, r18
    3d02:	93 1f       	adc	r25, r19
    3d04:	82 5a       	subi	r24, 0xA2	; 162
    3d06:	99 4f       	sbci	r25, 0xF9	; 249
    3d08:	9a 83       	std	Y+2, r25	; 0x02
    3d0a:	89 83       	std	Y+1, r24	; 0x01
    3d0c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d0e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d10:	01 80       	ldd	r0, Z+1	; 0x01
    3d12:	f2 81       	ldd	r31, Z+2	; 0x02
    3d14:	e0 2d       	mov	r30, r0
    3d16:	82 81       	ldd	r24, Z+2	; 0x02
    3d18:	93 81       	ldd	r25, Z+3	; 0x03
    3d1a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d1c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d1e:	92 83       	std	Z+2, r25	; 0x02
    3d20:	81 83       	std	Z+1, r24	; 0x01
    3d22:	e9 81       	ldd	r30, Y+1	; 0x01
    3d24:	fa 81       	ldd	r31, Y+2	; 0x02
    3d26:	21 81       	ldd	r18, Z+1	; 0x01
    3d28:	32 81       	ldd	r19, Z+2	; 0x02
    3d2a:	89 81       	ldd	r24, Y+1	; 0x01
    3d2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d2e:	03 96       	adiw	r24, 0x03	; 3
    3d30:	28 17       	cp	r18, r24
    3d32:	39 07       	cpc	r19, r25
    3d34:	59 f4       	brne	.+22     	; 0x3d4c <vTaskSwitchContext+0xb2>
    3d36:	e9 81       	ldd	r30, Y+1	; 0x01
    3d38:	fa 81       	ldd	r31, Y+2	; 0x02
    3d3a:	01 80       	ldd	r0, Z+1	; 0x01
    3d3c:	f2 81       	ldd	r31, Z+2	; 0x02
    3d3e:	e0 2d       	mov	r30, r0
    3d40:	82 81       	ldd	r24, Z+2	; 0x02
    3d42:	93 81       	ldd	r25, Z+3	; 0x03
    3d44:	e9 81       	ldd	r30, Y+1	; 0x01
    3d46:	fa 81       	ldd	r31, Y+2	; 0x02
    3d48:	92 83       	std	Z+2, r25	; 0x02
    3d4a:	81 83       	std	Z+1, r24	; 0x01
    3d4c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d4e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d50:	01 80       	ldd	r0, Z+1	; 0x01
    3d52:	f2 81       	ldd	r31, Z+2	; 0x02
    3d54:	e0 2d       	mov	r30, r0
    3d56:	86 81       	ldd	r24, Z+6	; 0x06
    3d58:	97 81       	ldd	r25, Z+7	; 0x07
    3d5a:	90 93 4d 06 	sts	0x064D, r25
    3d5e:	80 93 4c 06 	sts	0x064C, r24
    3d62:	8b 81       	ldd	r24, Y+3	; 0x03
    3d64:	80 93 52 06 	sts	0x0652, r24
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
    3d68:	0f 90       	pop	r0
    3d6a:	0f 90       	pop	r0
    3d6c:	0f 90       	pop	r0
    3d6e:	cf 91       	pop	r28
    3d70:	df 91       	pop	r29
    3d72:	08 95       	ret

00003d74 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    3d74:	df 93       	push	r29
    3d76:	cf 93       	push	r28
    3d78:	00 d0       	rcall	.+0      	; 0x3d7a <vTaskPlaceOnEventList+0x6>
    3d7a:	00 d0       	rcall	.+0      	; 0x3d7c <vTaskPlaceOnEventList+0x8>
    3d7c:	cd b7       	in	r28, 0x3d	; 61
    3d7e:	de b7       	in	r29, 0x3e	; 62
    3d80:	9a 83       	std	Y+2, r25	; 0x02
    3d82:	89 83       	std	Y+1, r24	; 0x01
    3d84:	7c 83       	std	Y+4, r23	; 0x04
    3d86:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3d88:	80 91 4c 06 	lds	r24, 0x064C
    3d8c:	90 91 4d 06 	lds	r25, 0x064D
    3d90:	9c 01       	movw	r18, r24
    3d92:	24 5f       	subi	r18, 0xF4	; 244
    3d94:	3f 4f       	sbci	r19, 0xFF	; 255
    3d96:	89 81       	ldd	r24, Y+1	; 0x01
    3d98:	9a 81       	ldd	r25, Y+2	; 0x02
    3d9a:	b9 01       	movw	r22, r18
    3d9c:	0e 94 60 07 	call	0xec0	; 0xec0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3da0:	8b 81       	ldd	r24, Y+3	; 0x03
    3da2:	9c 81       	ldd	r25, Y+4	; 0x04
    3da4:	61 e0       	ldi	r22, 0x01	; 1
    3da6:	0e 94 ad 2a 	call	0x555a	; 0x555a <prvAddCurrentTaskToDelayedList>
}
    3daa:	0f 90       	pop	r0
    3dac:	0f 90       	pop	r0
    3dae:	0f 90       	pop	r0
    3db0:	0f 90       	pop	r0
    3db2:	cf 91       	pop	r28
    3db4:	df 91       	pop	r29
    3db6:	08 95       	ret

00003db8 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    3db8:	df 93       	push	r29
    3dba:	cf 93       	push	r28
    3dbc:	cd b7       	in	r28, 0x3d	; 61
    3dbe:	de b7       	in	r29, 0x3e	; 62
    3dc0:	28 97       	sbiw	r28, 0x08	; 8
    3dc2:	0f b6       	in	r0, 0x3f	; 63
    3dc4:	f8 94       	cli
    3dc6:	de bf       	out	0x3e, r29	; 62
    3dc8:	0f be       	out	0x3f, r0	; 63
    3dca:	cd bf       	out	0x3d, r28	; 61
    3dcc:	9c 83       	std	Y+4, r25	; 0x04
    3dce:	8b 83       	std	Y+3, r24	; 0x03
    3dd0:	7e 83       	std	Y+6, r23	; 0x06
    3dd2:	6d 83       	std	Y+5, r22	; 0x05
    3dd4:	58 87       	std	Y+8, r21	; 0x08
    3dd6:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3dd8:	e0 91 4c 06 	lds	r30, 0x064C
    3ddc:	f0 91 4d 06 	lds	r31, 0x064D
    3de0:	8d 81       	ldd	r24, Y+5	; 0x05
    3de2:	9e 81       	ldd	r25, Y+6	; 0x06
    3de4:	90 68       	ori	r25, 0x80	; 128
    3de6:	95 87       	std	Z+13, r25	; 0x0d
    3de8:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3dea:	eb 81       	ldd	r30, Y+3	; 0x03
    3dec:	fc 81       	ldd	r31, Y+4	; 0x04
    3dee:	81 81       	ldd	r24, Z+1	; 0x01
    3df0:	92 81       	ldd	r25, Z+2	; 0x02
    3df2:	9a 83       	std	Y+2, r25	; 0x02
    3df4:	89 83       	std	Y+1, r24	; 0x01
    3df6:	e0 91 4c 06 	lds	r30, 0x064C
    3dfa:	f0 91 4d 06 	lds	r31, 0x064D
    3dfe:	89 81       	ldd	r24, Y+1	; 0x01
    3e00:	9a 81       	ldd	r25, Y+2	; 0x02
    3e02:	97 87       	std	Z+15, r25	; 0x0f
    3e04:	86 87       	std	Z+14, r24	; 0x0e
    3e06:	a0 91 4c 06 	lds	r26, 0x064C
    3e0a:	b0 91 4d 06 	lds	r27, 0x064D
    3e0e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e10:	fa 81       	ldd	r31, Y+2	; 0x02
    3e12:	84 81       	ldd	r24, Z+4	; 0x04
    3e14:	95 81       	ldd	r25, Z+5	; 0x05
    3e16:	51 96       	adiw	r26, 0x11	; 17
    3e18:	9c 93       	st	X, r25
    3e1a:	8e 93       	st	-X, r24
    3e1c:	50 97       	sbiw	r26, 0x10	; 16
    3e1e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e20:	fa 81       	ldd	r31, Y+2	; 0x02
    3e22:	04 80       	ldd	r0, Z+4	; 0x04
    3e24:	f5 81       	ldd	r31, Z+5	; 0x05
    3e26:	e0 2d       	mov	r30, r0
    3e28:	80 91 4c 06 	lds	r24, 0x064C
    3e2c:	90 91 4d 06 	lds	r25, 0x064D
    3e30:	0c 96       	adiw	r24, 0x0c	; 12
    3e32:	93 83       	std	Z+3, r25	; 0x03
    3e34:	82 83       	std	Z+2, r24	; 0x02
    3e36:	80 91 4c 06 	lds	r24, 0x064C
    3e3a:	90 91 4d 06 	lds	r25, 0x064D
    3e3e:	0c 96       	adiw	r24, 0x0c	; 12
    3e40:	e9 81       	ldd	r30, Y+1	; 0x01
    3e42:	fa 81       	ldd	r31, Y+2	; 0x02
    3e44:	95 83       	std	Z+5, r25	; 0x05
    3e46:	84 83       	std	Z+4, r24	; 0x04
    3e48:	e0 91 4c 06 	lds	r30, 0x064C
    3e4c:	f0 91 4d 06 	lds	r31, 0x064D
    3e50:	8b 81       	ldd	r24, Y+3	; 0x03
    3e52:	9c 81       	ldd	r25, Y+4	; 0x04
    3e54:	95 8b       	std	Z+21, r25	; 0x15
    3e56:	84 8b       	std	Z+20, r24	; 0x14
    3e58:	eb 81       	ldd	r30, Y+3	; 0x03
    3e5a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e5c:	80 81       	ld	r24, Z
    3e5e:	8f 5f       	subi	r24, 0xFF	; 255
    3e60:	eb 81       	ldd	r30, Y+3	; 0x03
    3e62:	fc 81       	ldd	r31, Y+4	; 0x04
    3e64:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3e66:	8f 81       	ldd	r24, Y+7	; 0x07
    3e68:	98 85       	ldd	r25, Y+8	; 0x08
    3e6a:	61 e0       	ldi	r22, 0x01	; 1
    3e6c:	0e 94 ad 2a 	call	0x555a	; 0x555a <prvAddCurrentTaskToDelayedList>
}
    3e70:	28 96       	adiw	r28, 0x08	; 8
    3e72:	0f b6       	in	r0, 0x3f	; 63
    3e74:	f8 94       	cli
    3e76:	de bf       	out	0x3e, r29	; 62
    3e78:	0f be       	out	0x3f, r0	; 63
    3e7a:	cd bf       	out	0x3d, r28	; 61
    3e7c:	cf 91       	pop	r28
    3e7e:	df 91       	pop	r29
    3e80:	08 95       	ret

00003e82 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3e82:	df 93       	push	r29
    3e84:	cf 93       	push	r28
    3e86:	cd b7       	in	r28, 0x3d	; 61
    3e88:	de b7       	in	r29, 0x3e	; 62
    3e8a:	2d 97       	sbiw	r28, 0x0d	; 13
    3e8c:	0f b6       	in	r0, 0x3f	; 63
    3e8e:	f8 94       	cli
    3e90:	de bf       	out	0x3e, r29	; 62
    3e92:	0f be       	out	0x3f, r0	; 63
    3e94:	cd bf       	out	0x3d, r28	; 61
    3e96:	9d 87       	std	Y+13, r25	; 0x0d
    3e98:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e9a:	ec 85       	ldd	r30, Y+12	; 0x0c
    3e9c:	fd 85       	ldd	r31, Y+13	; 0x0d
    3e9e:	05 80       	ldd	r0, Z+5	; 0x05
    3ea0:	f6 81       	ldd	r31, Z+6	; 0x06
    3ea2:	e0 2d       	mov	r30, r0
    3ea4:	86 81       	ldd	r24, Z+6	; 0x06
    3ea6:	97 81       	ldd	r25, Z+7	; 0x07
    3ea8:	9b 87       	std	Y+11, r25	; 0x0b
    3eaa:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    3eac:	ea 85       	ldd	r30, Y+10	; 0x0a
    3eae:	fb 85       	ldd	r31, Y+11	; 0x0b
    3eb0:	84 89       	ldd	r24, Z+20	; 0x14
    3eb2:	95 89       	ldd	r25, Z+21	; 0x15
    3eb4:	98 87       	std	Y+8, r25	; 0x08
    3eb6:	8f 83       	std	Y+7, r24	; 0x07
    3eb8:	ea 85       	ldd	r30, Y+10	; 0x0a
    3eba:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ebc:	a6 85       	ldd	r26, Z+14	; 0x0e
    3ebe:	b7 85       	ldd	r27, Z+15	; 0x0f
    3ec0:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ec2:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ec4:	80 89       	ldd	r24, Z+16	; 0x10
    3ec6:	91 89       	ldd	r25, Z+17	; 0x11
    3ec8:	15 96       	adiw	r26, 0x05	; 5
    3eca:	9c 93       	st	X, r25
    3ecc:	8e 93       	st	-X, r24
    3ece:	14 97       	sbiw	r26, 0x04	; 4
    3ed0:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ed2:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ed4:	a0 89       	ldd	r26, Z+16	; 0x10
    3ed6:	b1 89       	ldd	r27, Z+17	; 0x11
    3ed8:	ea 85       	ldd	r30, Y+10	; 0x0a
    3eda:	fb 85       	ldd	r31, Y+11	; 0x0b
    3edc:	86 85       	ldd	r24, Z+14	; 0x0e
    3ede:	97 85       	ldd	r25, Z+15	; 0x0f
    3ee0:	13 96       	adiw	r26, 0x03	; 3
    3ee2:	9c 93       	st	X, r25
    3ee4:	8e 93       	st	-X, r24
    3ee6:	12 97       	sbiw	r26, 0x02	; 2
    3ee8:	ef 81       	ldd	r30, Y+7	; 0x07
    3eea:	f8 85       	ldd	r31, Y+8	; 0x08
    3eec:	21 81       	ldd	r18, Z+1	; 0x01
    3eee:	32 81       	ldd	r19, Z+2	; 0x02
    3ef0:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ef2:	9b 85       	ldd	r25, Y+11	; 0x0b
    3ef4:	0c 96       	adiw	r24, 0x0c	; 12
    3ef6:	28 17       	cp	r18, r24
    3ef8:	39 07       	cpc	r19, r25
    3efa:	41 f4       	brne	.+16     	; 0x3f0c <xTaskRemoveFromEventList+0x8a>
    3efc:	ea 85       	ldd	r30, Y+10	; 0x0a
    3efe:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f00:	80 89       	ldd	r24, Z+16	; 0x10
    3f02:	91 89       	ldd	r25, Z+17	; 0x11
    3f04:	ef 81       	ldd	r30, Y+7	; 0x07
    3f06:	f8 85       	ldd	r31, Y+8	; 0x08
    3f08:	92 83       	std	Z+2, r25	; 0x02
    3f0a:	81 83       	std	Z+1, r24	; 0x01
    3f0c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f0e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f10:	15 8a       	std	Z+21, r1	; 0x15
    3f12:	14 8a       	std	Z+20, r1	; 0x14
    3f14:	ef 81       	ldd	r30, Y+7	; 0x07
    3f16:	f8 85       	ldd	r31, Y+8	; 0x08
    3f18:	80 81       	ld	r24, Z
    3f1a:	81 50       	subi	r24, 0x01	; 1
    3f1c:	ef 81       	ldd	r30, Y+7	; 0x07
    3f1e:	f8 85       	ldd	r31, Y+8	; 0x08
    3f20:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3f22:	80 91 5d 06 	lds	r24, 0x065D
    3f26:	88 23       	and	r24, r24
    3f28:	09 f0       	breq	.+2      	; 0x3f2c <xTaskRemoveFromEventList+0xaa>
    3f2a:	a4 c0       	rjmp	.+328    	; 0x4074 <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    3f2c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f2e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f30:	82 85       	ldd	r24, Z+10	; 0x0a
    3f32:	93 85       	ldd	r25, Z+11	; 0x0b
    3f34:	9e 83       	std	Y+6, r25	; 0x06
    3f36:	8d 83       	std	Y+5, r24	; 0x05
    3f38:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f3a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f3c:	a4 81       	ldd	r26, Z+4	; 0x04
    3f3e:	b5 81       	ldd	r27, Z+5	; 0x05
    3f40:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f42:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f44:	86 81       	ldd	r24, Z+6	; 0x06
    3f46:	97 81       	ldd	r25, Z+7	; 0x07
    3f48:	15 96       	adiw	r26, 0x05	; 5
    3f4a:	9c 93       	st	X, r25
    3f4c:	8e 93       	st	-X, r24
    3f4e:	14 97       	sbiw	r26, 0x04	; 4
    3f50:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f52:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f54:	a6 81       	ldd	r26, Z+6	; 0x06
    3f56:	b7 81       	ldd	r27, Z+7	; 0x07
    3f58:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f5a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f5c:	84 81       	ldd	r24, Z+4	; 0x04
    3f5e:	95 81       	ldd	r25, Z+5	; 0x05
    3f60:	13 96       	adiw	r26, 0x03	; 3
    3f62:	9c 93       	st	X, r25
    3f64:	8e 93       	st	-X, r24
    3f66:	12 97       	sbiw	r26, 0x02	; 2
    3f68:	ed 81       	ldd	r30, Y+5	; 0x05
    3f6a:	fe 81       	ldd	r31, Y+6	; 0x06
    3f6c:	21 81       	ldd	r18, Z+1	; 0x01
    3f6e:	32 81       	ldd	r19, Z+2	; 0x02
    3f70:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f72:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f74:	02 96       	adiw	r24, 0x02	; 2
    3f76:	28 17       	cp	r18, r24
    3f78:	39 07       	cpc	r19, r25
    3f7a:	41 f4       	brne	.+16     	; 0x3f8c <xTaskRemoveFromEventList+0x10a>
    3f7c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f7e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f80:	86 81       	ldd	r24, Z+6	; 0x06
    3f82:	97 81       	ldd	r25, Z+7	; 0x07
    3f84:	ed 81       	ldd	r30, Y+5	; 0x05
    3f86:	fe 81       	ldd	r31, Y+6	; 0x06
    3f88:	92 83       	std	Z+2, r25	; 0x02
    3f8a:	81 83       	std	Z+1, r24	; 0x01
    3f8c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f8e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f90:	13 86       	std	Z+11, r1	; 0x0b
    3f92:	12 86       	std	Z+10, r1	; 0x0a
    3f94:	ed 81       	ldd	r30, Y+5	; 0x05
    3f96:	fe 81       	ldd	r31, Y+6	; 0x06
    3f98:	80 81       	ld	r24, Z
    3f9a:	81 50       	subi	r24, 0x01	; 1
    3f9c:	ed 81       	ldd	r30, Y+5	; 0x05
    3f9e:	fe 81       	ldd	r31, Y+6	; 0x06
    3fa0:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    3fa2:	ea 85       	ldd	r30, Y+10	; 0x0a
    3fa4:	fb 85       	ldd	r31, Y+11	; 0x0b
    3fa6:	96 89       	ldd	r25, Z+22	; 0x16
    3fa8:	80 91 52 06 	lds	r24, 0x0652
    3fac:	89 17       	cp	r24, r25
    3fae:	28 f4       	brcc	.+10     	; 0x3fba <xTaskRemoveFromEventList+0x138>
    3fb0:	ea 85       	ldd	r30, Y+10	; 0x0a
    3fb2:	fb 85       	ldd	r31, Y+11	; 0x0b
    3fb4:	86 89       	ldd	r24, Z+22	; 0x16
    3fb6:	80 93 52 06 	sts	0x0652, r24
    3fba:	ea 85       	ldd	r30, Y+10	; 0x0a
    3fbc:	fb 85       	ldd	r31, Y+11	; 0x0b
    3fbe:	86 89       	ldd	r24, Z+22	; 0x16
    3fc0:	28 2f       	mov	r18, r24
    3fc2:	30 e0       	ldi	r19, 0x00	; 0
    3fc4:	c9 01       	movw	r24, r18
    3fc6:	88 0f       	add	r24, r24
    3fc8:	99 1f       	adc	r25, r25
    3fca:	88 0f       	add	r24, r24
    3fcc:	99 1f       	adc	r25, r25
    3fce:	88 0f       	add	r24, r24
    3fd0:	99 1f       	adc	r25, r25
    3fd2:	82 0f       	add	r24, r18
    3fd4:	93 1f       	adc	r25, r19
    3fd6:	fc 01       	movw	r30, r24
    3fd8:	e2 5a       	subi	r30, 0xA2	; 162
    3fda:	f9 4f       	sbci	r31, 0xF9	; 249
    3fdc:	81 81       	ldd	r24, Z+1	; 0x01
    3fde:	92 81       	ldd	r25, Z+2	; 0x02
    3fe0:	9c 83       	std	Y+4, r25	; 0x04
    3fe2:	8b 83       	std	Y+3, r24	; 0x03
    3fe4:	ea 85       	ldd	r30, Y+10	; 0x0a
    3fe6:	fb 85       	ldd	r31, Y+11	; 0x0b
    3fe8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fea:	9c 81       	ldd	r25, Y+4	; 0x04
    3fec:	95 83       	std	Z+5, r25	; 0x05
    3fee:	84 83       	std	Z+4, r24	; 0x04
    3ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ff4:	84 81       	ldd	r24, Z+4	; 0x04
    3ff6:	95 81       	ldd	r25, Z+5	; 0x05
    3ff8:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ffa:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ffc:	97 83       	std	Z+7, r25	; 0x07
    3ffe:	86 83       	std	Z+6, r24	; 0x06
    4000:	eb 81       	ldd	r30, Y+3	; 0x03
    4002:	fc 81       	ldd	r31, Y+4	; 0x04
    4004:	04 80       	ldd	r0, Z+4	; 0x04
    4006:	f5 81       	ldd	r31, Z+5	; 0x05
    4008:	e0 2d       	mov	r30, r0
    400a:	8a 85       	ldd	r24, Y+10	; 0x0a
    400c:	9b 85       	ldd	r25, Y+11	; 0x0b
    400e:	02 96       	adiw	r24, 0x02	; 2
    4010:	93 83       	std	Z+3, r25	; 0x03
    4012:	82 83       	std	Z+2, r24	; 0x02
    4014:	8a 85       	ldd	r24, Y+10	; 0x0a
    4016:	9b 85       	ldd	r25, Y+11	; 0x0b
    4018:	02 96       	adiw	r24, 0x02	; 2
    401a:	eb 81       	ldd	r30, Y+3	; 0x03
    401c:	fc 81       	ldd	r31, Y+4	; 0x04
    401e:	95 83       	std	Z+5, r25	; 0x05
    4020:	84 83       	std	Z+4, r24	; 0x04
    4022:	ea 85       	ldd	r30, Y+10	; 0x0a
    4024:	fb 85       	ldd	r31, Y+11	; 0x0b
    4026:	86 89       	ldd	r24, Z+22	; 0x16
    4028:	28 2f       	mov	r18, r24
    402a:	30 e0       	ldi	r19, 0x00	; 0
    402c:	c9 01       	movw	r24, r18
    402e:	88 0f       	add	r24, r24
    4030:	99 1f       	adc	r25, r25
    4032:	88 0f       	add	r24, r24
    4034:	99 1f       	adc	r25, r25
    4036:	88 0f       	add	r24, r24
    4038:	99 1f       	adc	r25, r25
    403a:	82 0f       	add	r24, r18
    403c:	93 1f       	adc	r25, r19
    403e:	82 5a       	subi	r24, 0xA2	; 162
    4040:	99 4f       	sbci	r25, 0xF9	; 249
    4042:	ea 85       	ldd	r30, Y+10	; 0x0a
    4044:	fb 85       	ldd	r31, Y+11	; 0x0b
    4046:	93 87       	std	Z+11, r25	; 0x0b
    4048:	82 87       	std	Z+10, r24	; 0x0a
    404a:	ea 85       	ldd	r30, Y+10	; 0x0a
    404c:	fb 85       	ldd	r31, Y+11	; 0x0b
    404e:	86 89       	ldd	r24, Z+22	; 0x16
    4050:	28 2f       	mov	r18, r24
    4052:	30 e0       	ldi	r19, 0x00	; 0
    4054:	c9 01       	movw	r24, r18
    4056:	88 0f       	add	r24, r24
    4058:	99 1f       	adc	r25, r25
    405a:	88 0f       	add	r24, r24
    405c:	99 1f       	adc	r25, r25
    405e:	88 0f       	add	r24, r24
    4060:	99 1f       	adc	r25, r25
    4062:	82 0f       	add	r24, r18
    4064:	93 1f       	adc	r25, r19
    4066:	fc 01       	movw	r30, r24
    4068:	e2 5a       	subi	r30, 0xA2	; 162
    406a:	f9 4f       	sbci	r31, 0xF9	; 249
    406c:	80 81       	ld	r24, Z
    406e:	8f 5f       	subi	r24, 0xFF	; 255
    4070:	80 83       	st	Z, r24
    4072:	30 c0       	rjmp	.+96     	; 0x40d4 <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4074:	80 91 99 06 	lds	r24, 0x0699
    4078:	90 91 9a 06 	lds	r25, 0x069A
    407c:	9a 83       	std	Y+2, r25	; 0x02
    407e:	89 83       	std	Y+1, r24	; 0x01
    4080:	ea 85       	ldd	r30, Y+10	; 0x0a
    4082:	fb 85       	ldd	r31, Y+11	; 0x0b
    4084:	89 81       	ldd	r24, Y+1	; 0x01
    4086:	9a 81       	ldd	r25, Y+2	; 0x02
    4088:	97 87       	std	Z+15, r25	; 0x0f
    408a:	86 87       	std	Z+14, r24	; 0x0e
    408c:	e9 81       	ldd	r30, Y+1	; 0x01
    408e:	fa 81       	ldd	r31, Y+2	; 0x02
    4090:	84 81       	ldd	r24, Z+4	; 0x04
    4092:	95 81       	ldd	r25, Z+5	; 0x05
    4094:	ea 85       	ldd	r30, Y+10	; 0x0a
    4096:	fb 85       	ldd	r31, Y+11	; 0x0b
    4098:	91 8b       	std	Z+17, r25	; 0x11
    409a:	80 8b       	std	Z+16, r24	; 0x10
    409c:	e9 81       	ldd	r30, Y+1	; 0x01
    409e:	fa 81       	ldd	r31, Y+2	; 0x02
    40a0:	04 80       	ldd	r0, Z+4	; 0x04
    40a2:	f5 81       	ldd	r31, Z+5	; 0x05
    40a4:	e0 2d       	mov	r30, r0
    40a6:	8a 85       	ldd	r24, Y+10	; 0x0a
    40a8:	9b 85       	ldd	r25, Y+11	; 0x0b
    40aa:	0c 96       	adiw	r24, 0x0c	; 12
    40ac:	93 83       	std	Z+3, r25	; 0x03
    40ae:	82 83       	std	Z+2, r24	; 0x02
    40b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    40b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    40b4:	0c 96       	adiw	r24, 0x0c	; 12
    40b6:	e9 81       	ldd	r30, Y+1	; 0x01
    40b8:	fa 81       	ldd	r31, Y+2	; 0x02
    40ba:	95 83       	std	Z+5, r25	; 0x05
    40bc:	84 83       	std	Z+4, r24	; 0x04
    40be:	ea 85       	ldd	r30, Y+10	; 0x0a
    40c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    40c2:	88 e9       	ldi	r24, 0x98	; 152
    40c4:	96 e0       	ldi	r25, 0x06	; 6
    40c6:	95 8b       	std	Z+21, r25	; 0x15
    40c8:	84 8b       	std	Z+20, r24	; 0x14
    40ca:	80 91 98 06 	lds	r24, 0x0698
    40ce:	8f 5f       	subi	r24, 0xFF	; 255
    40d0:	80 93 98 06 	sts	0x0698, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    40d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    40d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    40d8:	96 89       	ldd	r25, Z+22	; 0x16
    40da:	e0 91 4c 06 	lds	r30, 0x064C
    40de:	f0 91 4d 06 	lds	r31, 0x064D
    40e2:	86 89       	ldd	r24, Z+22	; 0x16
    40e4:	89 17       	cp	r24, r25
    40e6:	30 f4       	brcc	.+12     	; 0x40f4 <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    40e8:	81 e0       	ldi	r24, 0x01	; 1
    40ea:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    40ec:	81 e0       	ldi	r24, 0x01	; 1
    40ee:	80 93 56 06 	sts	0x0656, r24
    40f2:	01 c0       	rjmp	.+2      	; 0x40f6 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    40f4:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    40f6:	89 85       	ldd	r24, Y+9	; 0x09
}
    40f8:	2d 96       	adiw	r28, 0x0d	; 13
    40fa:	0f b6       	in	r0, 0x3f	; 63
    40fc:	f8 94       	cli
    40fe:	de bf       	out	0x3e, r29	; 62
    4100:	0f be       	out	0x3f, r0	; 63
    4102:	cd bf       	out	0x3d, r28	; 61
    4104:	cf 91       	pop	r28
    4106:	df 91       	pop	r29
    4108:	08 95       	ret

0000410a <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    410a:	df 93       	push	r29
    410c:	cf 93       	push	r28
    410e:	cd b7       	in	r28, 0x3d	; 61
    4110:	de b7       	in	r29, 0x3e	; 62
    4112:	2c 97       	sbiw	r28, 0x0c	; 12
    4114:	0f b6       	in	r0, 0x3f	; 63
    4116:	f8 94       	cli
    4118:	de bf       	out	0x3e, r29	; 62
    411a:	0f be       	out	0x3f, r0	; 63
    411c:	cd bf       	out	0x3d, r28	; 61
    411e:	9a 87       	std	Y+10, r25	; 0x0a
    4120:	89 87       	std	Y+9, r24	; 0x09
    4122:	7c 87       	std	Y+12, r23	; 0x0c
    4124:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4126:	8b 85       	ldd	r24, Y+11	; 0x0b
    4128:	9c 85       	ldd	r25, Y+12	; 0x0c
    412a:	90 68       	ori	r25, 0x80	; 128
    412c:	e9 85       	ldd	r30, Y+9	; 0x09
    412e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4130:	91 83       	std	Z+1, r25	; 0x01
    4132:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4134:	e9 85       	ldd	r30, Y+9	; 0x09
    4136:	fa 85       	ldd	r31, Y+10	; 0x0a
    4138:	86 81       	ldd	r24, Z+6	; 0x06
    413a:	97 81       	ldd	r25, Z+7	; 0x07
    413c:	98 87       	std	Y+8, r25	; 0x08
    413e:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    4140:	e9 85       	ldd	r30, Y+9	; 0x09
    4142:	fa 85       	ldd	r31, Y+10	; 0x0a
    4144:	80 85       	ldd	r24, Z+8	; 0x08
    4146:	91 85       	ldd	r25, Z+9	; 0x09
    4148:	9e 83       	std	Y+6, r25	; 0x06
    414a:	8d 83       	std	Y+5, r24	; 0x05
    414c:	e9 85       	ldd	r30, Y+9	; 0x09
    414e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4150:	a2 81       	ldd	r26, Z+2	; 0x02
    4152:	b3 81       	ldd	r27, Z+3	; 0x03
    4154:	e9 85       	ldd	r30, Y+9	; 0x09
    4156:	fa 85       	ldd	r31, Y+10	; 0x0a
    4158:	84 81       	ldd	r24, Z+4	; 0x04
    415a:	95 81       	ldd	r25, Z+5	; 0x05
    415c:	15 96       	adiw	r26, 0x05	; 5
    415e:	9c 93       	st	X, r25
    4160:	8e 93       	st	-X, r24
    4162:	14 97       	sbiw	r26, 0x04	; 4
    4164:	e9 85       	ldd	r30, Y+9	; 0x09
    4166:	fa 85       	ldd	r31, Y+10	; 0x0a
    4168:	a4 81       	ldd	r26, Z+4	; 0x04
    416a:	b5 81       	ldd	r27, Z+5	; 0x05
    416c:	e9 85       	ldd	r30, Y+9	; 0x09
    416e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4170:	82 81       	ldd	r24, Z+2	; 0x02
    4172:	93 81       	ldd	r25, Z+3	; 0x03
    4174:	13 96       	adiw	r26, 0x03	; 3
    4176:	9c 93       	st	X, r25
    4178:	8e 93       	st	-X, r24
    417a:	12 97       	sbiw	r26, 0x02	; 2
    417c:	ed 81       	ldd	r30, Y+5	; 0x05
    417e:	fe 81       	ldd	r31, Y+6	; 0x06
    4180:	21 81       	ldd	r18, Z+1	; 0x01
    4182:	32 81       	ldd	r19, Z+2	; 0x02
    4184:	89 85       	ldd	r24, Y+9	; 0x09
    4186:	9a 85       	ldd	r25, Y+10	; 0x0a
    4188:	28 17       	cp	r18, r24
    418a:	39 07       	cpc	r19, r25
    418c:	41 f4       	brne	.+16     	; 0x419e <vTaskRemoveFromUnorderedEventList+0x94>
    418e:	e9 85       	ldd	r30, Y+9	; 0x09
    4190:	fa 85       	ldd	r31, Y+10	; 0x0a
    4192:	84 81       	ldd	r24, Z+4	; 0x04
    4194:	95 81       	ldd	r25, Z+5	; 0x05
    4196:	ed 81       	ldd	r30, Y+5	; 0x05
    4198:	fe 81       	ldd	r31, Y+6	; 0x06
    419a:	92 83       	std	Z+2, r25	; 0x02
    419c:	81 83       	std	Z+1, r24	; 0x01
    419e:	e9 85       	ldd	r30, Y+9	; 0x09
    41a0:	fa 85       	ldd	r31, Y+10	; 0x0a
    41a2:	11 86       	std	Z+9, r1	; 0x09
    41a4:	10 86       	std	Z+8, r1	; 0x08
    41a6:	ed 81       	ldd	r30, Y+5	; 0x05
    41a8:	fe 81       	ldd	r31, Y+6	; 0x06
    41aa:	80 81       	ld	r24, Z
    41ac:	81 50       	subi	r24, 0x01	; 1
    41ae:	ed 81       	ldd	r30, Y+5	; 0x05
    41b0:	fe 81       	ldd	r31, Y+6	; 0x06
    41b2:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    41b4:	ef 81       	ldd	r30, Y+7	; 0x07
    41b6:	f8 85       	ldd	r31, Y+8	; 0x08
    41b8:	82 85       	ldd	r24, Z+10	; 0x0a
    41ba:	93 85       	ldd	r25, Z+11	; 0x0b
    41bc:	9c 83       	std	Y+4, r25	; 0x04
    41be:	8b 83       	std	Y+3, r24	; 0x03
    41c0:	ef 81       	ldd	r30, Y+7	; 0x07
    41c2:	f8 85       	ldd	r31, Y+8	; 0x08
    41c4:	a4 81       	ldd	r26, Z+4	; 0x04
    41c6:	b5 81       	ldd	r27, Z+5	; 0x05
    41c8:	ef 81       	ldd	r30, Y+7	; 0x07
    41ca:	f8 85       	ldd	r31, Y+8	; 0x08
    41cc:	86 81       	ldd	r24, Z+6	; 0x06
    41ce:	97 81       	ldd	r25, Z+7	; 0x07
    41d0:	15 96       	adiw	r26, 0x05	; 5
    41d2:	9c 93       	st	X, r25
    41d4:	8e 93       	st	-X, r24
    41d6:	14 97       	sbiw	r26, 0x04	; 4
    41d8:	ef 81       	ldd	r30, Y+7	; 0x07
    41da:	f8 85       	ldd	r31, Y+8	; 0x08
    41dc:	a6 81       	ldd	r26, Z+6	; 0x06
    41de:	b7 81       	ldd	r27, Z+7	; 0x07
    41e0:	ef 81       	ldd	r30, Y+7	; 0x07
    41e2:	f8 85       	ldd	r31, Y+8	; 0x08
    41e4:	84 81       	ldd	r24, Z+4	; 0x04
    41e6:	95 81       	ldd	r25, Z+5	; 0x05
    41e8:	13 96       	adiw	r26, 0x03	; 3
    41ea:	9c 93       	st	X, r25
    41ec:	8e 93       	st	-X, r24
    41ee:	12 97       	sbiw	r26, 0x02	; 2
    41f0:	eb 81       	ldd	r30, Y+3	; 0x03
    41f2:	fc 81       	ldd	r31, Y+4	; 0x04
    41f4:	21 81       	ldd	r18, Z+1	; 0x01
    41f6:	32 81       	ldd	r19, Z+2	; 0x02
    41f8:	8f 81       	ldd	r24, Y+7	; 0x07
    41fa:	98 85       	ldd	r25, Y+8	; 0x08
    41fc:	02 96       	adiw	r24, 0x02	; 2
    41fe:	28 17       	cp	r18, r24
    4200:	39 07       	cpc	r19, r25
    4202:	41 f4       	brne	.+16     	; 0x4214 <vTaskRemoveFromUnorderedEventList+0x10a>
    4204:	ef 81       	ldd	r30, Y+7	; 0x07
    4206:	f8 85       	ldd	r31, Y+8	; 0x08
    4208:	86 81       	ldd	r24, Z+6	; 0x06
    420a:	97 81       	ldd	r25, Z+7	; 0x07
    420c:	eb 81       	ldd	r30, Y+3	; 0x03
    420e:	fc 81       	ldd	r31, Y+4	; 0x04
    4210:	92 83       	std	Z+2, r25	; 0x02
    4212:	81 83       	std	Z+1, r24	; 0x01
    4214:	ef 81       	ldd	r30, Y+7	; 0x07
    4216:	f8 85       	ldd	r31, Y+8	; 0x08
    4218:	13 86       	std	Z+11, r1	; 0x0b
    421a:	12 86       	std	Z+10, r1	; 0x0a
    421c:	eb 81       	ldd	r30, Y+3	; 0x03
    421e:	fc 81       	ldd	r31, Y+4	; 0x04
    4220:	80 81       	ld	r24, Z
    4222:	81 50       	subi	r24, 0x01	; 1
    4224:	eb 81       	ldd	r30, Y+3	; 0x03
    4226:	fc 81       	ldd	r31, Y+4	; 0x04
    4228:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    422a:	ef 81       	ldd	r30, Y+7	; 0x07
    422c:	f8 85       	ldd	r31, Y+8	; 0x08
    422e:	96 89       	ldd	r25, Z+22	; 0x16
    4230:	80 91 52 06 	lds	r24, 0x0652
    4234:	89 17       	cp	r24, r25
    4236:	28 f4       	brcc	.+10     	; 0x4242 <vTaskRemoveFromUnorderedEventList+0x138>
    4238:	ef 81       	ldd	r30, Y+7	; 0x07
    423a:	f8 85       	ldd	r31, Y+8	; 0x08
    423c:	86 89       	ldd	r24, Z+22	; 0x16
    423e:	80 93 52 06 	sts	0x0652, r24
    4242:	ef 81       	ldd	r30, Y+7	; 0x07
    4244:	f8 85       	ldd	r31, Y+8	; 0x08
    4246:	86 89       	ldd	r24, Z+22	; 0x16
    4248:	28 2f       	mov	r18, r24
    424a:	30 e0       	ldi	r19, 0x00	; 0
    424c:	c9 01       	movw	r24, r18
    424e:	88 0f       	add	r24, r24
    4250:	99 1f       	adc	r25, r25
    4252:	88 0f       	add	r24, r24
    4254:	99 1f       	adc	r25, r25
    4256:	88 0f       	add	r24, r24
    4258:	99 1f       	adc	r25, r25
    425a:	82 0f       	add	r24, r18
    425c:	93 1f       	adc	r25, r19
    425e:	fc 01       	movw	r30, r24
    4260:	e2 5a       	subi	r30, 0xA2	; 162
    4262:	f9 4f       	sbci	r31, 0xF9	; 249
    4264:	81 81       	ldd	r24, Z+1	; 0x01
    4266:	92 81       	ldd	r25, Z+2	; 0x02
    4268:	9a 83       	std	Y+2, r25	; 0x02
    426a:	89 83       	std	Y+1, r24	; 0x01
    426c:	ef 81       	ldd	r30, Y+7	; 0x07
    426e:	f8 85       	ldd	r31, Y+8	; 0x08
    4270:	89 81       	ldd	r24, Y+1	; 0x01
    4272:	9a 81       	ldd	r25, Y+2	; 0x02
    4274:	95 83       	std	Z+5, r25	; 0x05
    4276:	84 83       	std	Z+4, r24	; 0x04
    4278:	e9 81       	ldd	r30, Y+1	; 0x01
    427a:	fa 81       	ldd	r31, Y+2	; 0x02
    427c:	84 81       	ldd	r24, Z+4	; 0x04
    427e:	95 81       	ldd	r25, Z+5	; 0x05
    4280:	ef 81       	ldd	r30, Y+7	; 0x07
    4282:	f8 85       	ldd	r31, Y+8	; 0x08
    4284:	97 83       	std	Z+7, r25	; 0x07
    4286:	86 83       	std	Z+6, r24	; 0x06
    4288:	e9 81       	ldd	r30, Y+1	; 0x01
    428a:	fa 81       	ldd	r31, Y+2	; 0x02
    428c:	04 80       	ldd	r0, Z+4	; 0x04
    428e:	f5 81       	ldd	r31, Z+5	; 0x05
    4290:	e0 2d       	mov	r30, r0
    4292:	8f 81       	ldd	r24, Y+7	; 0x07
    4294:	98 85       	ldd	r25, Y+8	; 0x08
    4296:	02 96       	adiw	r24, 0x02	; 2
    4298:	93 83       	std	Z+3, r25	; 0x03
    429a:	82 83       	std	Z+2, r24	; 0x02
    429c:	8f 81       	ldd	r24, Y+7	; 0x07
    429e:	98 85       	ldd	r25, Y+8	; 0x08
    42a0:	02 96       	adiw	r24, 0x02	; 2
    42a2:	e9 81       	ldd	r30, Y+1	; 0x01
    42a4:	fa 81       	ldd	r31, Y+2	; 0x02
    42a6:	95 83       	std	Z+5, r25	; 0x05
    42a8:	84 83       	std	Z+4, r24	; 0x04
    42aa:	ef 81       	ldd	r30, Y+7	; 0x07
    42ac:	f8 85       	ldd	r31, Y+8	; 0x08
    42ae:	86 89       	ldd	r24, Z+22	; 0x16
    42b0:	28 2f       	mov	r18, r24
    42b2:	30 e0       	ldi	r19, 0x00	; 0
    42b4:	c9 01       	movw	r24, r18
    42b6:	88 0f       	add	r24, r24
    42b8:	99 1f       	adc	r25, r25
    42ba:	88 0f       	add	r24, r24
    42bc:	99 1f       	adc	r25, r25
    42be:	88 0f       	add	r24, r24
    42c0:	99 1f       	adc	r25, r25
    42c2:	82 0f       	add	r24, r18
    42c4:	93 1f       	adc	r25, r19
    42c6:	82 5a       	subi	r24, 0xA2	; 162
    42c8:	99 4f       	sbci	r25, 0xF9	; 249
    42ca:	ef 81       	ldd	r30, Y+7	; 0x07
    42cc:	f8 85       	ldd	r31, Y+8	; 0x08
    42ce:	93 87       	std	Z+11, r25	; 0x0b
    42d0:	82 87       	std	Z+10, r24	; 0x0a
    42d2:	ef 81       	ldd	r30, Y+7	; 0x07
    42d4:	f8 85       	ldd	r31, Y+8	; 0x08
    42d6:	86 89       	ldd	r24, Z+22	; 0x16
    42d8:	28 2f       	mov	r18, r24
    42da:	30 e0       	ldi	r19, 0x00	; 0
    42dc:	c9 01       	movw	r24, r18
    42de:	88 0f       	add	r24, r24
    42e0:	99 1f       	adc	r25, r25
    42e2:	88 0f       	add	r24, r24
    42e4:	99 1f       	adc	r25, r25
    42e6:	88 0f       	add	r24, r24
    42e8:	99 1f       	adc	r25, r25
    42ea:	82 0f       	add	r24, r18
    42ec:	93 1f       	adc	r25, r19
    42ee:	fc 01       	movw	r30, r24
    42f0:	e2 5a       	subi	r30, 0xA2	; 162
    42f2:	f9 4f       	sbci	r31, 0xF9	; 249
    42f4:	80 81       	ld	r24, Z
    42f6:	8f 5f       	subi	r24, 0xFF	; 255
    42f8:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    42fa:	ef 81       	ldd	r30, Y+7	; 0x07
    42fc:	f8 85       	ldd	r31, Y+8	; 0x08
    42fe:	96 89       	ldd	r25, Z+22	; 0x16
    4300:	e0 91 4c 06 	lds	r30, 0x064C
    4304:	f0 91 4d 06 	lds	r31, 0x064D
    4308:	86 89       	ldd	r24, Z+22	; 0x16
    430a:	89 17       	cp	r24, r25
    430c:	18 f4       	brcc	.+6      	; 0x4314 <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    430e:	81 e0       	ldi	r24, 0x01	; 1
    4310:	80 93 56 06 	sts	0x0656, r24
    }
}
    4314:	2c 96       	adiw	r28, 0x0c	; 12
    4316:	0f b6       	in	r0, 0x3f	; 63
    4318:	f8 94       	cli
    431a:	de bf       	out	0x3e, r29	; 62
    431c:	0f be       	out	0x3f, r0	; 63
    431e:	cd bf       	out	0x3d, r28	; 61
    4320:	cf 91       	pop	r28
    4322:	df 91       	pop	r29
    4324:	08 95       	ret

00004326 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4326:	df 93       	push	r29
    4328:	cf 93       	push	r28
    432a:	00 d0       	rcall	.+0      	; 0x432c <vTaskSetTimeOutState+0x6>
    432c:	cd b7       	in	r28, 0x3d	; 61
    432e:	de b7       	in	r29, 0x3e	; 62
    4330:	9a 83       	std	Y+2, r25	; 0x02
    4332:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    4334:	0f b6       	in	r0, 0x3f	; 63
    4336:	f8 94       	cli
    4338:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    433a:	80 91 57 06 	lds	r24, 0x0657
    433e:	e9 81       	ldd	r30, Y+1	; 0x01
    4340:	fa 81       	ldd	r31, Y+2	; 0x02
    4342:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    4344:	80 91 50 06 	lds	r24, 0x0650
    4348:	90 91 51 06 	lds	r25, 0x0651
    434c:	e9 81       	ldd	r30, Y+1	; 0x01
    434e:	fa 81       	ldd	r31, Y+2	; 0x02
    4350:	92 83       	std	Z+2, r25	; 0x02
    4352:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    4354:	0f 90       	pop	r0
    4356:	0f be       	out	0x3f, r0	; 63
}
    4358:	0f 90       	pop	r0
    435a:	0f 90       	pop	r0
    435c:	cf 91       	pop	r28
    435e:	df 91       	pop	r29
    4360:	08 95       	ret

00004362 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4362:	df 93       	push	r29
    4364:	cf 93       	push	r28
    4366:	00 d0       	rcall	.+0      	; 0x4368 <vTaskInternalSetTimeOutState+0x6>
    4368:	cd b7       	in	r28, 0x3d	; 61
    436a:	de b7       	in	r29, 0x3e	; 62
    436c:	9a 83       	std	Y+2, r25	; 0x02
    436e:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4370:	80 91 57 06 	lds	r24, 0x0657
    4374:	e9 81       	ldd	r30, Y+1	; 0x01
    4376:	fa 81       	ldd	r31, Y+2	; 0x02
    4378:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    437a:	80 91 50 06 	lds	r24, 0x0650
    437e:	90 91 51 06 	lds	r25, 0x0651
    4382:	e9 81       	ldd	r30, Y+1	; 0x01
    4384:	fa 81       	ldd	r31, Y+2	; 0x02
    4386:	92 83       	std	Z+2, r25	; 0x02
    4388:	81 83       	std	Z+1, r24	; 0x01
}
    438a:	0f 90       	pop	r0
    438c:	0f 90       	pop	r0
    438e:	cf 91       	pop	r28
    4390:	df 91       	pop	r29
    4392:	08 95       	ret

00004394 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4394:	df 93       	push	r29
    4396:	cf 93       	push	r28
    4398:	cd b7       	in	r28, 0x3d	; 61
    439a:	de b7       	in	r29, 0x3e	; 62
    439c:	29 97       	sbiw	r28, 0x09	; 9
    439e:	0f b6       	in	r0, 0x3f	; 63
    43a0:	f8 94       	cli
    43a2:	de bf       	out	0x3e, r29	; 62
    43a4:	0f be       	out	0x3f, r0	; 63
    43a6:	cd bf       	out	0x3d, r28	; 61
    43a8:	9f 83       	std	Y+7, r25	; 0x07
    43aa:	8e 83       	std	Y+6, r24	; 0x06
    43ac:	79 87       	std	Y+9, r23	; 0x09
    43ae:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    43b0:	0f b6       	in	r0, 0x3f	; 63
    43b2:	f8 94       	cli
    43b4:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    43b6:	80 91 50 06 	lds	r24, 0x0650
    43ba:	90 91 51 06 	lds	r25, 0x0651
    43be:	9c 83       	std	Y+4, r25	; 0x04
    43c0:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    43c2:	ee 81       	ldd	r30, Y+6	; 0x06
    43c4:	ff 81       	ldd	r31, Y+7	; 0x07
    43c6:	21 81       	ldd	r18, Z+1	; 0x01
    43c8:	32 81       	ldd	r19, Z+2	; 0x02
    43ca:	8b 81       	ldd	r24, Y+3	; 0x03
    43cc:	9c 81       	ldd	r25, Y+4	; 0x04
    43ce:	82 1b       	sub	r24, r18
    43d0:	93 0b       	sbc	r25, r19
    43d2:	9a 83       	std	Y+2, r25	; 0x02
    43d4:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    43d6:	ee 81       	ldd	r30, Y+6	; 0x06
    43d8:	ff 81       	ldd	r31, Y+7	; 0x07
    43da:	90 81       	ld	r25, Z
    43dc:	80 91 57 06 	lds	r24, 0x0657
    43e0:	98 17       	cp	r25, r24
    43e2:	81 f0       	breq	.+32     	; 0x4404 <xTaskCheckForTimeOut+0x70>
    43e4:	ee 81       	ldd	r30, Y+6	; 0x06
    43e6:	ff 81       	ldd	r31, Y+7	; 0x07
    43e8:	21 81       	ldd	r18, Z+1	; 0x01
    43ea:	32 81       	ldd	r19, Z+2	; 0x02
    43ec:	8b 81       	ldd	r24, Y+3	; 0x03
    43ee:	9c 81       	ldd	r25, Y+4	; 0x04
    43f0:	82 17       	cp	r24, r18
    43f2:	93 07       	cpc	r25, r19
    43f4:	38 f0       	brcs	.+14     	; 0x4404 <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    43f6:	81 e0       	ldi	r24, 0x01	; 1
    43f8:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    43fa:	e8 85       	ldd	r30, Y+8	; 0x08
    43fc:	f9 85       	ldd	r31, Y+9	; 0x09
    43fe:	11 82       	std	Z+1, r1	; 0x01
    4400:	10 82       	st	Z, r1
    4402:	23 c0       	rjmp	.+70     	; 0x444a <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4404:	e8 85       	ldd	r30, Y+8	; 0x08
    4406:	f9 85       	ldd	r31, Y+9	; 0x09
    4408:	20 81       	ld	r18, Z
    440a:	31 81       	ldd	r19, Z+1	; 0x01
    440c:	89 81       	ldd	r24, Y+1	; 0x01
    440e:	9a 81       	ldd	r25, Y+2	; 0x02
    4410:	82 17       	cp	r24, r18
    4412:	93 07       	cpc	r25, r19
    4414:	a0 f4       	brcc	.+40     	; 0x443e <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    4416:	e8 85       	ldd	r30, Y+8	; 0x08
    4418:	f9 85       	ldd	r31, Y+9	; 0x09
    441a:	20 81       	ld	r18, Z
    441c:	31 81       	ldd	r19, Z+1	; 0x01
    441e:	89 81       	ldd	r24, Y+1	; 0x01
    4420:	9a 81       	ldd	r25, Y+2	; 0x02
    4422:	a9 01       	movw	r20, r18
    4424:	48 1b       	sub	r20, r24
    4426:	59 0b       	sbc	r21, r25
    4428:	ca 01       	movw	r24, r20
    442a:	e8 85       	ldd	r30, Y+8	; 0x08
    442c:	f9 85       	ldd	r31, Y+9	; 0x09
    442e:	91 83       	std	Z+1, r25	; 0x01
    4430:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    4432:	8e 81       	ldd	r24, Y+6	; 0x06
    4434:	9f 81       	ldd	r25, Y+7	; 0x07
    4436:	0e 94 b1 21 	call	0x4362	; 0x4362 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    443a:	1d 82       	std	Y+5, r1	; 0x05
    443c:	06 c0       	rjmp	.+12     	; 0x444a <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    443e:	e8 85       	ldd	r30, Y+8	; 0x08
    4440:	f9 85       	ldd	r31, Y+9	; 0x09
    4442:	11 82       	std	Z+1, r1	; 0x01
    4444:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    4446:	81 e0       	ldi	r24, 0x01	; 1
    4448:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    444a:	0f 90       	pop	r0
    444c:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    444e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4450:	29 96       	adiw	r28, 0x09	; 9
    4452:	0f b6       	in	r0, 0x3f	; 63
    4454:	f8 94       	cli
    4456:	de bf       	out	0x3e, r29	; 62
    4458:	0f be       	out	0x3f, r0	; 63
    445a:	cd bf       	out	0x3d, r28	; 61
    445c:	cf 91       	pop	r28
    445e:	df 91       	pop	r29
    4460:	08 95       	ret

00004462 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4462:	df 93       	push	r29
    4464:	cf 93       	push	r28
    4466:	cd b7       	in	r28, 0x3d	; 61
    4468:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    446a:	81 e0       	ldi	r24, 0x01	; 1
    446c:	80 93 56 06 	sts	0x0656, r24
}
    4470:	cf 91       	pop	r28
    4472:	df 91       	pop	r29
    4474:	08 95       	ret

00004476 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4476:	df 93       	push	r29
    4478:	cf 93       	push	r28
    447a:	00 d0       	rcall	.+0      	; 0x447c <prvIdleTask+0x6>
    447c:	cd b7       	in	r28, 0x3d	; 61
    447e:	de b7       	in	r29, 0x3e	; 62
    4480:	9a 83       	std	Y+2, r25	; 0x02
    4482:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    4484:	0e 94 88 22 	call	0x4510	; 0x4510 <prvCheckTasksWaitingTermination>
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    4488:	80 91 5e 06 	lds	r24, 0x065E
    448c:	82 30       	cpi	r24, 0x02	; 2
    448e:	d0 f3       	brcs	.-12     	; 0x4484 <prvIdleTask+0xe>
            {
                taskYIELD();
    4490:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    4494:	f7 cf       	rjmp	.-18     	; 0x4484 <prvIdleTask+0xe>

00004496 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4496:	df 93       	push	r29
    4498:	cf 93       	push	r28
    449a:	0f 92       	push	r0
    449c:	cd b7       	in	r28, 0x3d	; 61
    449e:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    44a0:	19 82       	std	Y+1, r1	; 0x01
    44a2:	13 c0       	rjmp	.+38     	; 0x44ca <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    44a4:	89 81       	ldd	r24, Y+1	; 0x01
    44a6:	28 2f       	mov	r18, r24
    44a8:	30 e0       	ldi	r19, 0x00	; 0
    44aa:	c9 01       	movw	r24, r18
    44ac:	88 0f       	add	r24, r24
    44ae:	99 1f       	adc	r25, r25
    44b0:	88 0f       	add	r24, r24
    44b2:	99 1f       	adc	r25, r25
    44b4:	88 0f       	add	r24, r24
    44b6:	99 1f       	adc	r25, r25
    44b8:	82 0f       	add	r24, r18
    44ba:	93 1f       	adc	r25, r19
    44bc:	82 5a       	subi	r24, 0xA2	; 162
    44be:	99 4f       	sbci	r25, 0xF9	; 249
    44c0:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    44c4:	89 81       	ldd	r24, Y+1	; 0x01
    44c6:	8f 5f       	subi	r24, 0xFF	; 255
    44c8:	89 83       	std	Y+1, r24	; 0x01
    44ca:	89 81       	ldd	r24, Y+1	; 0x01
    44cc:	84 30       	cpi	r24, 0x04	; 4
    44ce:	50 f3       	brcs	.-44     	; 0x44a4 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    44d0:	82 e8       	ldi	r24, 0x82	; 130
    44d2:	96 e0       	ldi	r25, 0x06	; 6
    44d4:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    44d8:	8b e8       	ldi	r24, 0x8B	; 139
    44da:	96 e0       	ldi	r25, 0x06	; 6
    44dc:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    44e0:	88 e9       	ldi	r24, 0x98	; 152
    44e2:	96 e0       	ldi	r25, 0x06	; 6
    44e4:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
    44e8:	81 ea       	ldi	r24, 0xA1	; 161
    44ea:	96 e0       	ldi	r25, 0x06	; 6
    44ec:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    44f0:	82 e8       	ldi	r24, 0x82	; 130
    44f2:	96 e0       	ldi	r25, 0x06	; 6
    44f4:	90 93 95 06 	sts	0x0695, r25
    44f8:	80 93 94 06 	sts	0x0694, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    44fc:	8b e8       	ldi	r24, 0x8B	; 139
    44fe:	96 e0       	ldi	r25, 0x06	; 6
    4500:	90 93 97 06 	sts	0x0697, r25
    4504:	80 93 96 06 	sts	0x0696, r24
}
    4508:	0f 90       	pop	r0
    450a:	cf 91       	pop	r28
    450c:	df 91       	pop	r29
    450e:	08 95       	ret

00004510 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4510:	df 93       	push	r29
    4512:	cf 93       	push	r28
    4514:	00 d0       	rcall	.+0      	; 0x4516 <prvCheckTasksWaitingTermination+0x6>
    4516:	cd b7       	in	r28, 0x3d	; 61
    4518:	de b7       	in	r29, 0x3e	; 62
    451a:	20 c0       	rjmp	.+64     	; 0x455c <prvCheckTasksWaitingTermination+0x4c>

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            taskENTER_CRITICAL();
    451c:	0f b6       	in	r0, 0x3f	; 63
    451e:	f8 94       	cli
    4520:	0f 92       	push	r0
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4522:	e0 91 a6 06 	lds	r30, 0x06A6
    4526:	f0 91 a7 06 	lds	r31, 0x06A7
    452a:	86 81       	ldd	r24, Z+6	; 0x06
    452c:	97 81       	ldd	r25, Z+7	; 0x07
    452e:	9a 83       	std	Y+2, r25	; 0x02
    4530:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4532:	89 81       	ldd	r24, Y+1	; 0x01
    4534:	9a 81       	ldd	r25, Y+2	; 0x02
    4536:	02 96       	adiw	r24, 0x02	; 2
    4538:	0e 94 cc 07 	call	0xf98	; 0xf98 <uxListRemove>
                --uxCurrentNumberOfTasks;
    453c:	80 91 4f 06 	lds	r24, 0x064F
    4540:	81 50       	subi	r24, 0x01	; 1
    4542:	80 93 4f 06 	sts	0x064F, r24
                --uxDeletedTasksWaitingCleanUp;
    4546:	80 91 4e 06 	lds	r24, 0x064E
    454a:	81 50       	subi	r24, 0x01	; 1
    454c:	80 93 4e 06 	sts	0x064E, r24
            }
            taskEXIT_CRITICAL();
    4550:	0f 90       	pop	r0
    4552:	0f be       	out	0x3f, r0	; 63

            prvDeleteTCB( pxTCB );
    4554:	89 81       	ldd	r24, Y+1	; 0x01
    4556:	9a 81       	ldd	r25, Y+2	; 0x02
    4558:	0e 94 b7 22 	call	0x456e	; 0x456e <prvDeleteTCB>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    455c:	80 91 4e 06 	lds	r24, 0x064E
    4560:	88 23       	and	r24, r24
    4562:	e1 f6       	brne	.-72     	; 0x451c <prvCheckTasksWaitingTermination+0xc>

            prvDeleteTCB( pxTCB );
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
    4564:	0f 90       	pop	r0
    4566:	0f 90       	pop	r0
    4568:	cf 91       	pop	r28
    456a:	df 91       	pop	r29
    456c:	08 95       	ret

0000456e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    456e:	df 93       	push	r29
    4570:	cf 93       	push	r28
    4572:	00 d0       	rcall	.+0      	; 0x4574 <prvDeleteTCB+0x6>
    4574:	cd b7       	in	r28, 0x3d	; 61
    4576:	de b7       	in	r29, 0x3e	; 62
    4578:	9a 83       	std	Y+2, r25	; 0x02
    457a:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    457c:	e9 81       	ldd	r30, Y+1	; 0x01
    457e:	fa 81       	ldd	r31, Y+2	; 0x02
    4580:	87 89       	ldd	r24, Z+23	; 0x17
    4582:	90 8d       	ldd	r25, Z+24	; 0x18
    4584:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
            vPortFree( pxTCB );
    4588:	89 81       	ldd	r24, Y+1	; 0x01
    458a:	9a 81       	ldd	r25, Y+2	; 0x02
    458c:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    4590:	0f 90       	pop	r0
    4592:	0f 90       	pop	r0
    4594:	cf 91       	pop	r28
    4596:	df 91       	pop	r29
    4598:	08 95       	ret

0000459a <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    459a:	df 93       	push	r29
    459c:	cf 93       	push	r28
    459e:	cd b7       	in	r28, 0x3d	; 61
    45a0:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    45a2:	e0 91 94 06 	lds	r30, 0x0694
    45a6:	f0 91 95 06 	lds	r31, 0x0695
    45aa:	80 81       	ld	r24, Z
    45ac:	88 23       	and	r24, r24
    45ae:	39 f4       	brne	.+14     	; 0x45be <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    45b0:	8f ef       	ldi	r24, 0xFF	; 255
    45b2:	9f ef       	ldi	r25, 0xFF	; 255
    45b4:	90 93 5a 06 	sts	0x065A, r25
    45b8:	80 93 59 06 	sts	0x0659, r24
    45bc:	0d c0       	rjmp	.+26     	; 0x45d8 <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    45be:	e0 91 94 06 	lds	r30, 0x0694
    45c2:	f0 91 95 06 	lds	r31, 0x0695
    45c6:	05 80       	ldd	r0, Z+5	; 0x05
    45c8:	f6 81       	ldd	r31, Z+6	; 0x06
    45ca:	e0 2d       	mov	r30, r0
    45cc:	80 81       	ld	r24, Z
    45ce:	91 81       	ldd	r25, Z+1	; 0x01
    45d0:	90 93 5a 06 	sts	0x065A, r25
    45d4:	80 93 59 06 	sts	0x0659, r24
    }
}
    45d8:	cf 91       	pop	r28
    45da:	df 91       	pop	r29
    45dc:	08 95       	ret

000045de <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
    45de:	df 93       	push	r29
    45e0:	cf 93       	push	r28
    45e2:	00 d0       	rcall	.+0      	; 0x45e4 <xTaskGetCurrentTaskHandle+0x6>
    45e4:	cd b7       	in	r28, 0x3d	; 61
    45e6:	de b7       	in	r29, 0x3e	; 62
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    45e8:	80 91 4c 06 	lds	r24, 0x064C
    45ec:	90 91 4d 06 	lds	r25, 0x064D
    45f0:	9a 83       	std	Y+2, r25	; 0x02
    45f2:	89 83       	std	Y+1, r24	; 0x01

        return xReturn;
    45f4:	89 81       	ldd	r24, Y+1	; 0x01
    45f6:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    45f8:	0f 90       	pop	r0
    45fa:	0f 90       	pop	r0
    45fc:	cf 91       	pop	r28
    45fe:	df 91       	pop	r29
    4600:	08 95       	ret

00004602 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4602:	df 93       	push	r29
    4604:	cf 93       	push	r28
    4606:	00 d0       	rcall	.+0      	; 0x4608 <uxTaskResetEventItemValue+0x6>
    4608:	cd b7       	in	r28, 0x3d	; 61
    460a:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    460c:	e0 91 4c 06 	lds	r30, 0x064C
    4610:	f0 91 4d 06 	lds	r31, 0x064D
    4614:	84 85       	ldd	r24, Z+12	; 0x0c
    4616:	95 85       	ldd	r25, Z+13	; 0x0d
    4618:	9a 83       	std	Y+2, r25	; 0x02
    461a:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    461c:	a0 91 4c 06 	lds	r26, 0x064C
    4620:	b0 91 4d 06 	lds	r27, 0x064D
    4624:	e0 91 4c 06 	lds	r30, 0x064C
    4628:	f0 91 4d 06 	lds	r31, 0x064D
    462c:	86 89       	ldd	r24, Z+22	; 0x16
    462e:	28 2f       	mov	r18, r24
    4630:	30 e0       	ldi	r19, 0x00	; 0
    4632:	84 e0       	ldi	r24, 0x04	; 4
    4634:	90 e0       	ldi	r25, 0x00	; 0
    4636:	82 1b       	sub	r24, r18
    4638:	93 0b       	sbc	r25, r19
    463a:	1d 96       	adiw	r26, 0x0d	; 13
    463c:	9c 93       	st	X, r25
    463e:	8e 93       	st	-X, r24
    4640:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4642:	89 81       	ldd	r24, Y+1	; 0x01
    4644:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4646:	0f 90       	pop	r0
    4648:	0f 90       	pop	r0
    464a:	cf 91       	pop	r28
    464c:	df 91       	pop	r29
    464e:	08 95       	ret

00004650 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    4650:	df 93       	push	r29
    4652:	cf 93       	push	r28
    4654:	cd b7       	in	r28, 0x3d	; 61
    4656:	de b7       	in	r29, 0x3e	; 62
    4658:	28 97       	sbiw	r28, 0x08	; 8
    465a:	0f b6       	in	r0, 0x3f	; 63
    465c:	f8 94       	cli
    465e:	de bf       	out	0x3e, r29	; 62
    4660:	0f be       	out	0x3f, r0	; 63
    4662:	cd bf       	out	0x3d, r28	; 61
    4664:	8d 83       	std	Y+5, r24	; 0x05
    4666:	6e 83       	std	Y+6, r22	; 0x06
    4668:	58 87       	std	Y+8, r21	; 0x08
    466a:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    466c:	0f b6       	in	r0, 0x3f	; 63
    466e:	f8 94       	cli
    4670:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    4672:	20 91 4c 06 	lds	r18, 0x064C
    4676:	30 91 4d 06 	lds	r19, 0x064D
    467a:	8d 81       	ldd	r24, Y+5	; 0x05
    467c:	88 2f       	mov	r24, r24
    467e:	90 e0       	ldi	r25, 0x00	; 0
    4680:	88 0f       	add	r24, r24
    4682:	99 1f       	adc	r25, r25
    4684:	88 0f       	add	r24, r24
    4686:	99 1f       	adc	r25, r25
    4688:	82 0f       	add	r24, r18
    468a:	93 1f       	adc	r25, r19
    468c:	fc 01       	movw	r30, r24
    468e:	b1 96       	adiw	r30, 0x21	; 33
    4690:	80 81       	ld	r24, Z
    4692:	91 81       	ldd	r25, Z+1	; 0x01
    4694:	a2 81       	ldd	r26, Z+2	; 0x02
    4696:	b3 81       	ldd	r27, Z+3	; 0x03
    4698:	00 97       	sbiw	r24, 0x00	; 0
    469a:	a1 05       	cpc	r26, r1
    469c:	b1 05       	cpc	r27, r1
    469e:	c1 f4       	brne	.+48     	; 0x46d0 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    46a0:	20 91 4c 06 	lds	r18, 0x064C
    46a4:	30 91 4d 06 	lds	r19, 0x064D
    46a8:	8d 81       	ldd	r24, Y+5	; 0x05
    46aa:	88 2f       	mov	r24, r24
    46ac:	90 e0       	ldi	r25, 0x00	; 0
    46ae:	82 0f       	add	r24, r18
    46b0:	93 1f       	adc	r25, r19
    46b2:	fc 01       	movw	r30, r24
    46b4:	b5 96       	adiw	r30, 0x25	; 37
    46b6:	81 e0       	ldi	r24, 0x01	; 1
    46b8:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    46ba:	8f 81       	ldd	r24, Y+7	; 0x07
    46bc:	98 85       	ldd	r25, Y+8	; 0x08
    46be:	00 97       	sbiw	r24, 0x00	; 0
    46c0:	39 f0       	breq	.+14     	; 0x46d0 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    46c2:	8f 81       	ldd	r24, Y+7	; 0x07
    46c4:	98 85       	ldd	r25, Y+8	; 0x08
    46c6:	61 e0       	ldi	r22, 0x01	; 1
    46c8:	0e 94 ad 2a 	call	0x555a	; 0x555a <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    46cc:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    46d0:	0f 90       	pop	r0
    46d2:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    46d4:	0f b6       	in	r0, 0x3f	; 63
    46d6:	f8 94       	cli
    46d8:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    46da:	20 91 4c 06 	lds	r18, 0x064C
    46de:	30 91 4d 06 	lds	r19, 0x064D
    46e2:	8d 81       	ldd	r24, Y+5	; 0x05
    46e4:	88 2f       	mov	r24, r24
    46e6:	90 e0       	ldi	r25, 0x00	; 0
    46e8:	88 0f       	add	r24, r24
    46ea:	99 1f       	adc	r25, r25
    46ec:	88 0f       	add	r24, r24
    46ee:	99 1f       	adc	r25, r25
    46f0:	82 0f       	add	r24, r18
    46f2:	93 1f       	adc	r25, r19
    46f4:	fc 01       	movw	r30, r24
    46f6:	b1 96       	adiw	r30, 0x21	; 33
    46f8:	80 81       	ld	r24, Z
    46fa:	91 81       	ldd	r25, Z+1	; 0x01
    46fc:	a2 81       	ldd	r26, Z+2	; 0x02
    46fe:	b3 81       	ldd	r27, Z+3	; 0x03
    4700:	89 83       	std	Y+1, r24	; 0x01
    4702:	9a 83       	std	Y+2, r25	; 0x02
    4704:	ab 83       	std	Y+3, r26	; 0x03
    4706:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    4708:	89 81       	ldd	r24, Y+1	; 0x01
    470a:	9a 81       	ldd	r25, Y+2	; 0x02
    470c:	ab 81       	ldd	r26, Y+3	; 0x03
    470e:	bc 81       	ldd	r27, Y+4	; 0x04
    4710:	00 97       	sbiw	r24, 0x00	; 0
    4712:	a1 05       	cpc	r26, r1
    4714:	b1 05       	cpc	r27, r1
    4716:	a9 f1       	breq	.+106    	; 0x4782 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    4718:	8e 81       	ldd	r24, Y+6	; 0x06
    471a:	88 23       	and	r24, r24
    471c:	a1 f0       	breq	.+40     	; 0x4746 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    471e:	20 91 4c 06 	lds	r18, 0x064C
    4722:	30 91 4d 06 	lds	r19, 0x064D
    4726:	8d 81       	ldd	r24, Y+5	; 0x05
    4728:	88 2f       	mov	r24, r24
    472a:	90 e0       	ldi	r25, 0x00	; 0
    472c:	88 0f       	add	r24, r24
    472e:	99 1f       	adc	r25, r25
    4730:	88 0f       	add	r24, r24
    4732:	99 1f       	adc	r25, r25
    4734:	82 0f       	add	r24, r18
    4736:	93 1f       	adc	r25, r19
    4738:	fc 01       	movw	r30, r24
    473a:	b1 96       	adiw	r30, 0x21	; 33
    473c:	10 82       	st	Z, r1
    473e:	11 82       	std	Z+1, r1	; 0x01
    4740:	12 82       	std	Z+2, r1	; 0x02
    4742:	13 82       	std	Z+3, r1	; 0x03
    4744:	1e c0       	rjmp	.+60     	; 0x4782 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    4746:	e0 91 4c 06 	lds	r30, 0x064C
    474a:	f0 91 4d 06 	lds	r31, 0x064D
    474e:	8d 81       	ldd	r24, Y+5	; 0x05
    4750:	68 2f       	mov	r22, r24
    4752:	70 e0       	ldi	r23, 0x00	; 0
    4754:	89 81       	ldd	r24, Y+1	; 0x01
    4756:	9a 81       	ldd	r25, Y+2	; 0x02
    4758:	ab 81       	ldd	r26, Y+3	; 0x03
    475a:	bc 81       	ldd	r27, Y+4	; 0x04
    475c:	9c 01       	movw	r18, r24
    475e:	ad 01       	movw	r20, r26
    4760:	21 50       	subi	r18, 0x01	; 1
    4762:	30 40       	sbci	r19, 0x00	; 0
    4764:	40 40       	sbci	r20, 0x00	; 0
    4766:	50 40       	sbci	r21, 0x00	; 0
    4768:	cb 01       	movw	r24, r22
    476a:	88 0f       	add	r24, r24
    476c:	99 1f       	adc	r25, r25
    476e:	88 0f       	add	r24, r24
    4770:	99 1f       	adc	r25, r25
    4772:	8e 0f       	add	r24, r30
    4774:	9f 1f       	adc	r25, r31
    4776:	fc 01       	movw	r30, r24
    4778:	b1 96       	adiw	r30, 0x21	; 33
    477a:	20 83       	st	Z, r18
    477c:	31 83       	std	Z+1, r19	; 0x01
    477e:	42 83       	std	Z+2, r20	; 0x02
    4780:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4782:	20 91 4c 06 	lds	r18, 0x064C
    4786:	30 91 4d 06 	lds	r19, 0x064D
    478a:	8d 81       	ldd	r24, Y+5	; 0x05
    478c:	88 2f       	mov	r24, r24
    478e:	90 e0       	ldi	r25, 0x00	; 0
    4790:	82 0f       	add	r24, r18
    4792:	93 1f       	adc	r25, r19
    4794:	fc 01       	movw	r30, r24
    4796:	b5 96       	adiw	r30, 0x25	; 37
    4798:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    479a:	0f 90       	pop	r0
    479c:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    479e:	89 81       	ldd	r24, Y+1	; 0x01
    47a0:	9a 81       	ldd	r25, Y+2	; 0x02
    47a2:	ab 81       	ldd	r26, Y+3	; 0x03
    47a4:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    47a6:	bc 01       	movw	r22, r24
    47a8:	cd 01       	movw	r24, r26
    47aa:	28 96       	adiw	r28, 0x08	; 8
    47ac:	0f b6       	in	r0, 0x3f	; 63
    47ae:	f8 94       	cli
    47b0:	de bf       	out	0x3e, r29	; 62
    47b2:	0f be       	out	0x3f, r0	; 63
    47b4:	cd bf       	out	0x3d, r28	; 61
    47b6:	cf 91       	pop	r28
    47b8:	df 91       	pop	r29
    47ba:	08 95       	ret

000047bc <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    47bc:	cf 92       	push	r12
    47be:	df 92       	push	r13
    47c0:	ef 92       	push	r14
    47c2:	ff 92       	push	r15
    47c4:	0f 93       	push	r16
    47c6:	1f 93       	push	r17
    47c8:	df 93       	push	r29
    47ca:	cf 93       	push	r28
    47cc:	cd b7       	in	r28, 0x3d	; 61
    47ce:	de b7       	in	r29, 0x3e	; 62
    47d0:	2e 97       	sbiw	r28, 0x0e	; 14
    47d2:	0f b6       	in	r0, 0x3f	; 63
    47d4:	f8 94       	cli
    47d6:	de bf       	out	0x3e, r29	; 62
    47d8:	0f be       	out	0x3f, r0	; 63
    47da:	cd bf       	out	0x3d, r28	; 61
    47dc:	8a 83       	std	Y+2, r24	; 0x02
    47de:	4b 83       	std	Y+3, r20	; 0x03
    47e0:	5c 83       	std	Y+4, r21	; 0x04
    47e2:	6d 83       	std	Y+5, r22	; 0x05
    47e4:	7e 83       	std	Y+6, r23	; 0x06
    47e6:	0f 83       	std	Y+7, r16	; 0x07
    47e8:	18 87       	std	Y+8, r17	; 0x08
    47ea:	29 87       	std	Y+9, r18	; 0x09
    47ec:	3a 87       	std	Y+10, r19	; 0x0a
    47ee:	fc 86       	std	Y+12, r15	; 0x0c
    47f0:	eb 86       	std	Y+11, r14	; 0x0b
    47f2:	de 86       	std	Y+14, r13	; 0x0e
    47f4:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    47f6:	0f b6       	in	r0, 0x3f	; 63
    47f8:	f8 94       	cli
    47fa:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    47fc:	20 91 4c 06 	lds	r18, 0x064C
    4800:	30 91 4d 06 	lds	r19, 0x064D
    4804:	8a 81       	ldd	r24, Y+2	; 0x02
    4806:	88 2f       	mov	r24, r24
    4808:	90 e0       	ldi	r25, 0x00	; 0
    480a:	82 0f       	add	r24, r18
    480c:	93 1f       	adc	r25, r19
    480e:	fc 01       	movw	r30, r24
    4810:	b5 96       	adiw	r30, 0x25	; 37
    4812:	80 81       	ld	r24, Z
    4814:	82 30       	cpi	r24, 0x02	; 2
    4816:	09 f4       	brne	.+2      	; 0x481a <xTaskGenericNotifyWait+0x5e>
    4818:	47 c0       	rjmp	.+142    	; 0x48a8 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    481a:	60 91 4c 06 	lds	r22, 0x064C
    481e:	70 91 4d 06 	lds	r23, 0x064D
    4822:	8a 81       	ldd	r24, Y+2	; 0x02
    4824:	08 2f       	mov	r16, r24
    4826:	10 e0       	ldi	r17, 0x00	; 0
    4828:	8a 81       	ldd	r24, Y+2	; 0x02
    482a:	88 2f       	mov	r24, r24
    482c:	90 e0       	ldi	r25, 0x00	; 0
    482e:	88 0f       	add	r24, r24
    4830:	99 1f       	adc	r25, r25
    4832:	88 0f       	add	r24, r24
    4834:	99 1f       	adc	r25, r25
    4836:	86 0f       	add	r24, r22
    4838:	97 1f       	adc	r25, r23
    483a:	fc 01       	movw	r30, r24
    483c:	b1 96       	adiw	r30, 0x21	; 33
    483e:	20 81       	ld	r18, Z
    4840:	31 81       	ldd	r19, Z+1	; 0x01
    4842:	42 81       	ldd	r20, Z+2	; 0x02
    4844:	53 81       	ldd	r21, Z+3	; 0x03
    4846:	8b 81       	ldd	r24, Y+3	; 0x03
    4848:	9c 81       	ldd	r25, Y+4	; 0x04
    484a:	ad 81       	ldd	r26, Y+5	; 0x05
    484c:	be 81       	ldd	r27, Y+6	; 0x06
    484e:	80 95       	com	r24
    4850:	90 95       	com	r25
    4852:	a0 95       	com	r26
    4854:	b0 95       	com	r27
    4856:	28 23       	and	r18, r24
    4858:	39 23       	and	r19, r25
    485a:	4a 23       	and	r20, r26
    485c:	5b 23       	and	r21, r27
    485e:	c8 01       	movw	r24, r16
    4860:	88 0f       	add	r24, r24
    4862:	99 1f       	adc	r25, r25
    4864:	88 0f       	add	r24, r24
    4866:	99 1f       	adc	r25, r25
    4868:	86 0f       	add	r24, r22
    486a:	97 1f       	adc	r25, r23
    486c:	fc 01       	movw	r30, r24
    486e:	b1 96       	adiw	r30, 0x21	; 33
    4870:	20 83       	st	Z, r18
    4872:	31 83       	std	Z+1, r19	; 0x01
    4874:	42 83       	std	Z+2, r20	; 0x02
    4876:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4878:	20 91 4c 06 	lds	r18, 0x064C
    487c:	30 91 4d 06 	lds	r19, 0x064D
    4880:	8a 81       	ldd	r24, Y+2	; 0x02
    4882:	88 2f       	mov	r24, r24
    4884:	90 e0       	ldi	r25, 0x00	; 0
    4886:	82 0f       	add	r24, r18
    4888:	93 1f       	adc	r25, r19
    488a:	fc 01       	movw	r30, r24
    488c:	b5 96       	adiw	r30, 0x25	; 37
    488e:	81 e0       	ldi	r24, 0x01	; 1
    4890:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4892:	8d 85       	ldd	r24, Y+13	; 0x0d
    4894:	9e 85       	ldd	r25, Y+14	; 0x0e
    4896:	00 97       	sbiw	r24, 0x00	; 0
    4898:	39 f0       	breq	.+14     	; 0x48a8 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    489a:	8d 85       	ldd	r24, Y+13	; 0x0d
    489c:	9e 85       	ldd	r25, Y+14	; 0x0e
    489e:	61 e0       	ldi	r22, 0x01	; 1
    48a0:	0e 94 ad 2a 	call	0x555a	; 0x555a <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    48a4:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    48a8:	0f 90       	pop	r0
    48aa:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    48ac:	0f b6       	in	r0, 0x3f	; 63
    48ae:	f8 94       	cli
    48b0:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    48b2:	8b 85       	ldd	r24, Y+11	; 0x0b
    48b4:	9c 85       	ldd	r25, Y+12	; 0x0c
    48b6:	00 97       	sbiw	r24, 0x00	; 0
    48b8:	c9 f0       	breq	.+50     	; 0x48ec <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    48ba:	20 91 4c 06 	lds	r18, 0x064C
    48be:	30 91 4d 06 	lds	r19, 0x064D
    48c2:	8a 81       	ldd	r24, Y+2	; 0x02
    48c4:	88 2f       	mov	r24, r24
    48c6:	90 e0       	ldi	r25, 0x00	; 0
    48c8:	88 0f       	add	r24, r24
    48ca:	99 1f       	adc	r25, r25
    48cc:	88 0f       	add	r24, r24
    48ce:	99 1f       	adc	r25, r25
    48d0:	82 0f       	add	r24, r18
    48d2:	93 1f       	adc	r25, r19
    48d4:	fc 01       	movw	r30, r24
    48d6:	b1 96       	adiw	r30, 0x21	; 33
    48d8:	80 81       	ld	r24, Z
    48da:	91 81       	ldd	r25, Z+1	; 0x01
    48dc:	a2 81       	ldd	r26, Z+2	; 0x02
    48de:	b3 81       	ldd	r27, Z+3	; 0x03
    48e0:	eb 85       	ldd	r30, Y+11	; 0x0b
    48e2:	fc 85       	ldd	r31, Y+12	; 0x0c
    48e4:	80 83       	st	Z, r24
    48e6:	91 83       	std	Z+1, r25	; 0x01
    48e8:	a2 83       	std	Z+2, r26	; 0x02
    48ea:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    48ec:	20 91 4c 06 	lds	r18, 0x064C
    48f0:	30 91 4d 06 	lds	r19, 0x064D
    48f4:	8a 81       	ldd	r24, Y+2	; 0x02
    48f6:	88 2f       	mov	r24, r24
    48f8:	90 e0       	ldi	r25, 0x00	; 0
    48fa:	82 0f       	add	r24, r18
    48fc:	93 1f       	adc	r25, r19
    48fe:	fc 01       	movw	r30, r24
    4900:	b5 96       	adiw	r30, 0x25	; 37
    4902:	80 81       	ld	r24, Z
    4904:	82 30       	cpi	r24, 0x02	; 2
    4906:	11 f0       	breq	.+4      	; 0x490c <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    4908:	19 82       	std	Y+1, r1	; 0x01
    490a:	31 c0       	rjmp	.+98     	; 0x496e <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    490c:	60 91 4c 06 	lds	r22, 0x064C
    4910:	70 91 4d 06 	lds	r23, 0x064D
    4914:	8a 81       	ldd	r24, Y+2	; 0x02
    4916:	08 2f       	mov	r16, r24
    4918:	10 e0       	ldi	r17, 0x00	; 0
    491a:	8a 81       	ldd	r24, Y+2	; 0x02
    491c:	88 2f       	mov	r24, r24
    491e:	90 e0       	ldi	r25, 0x00	; 0
    4920:	88 0f       	add	r24, r24
    4922:	99 1f       	adc	r25, r25
    4924:	88 0f       	add	r24, r24
    4926:	99 1f       	adc	r25, r25
    4928:	86 0f       	add	r24, r22
    492a:	97 1f       	adc	r25, r23
    492c:	fc 01       	movw	r30, r24
    492e:	b1 96       	adiw	r30, 0x21	; 33
    4930:	20 81       	ld	r18, Z
    4932:	31 81       	ldd	r19, Z+1	; 0x01
    4934:	42 81       	ldd	r20, Z+2	; 0x02
    4936:	53 81       	ldd	r21, Z+3	; 0x03
    4938:	8f 81       	ldd	r24, Y+7	; 0x07
    493a:	98 85       	ldd	r25, Y+8	; 0x08
    493c:	a9 85       	ldd	r26, Y+9	; 0x09
    493e:	ba 85       	ldd	r27, Y+10	; 0x0a
    4940:	80 95       	com	r24
    4942:	90 95       	com	r25
    4944:	a0 95       	com	r26
    4946:	b0 95       	com	r27
    4948:	28 23       	and	r18, r24
    494a:	39 23       	and	r19, r25
    494c:	4a 23       	and	r20, r26
    494e:	5b 23       	and	r21, r27
    4950:	c8 01       	movw	r24, r16
    4952:	88 0f       	add	r24, r24
    4954:	99 1f       	adc	r25, r25
    4956:	88 0f       	add	r24, r24
    4958:	99 1f       	adc	r25, r25
    495a:	86 0f       	add	r24, r22
    495c:	97 1f       	adc	r25, r23
    495e:	fc 01       	movw	r30, r24
    4960:	b1 96       	adiw	r30, 0x21	; 33
    4962:	20 83       	st	Z, r18
    4964:	31 83       	std	Z+1, r19	; 0x01
    4966:	42 83       	std	Z+2, r20	; 0x02
    4968:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    496a:	81 e0       	ldi	r24, 0x01	; 1
    496c:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    496e:	20 91 4c 06 	lds	r18, 0x064C
    4972:	30 91 4d 06 	lds	r19, 0x064D
    4976:	8a 81       	ldd	r24, Y+2	; 0x02
    4978:	88 2f       	mov	r24, r24
    497a:	90 e0       	ldi	r25, 0x00	; 0
    497c:	82 0f       	add	r24, r18
    497e:	93 1f       	adc	r25, r19
    4980:	fc 01       	movw	r30, r24
    4982:	b5 96       	adiw	r30, 0x25	; 37
    4984:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4986:	0f 90       	pop	r0
    4988:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    498a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    498c:	2e 96       	adiw	r28, 0x0e	; 14
    498e:	0f b6       	in	r0, 0x3f	; 63
    4990:	f8 94       	cli
    4992:	de bf       	out	0x3e, r29	; 62
    4994:	0f be       	out	0x3f, r0	; 63
    4996:	cd bf       	out	0x3d, r28	; 61
    4998:	cf 91       	pop	r28
    499a:	df 91       	pop	r29
    499c:	1f 91       	pop	r17
    499e:	0f 91       	pop	r16
    49a0:	ff 90       	pop	r15
    49a2:	ef 90       	pop	r14
    49a4:	df 90       	pop	r13
    49a6:	cf 90       	pop	r12
    49a8:	08 95       	ret

000049aa <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    49aa:	ef 92       	push	r14
    49ac:	ff 92       	push	r15
    49ae:	0f 93       	push	r16
    49b0:	1f 93       	push	r17
    49b2:	df 93       	push	r29
    49b4:	cf 93       	push	r28
    49b6:	cd b7       	in	r28, 0x3d	; 61
    49b8:	de b7       	in	r29, 0x3e	; 62
    49ba:	64 97       	sbiw	r28, 0x14	; 20
    49bc:	0f b6       	in	r0, 0x3f	; 63
    49be:	f8 94       	cli
    49c0:	de bf       	out	0x3e, r29	; 62
    49c2:	0f be       	out	0x3f, r0	; 63
    49c4:	cd bf       	out	0x3d, r28	; 61
    49c6:	9a 87       	std	Y+10, r25	; 0x0a
    49c8:	89 87       	std	Y+9, r24	; 0x09
    49ca:	6b 87       	std	Y+11, r22	; 0x0b
    49cc:	2c 87       	std	Y+12, r18	; 0x0c
    49ce:	3d 87       	std	Y+13, r19	; 0x0d
    49d0:	4e 87       	std	Y+14, r20	; 0x0e
    49d2:	5f 87       	std	Y+15, r21	; 0x0f
    49d4:	08 8b       	std	Y+16, r16	; 0x10
    49d6:	fa 8a       	std	Y+18, r15	; 0x12
    49d8:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    49da:	81 e0       	ldi	r24, 0x01	; 1
    49dc:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    49de:	89 85       	ldd	r24, Y+9	; 0x09
    49e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    49e2:	98 87       	std	Y+8, r25	; 0x08
    49e4:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    49e6:	0f b6       	in	r0, 0x3f	; 63
    49e8:	f8 94       	cli
    49ea:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    49ec:	89 89       	ldd	r24, Y+17	; 0x11
    49ee:	9a 89       	ldd	r25, Y+18	; 0x12
    49f0:	00 97       	sbiw	r24, 0x00	; 0
    49f2:	b9 f0       	breq	.+46     	; 0x4a22 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    49f4:	8b 85       	ldd	r24, Y+11	; 0x0b
    49f6:	88 2f       	mov	r24, r24
    49f8:	90 e0       	ldi	r25, 0x00	; 0
    49fa:	2f 81       	ldd	r18, Y+7	; 0x07
    49fc:	38 85       	ldd	r19, Y+8	; 0x08
    49fe:	88 0f       	add	r24, r24
    4a00:	99 1f       	adc	r25, r25
    4a02:	88 0f       	add	r24, r24
    4a04:	99 1f       	adc	r25, r25
    4a06:	82 0f       	add	r24, r18
    4a08:	93 1f       	adc	r25, r19
    4a0a:	fc 01       	movw	r30, r24
    4a0c:	b1 96       	adiw	r30, 0x21	; 33
    4a0e:	80 81       	ld	r24, Z
    4a10:	91 81       	ldd	r25, Z+1	; 0x01
    4a12:	a2 81       	ldd	r26, Z+2	; 0x02
    4a14:	b3 81       	ldd	r27, Z+3	; 0x03
    4a16:	e9 89       	ldd	r30, Y+17	; 0x11
    4a18:	fa 89       	ldd	r31, Y+18	; 0x12
    4a1a:	80 83       	st	Z, r24
    4a1c:	91 83       	std	Z+1, r25	; 0x01
    4a1e:	a2 83       	std	Z+2, r26	; 0x02
    4a20:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4a22:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a24:	28 2f       	mov	r18, r24
    4a26:	30 e0       	ldi	r19, 0x00	; 0
    4a28:	8f 81       	ldd	r24, Y+7	; 0x07
    4a2a:	98 85       	ldd	r25, Y+8	; 0x08
    4a2c:	82 0f       	add	r24, r18
    4a2e:	93 1f       	adc	r25, r19
    4a30:	fc 01       	movw	r30, r24
    4a32:	b5 96       	adiw	r30, 0x25	; 37
    4a34:	80 81       	ld	r24, Z
    4a36:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4a38:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a3a:	28 2f       	mov	r18, r24
    4a3c:	30 e0       	ldi	r19, 0x00	; 0
    4a3e:	8f 81       	ldd	r24, Y+7	; 0x07
    4a40:	98 85       	ldd	r25, Y+8	; 0x08
    4a42:	82 0f       	add	r24, r18
    4a44:	93 1f       	adc	r25, r19
    4a46:	fc 01       	movw	r30, r24
    4a48:	b5 96       	adiw	r30, 0x25	; 37
    4a4a:	82 e0       	ldi	r24, 0x02	; 2
    4a4c:	80 83       	st	Z, r24

            switch( eAction )
    4a4e:	88 89       	ldd	r24, Y+16	; 0x10
    4a50:	28 2f       	mov	r18, r24
    4a52:	30 e0       	ldi	r19, 0x00	; 0
    4a54:	3c 8b       	std	Y+20, r19	; 0x14
    4a56:	2b 8b       	std	Y+19, r18	; 0x13
    4a58:	8b 89       	ldd	r24, Y+19	; 0x13
    4a5a:	9c 89       	ldd	r25, Y+20	; 0x14
    4a5c:	82 30       	cpi	r24, 0x02	; 2
    4a5e:	91 05       	cpc	r25, r1
    4a60:	09 f4       	brne	.+2      	; 0x4a64 <xTaskGenericNotify+0xba>
    4a62:	46 c0       	rjmp	.+140    	; 0x4af0 <xTaskGenericNotify+0x146>
    4a64:	2b 89       	ldd	r18, Y+19	; 0x13
    4a66:	3c 89       	ldd	r19, Y+20	; 0x14
    4a68:	23 30       	cpi	r18, 0x03	; 3
    4a6a:	31 05       	cpc	r19, r1
    4a6c:	34 f4       	brge	.+12     	; 0x4a7a <xTaskGenericNotify+0xd0>
    4a6e:	8b 89       	ldd	r24, Y+19	; 0x13
    4a70:	9c 89       	ldd	r25, Y+20	; 0x14
    4a72:	81 30       	cpi	r24, 0x01	; 1
    4a74:	91 05       	cpc	r25, r1
    4a76:	71 f0       	breq	.+28     	; 0x4a94 <xTaskGenericNotify+0xea>
    4a78:	93 c0       	rjmp	.+294    	; 0x4ba0 <xTaskGenericNotify+0x1f6>
    4a7a:	2b 89       	ldd	r18, Y+19	; 0x13
    4a7c:	3c 89       	ldd	r19, Y+20	; 0x14
    4a7e:	23 30       	cpi	r18, 0x03	; 3
    4a80:	31 05       	cpc	r19, r1
    4a82:	09 f4       	brne	.+2      	; 0x4a86 <xTaskGenericNotify+0xdc>
    4a84:	5d c0       	rjmp	.+186    	; 0x4b40 <xTaskGenericNotify+0x196>
    4a86:	8b 89       	ldd	r24, Y+19	; 0x13
    4a88:	9c 89       	ldd	r25, Y+20	; 0x14
    4a8a:	84 30       	cpi	r24, 0x04	; 4
    4a8c:	91 05       	cpc	r25, r1
    4a8e:	09 f4       	brne	.+2      	; 0x4a92 <xTaskGenericNotify+0xe8>
    4a90:	6d c0       	rjmp	.+218    	; 0x4b6c <xTaskGenericNotify+0x1c2>
    4a92:	86 c0       	rjmp	.+268    	; 0x4ba0 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4a94:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a96:	08 2f       	mov	r16, r24
    4a98:	10 e0       	ldi	r17, 0x00	; 0
    4a9a:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a9c:	88 2f       	mov	r24, r24
    4a9e:	90 e0       	ldi	r25, 0x00	; 0
    4aa0:	2f 81       	ldd	r18, Y+7	; 0x07
    4aa2:	38 85       	ldd	r19, Y+8	; 0x08
    4aa4:	88 0f       	add	r24, r24
    4aa6:	99 1f       	adc	r25, r25
    4aa8:	88 0f       	add	r24, r24
    4aaa:	99 1f       	adc	r25, r25
    4aac:	82 0f       	add	r24, r18
    4aae:	93 1f       	adc	r25, r19
    4ab0:	fc 01       	movw	r30, r24
    4ab2:	b1 96       	adiw	r30, 0x21	; 33
    4ab4:	20 81       	ld	r18, Z
    4ab6:	31 81       	ldd	r19, Z+1	; 0x01
    4ab8:	42 81       	ldd	r20, Z+2	; 0x02
    4aba:	53 81       	ldd	r21, Z+3	; 0x03
    4abc:	8c 85       	ldd	r24, Y+12	; 0x0c
    4abe:	9d 85       	ldd	r25, Y+13	; 0x0d
    4ac0:	ae 85       	ldd	r26, Y+14	; 0x0e
    4ac2:	bf 85       	ldd	r27, Y+15	; 0x0f
    4ac4:	ba 01       	movw	r22, r20
    4ac6:	a9 01       	movw	r20, r18
    4ac8:	48 2b       	or	r20, r24
    4aca:	59 2b       	or	r21, r25
    4acc:	6a 2b       	or	r22, r26
    4ace:	7b 2b       	or	r23, r27
    4ad0:	2f 81       	ldd	r18, Y+7	; 0x07
    4ad2:	38 85       	ldd	r19, Y+8	; 0x08
    4ad4:	c8 01       	movw	r24, r16
    4ad6:	88 0f       	add	r24, r24
    4ad8:	99 1f       	adc	r25, r25
    4ada:	88 0f       	add	r24, r24
    4adc:	99 1f       	adc	r25, r25
    4ade:	82 0f       	add	r24, r18
    4ae0:	93 1f       	adc	r25, r19
    4ae2:	fc 01       	movw	r30, r24
    4ae4:	b1 96       	adiw	r30, 0x21	; 33
    4ae6:	40 83       	st	Z, r20
    4ae8:	51 83       	std	Z+1, r21	; 0x01
    4aea:	62 83       	std	Z+2, r22	; 0x02
    4aec:	73 83       	std	Z+3, r23	; 0x03
    4aee:	58 c0       	rjmp	.+176    	; 0x4ba0 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4af0:	8b 85       	ldd	r24, Y+11	; 0x0b
    4af2:	08 2f       	mov	r16, r24
    4af4:	10 e0       	ldi	r17, 0x00	; 0
    4af6:	2f 81       	ldd	r18, Y+7	; 0x07
    4af8:	38 85       	ldd	r19, Y+8	; 0x08
    4afa:	c8 01       	movw	r24, r16
    4afc:	88 0f       	add	r24, r24
    4afe:	99 1f       	adc	r25, r25
    4b00:	88 0f       	add	r24, r24
    4b02:	99 1f       	adc	r25, r25
    4b04:	82 0f       	add	r24, r18
    4b06:	93 1f       	adc	r25, r19
    4b08:	fc 01       	movw	r30, r24
    4b0a:	b1 96       	adiw	r30, 0x21	; 33
    4b0c:	80 81       	ld	r24, Z
    4b0e:	91 81       	ldd	r25, Z+1	; 0x01
    4b10:	a2 81       	ldd	r26, Z+2	; 0x02
    4b12:	b3 81       	ldd	r27, Z+3	; 0x03
    4b14:	ac 01       	movw	r20, r24
    4b16:	bd 01       	movw	r22, r26
    4b18:	4f 5f       	subi	r20, 0xFF	; 255
    4b1a:	5f 4f       	sbci	r21, 0xFF	; 255
    4b1c:	6f 4f       	sbci	r22, 0xFF	; 255
    4b1e:	7f 4f       	sbci	r23, 0xFF	; 255
    4b20:	2f 81       	ldd	r18, Y+7	; 0x07
    4b22:	38 85       	ldd	r19, Y+8	; 0x08
    4b24:	c8 01       	movw	r24, r16
    4b26:	88 0f       	add	r24, r24
    4b28:	99 1f       	adc	r25, r25
    4b2a:	88 0f       	add	r24, r24
    4b2c:	99 1f       	adc	r25, r25
    4b2e:	82 0f       	add	r24, r18
    4b30:	93 1f       	adc	r25, r19
    4b32:	fc 01       	movw	r30, r24
    4b34:	b1 96       	adiw	r30, 0x21	; 33
    4b36:	40 83       	st	Z, r20
    4b38:	51 83       	std	Z+1, r21	; 0x01
    4b3a:	62 83       	std	Z+2, r22	; 0x02
    4b3c:	73 83       	std	Z+3, r23	; 0x03
    4b3e:	30 c0       	rjmp	.+96     	; 0x4ba0 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4b40:	8b 85       	ldd	r24, Y+11	; 0x0b
    4b42:	88 2f       	mov	r24, r24
    4b44:	90 e0       	ldi	r25, 0x00	; 0
    4b46:	2f 81       	ldd	r18, Y+7	; 0x07
    4b48:	38 85       	ldd	r19, Y+8	; 0x08
    4b4a:	88 0f       	add	r24, r24
    4b4c:	99 1f       	adc	r25, r25
    4b4e:	88 0f       	add	r24, r24
    4b50:	99 1f       	adc	r25, r25
    4b52:	82 0f       	add	r24, r18
    4b54:	93 1f       	adc	r25, r19
    4b56:	fc 01       	movw	r30, r24
    4b58:	b1 96       	adiw	r30, 0x21	; 33
    4b5a:	8c 85       	ldd	r24, Y+12	; 0x0c
    4b5c:	9d 85       	ldd	r25, Y+13	; 0x0d
    4b5e:	ae 85       	ldd	r26, Y+14	; 0x0e
    4b60:	bf 85       	ldd	r27, Y+15	; 0x0f
    4b62:	80 83       	st	Z, r24
    4b64:	91 83       	std	Z+1, r25	; 0x01
    4b66:	a2 83       	std	Z+2, r26	; 0x02
    4b68:	b3 83       	std	Z+3, r27	; 0x03
    4b6a:	1a c0       	rjmp	.+52     	; 0x4ba0 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4b6c:	8d 81       	ldd	r24, Y+5	; 0x05
    4b6e:	82 30       	cpi	r24, 0x02	; 2
    4b70:	b1 f0       	breq	.+44     	; 0x4b9e <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4b72:	8b 85       	ldd	r24, Y+11	; 0x0b
    4b74:	88 2f       	mov	r24, r24
    4b76:	90 e0       	ldi	r25, 0x00	; 0
    4b78:	2f 81       	ldd	r18, Y+7	; 0x07
    4b7a:	38 85       	ldd	r19, Y+8	; 0x08
    4b7c:	88 0f       	add	r24, r24
    4b7e:	99 1f       	adc	r25, r25
    4b80:	88 0f       	add	r24, r24
    4b82:	99 1f       	adc	r25, r25
    4b84:	82 0f       	add	r24, r18
    4b86:	93 1f       	adc	r25, r19
    4b88:	fc 01       	movw	r30, r24
    4b8a:	b1 96       	adiw	r30, 0x21	; 33
    4b8c:	8c 85       	ldd	r24, Y+12	; 0x0c
    4b8e:	9d 85       	ldd	r25, Y+13	; 0x0d
    4b90:	ae 85       	ldd	r26, Y+14	; 0x0e
    4b92:	bf 85       	ldd	r27, Y+15	; 0x0f
    4b94:	80 83       	st	Z, r24
    4b96:	91 83       	std	Z+1, r25	; 0x01
    4b98:	a2 83       	std	Z+2, r26	; 0x02
    4b9a:	b3 83       	std	Z+3, r27	; 0x03
    4b9c:	01 c0       	rjmp	.+2      	; 0x4ba0 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    4b9e:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4ba0:	8d 81       	ldd	r24, Y+5	; 0x05
    4ba2:	81 30       	cpi	r24, 0x01	; 1
    4ba4:	09 f0       	breq	.+2      	; 0x4ba8 <xTaskGenericNotify+0x1fe>
    4ba6:	af c0       	rjmp	.+350    	; 0x4d06 <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4ba8:	ef 81       	ldd	r30, Y+7	; 0x07
    4baa:	f8 85       	ldd	r31, Y+8	; 0x08
    4bac:	82 85       	ldd	r24, Z+10	; 0x0a
    4bae:	93 85       	ldd	r25, Z+11	; 0x0b
    4bb0:	9c 83       	std	Y+4, r25	; 0x04
    4bb2:	8b 83       	std	Y+3, r24	; 0x03
    4bb4:	ef 81       	ldd	r30, Y+7	; 0x07
    4bb6:	f8 85       	ldd	r31, Y+8	; 0x08
    4bb8:	a4 81       	ldd	r26, Z+4	; 0x04
    4bba:	b5 81       	ldd	r27, Z+5	; 0x05
    4bbc:	ef 81       	ldd	r30, Y+7	; 0x07
    4bbe:	f8 85       	ldd	r31, Y+8	; 0x08
    4bc0:	86 81       	ldd	r24, Z+6	; 0x06
    4bc2:	97 81       	ldd	r25, Z+7	; 0x07
    4bc4:	15 96       	adiw	r26, 0x05	; 5
    4bc6:	9c 93       	st	X, r25
    4bc8:	8e 93       	st	-X, r24
    4bca:	14 97       	sbiw	r26, 0x04	; 4
    4bcc:	ef 81       	ldd	r30, Y+7	; 0x07
    4bce:	f8 85       	ldd	r31, Y+8	; 0x08
    4bd0:	a6 81       	ldd	r26, Z+6	; 0x06
    4bd2:	b7 81       	ldd	r27, Z+7	; 0x07
    4bd4:	ef 81       	ldd	r30, Y+7	; 0x07
    4bd6:	f8 85       	ldd	r31, Y+8	; 0x08
    4bd8:	84 81       	ldd	r24, Z+4	; 0x04
    4bda:	95 81       	ldd	r25, Z+5	; 0x05
    4bdc:	13 96       	adiw	r26, 0x03	; 3
    4bde:	9c 93       	st	X, r25
    4be0:	8e 93       	st	-X, r24
    4be2:	12 97       	sbiw	r26, 0x02	; 2
    4be4:	eb 81       	ldd	r30, Y+3	; 0x03
    4be6:	fc 81       	ldd	r31, Y+4	; 0x04
    4be8:	21 81       	ldd	r18, Z+1	; 0x01
    4bea:	32 81       	ldd	r19, Z+2	; 0x02
    4bec:	8f 81       	ldd	r24, Y+7	; 0x07
    4bee:	98 85       	ldd	r25, Y+8	; 0x08
    4bf0:	02 96       	adiw	r24, 0x02	; 2
    4bf2:	28 17       	cp	r18, r24
    4bf4:	39 07       	cpc	r19, r25
    4bf6:	41 f4       	brne	.+16     	; 0x4c08 <xTaskGenericNotify+0x25e>
    4bf8:	ef 81       	ldd	r30, Y+7	; 0x07
    4bfa:	f8 85       	ldd	r31, Y+8	; 0x08
    4bfc:	86 81       	ldd	r24, Z+6	; 0x06
    4bfe:	97 81       	ldd	r25, Z+7	; 0x07
    4c00:	eb 81       	ldd	r30, Y+3	; 0x03
    4c02:	fc 81       	ldd	r31, Y+4	; 0x04
    4c04:	92 83       	std	Z+2, r25	; 0x02
    4c06:	81 83       	std	Z+1, r24	; 0x01
    4c08:	ef 81       	ldd	r30, Y+7	; 0x07
    4c0a:	f8 85       	ldd	r31, Y+8	; 0x08
    4c0c:	13 86       	std	Z+11, r1	; 0x0b
    4c0e:	12 86       	std	Z+10, r1	; 0x0a
    4c10:	eb 81       	ldd	r30, Y+3	; 0x03
    4c12:	fc 81       	ldd	r31, Y+4	; 0x04
    4c14:	80 81       	ld	r24, Z
    4c16:	81 50       	subi	r24, 0x01	; 1
    4c18:	eb 81       	ldd	r30, Y+3	; 0x03
    4c1a:	fc 81       	ldd	r31, Y+4	; 0x04
    4c1c:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    4c1e:	ef 81       	ldd	r30, Y+7	; 0x07
    4c20:	f8 85       	ldd	r31, Y+8	; 0x08
    4c22:	96 89       	ldd	r25, Z+22	; 0x16
    4c24:	80 91 52 06 	lds	r24, 0x0652
    4c28:	89 17       	cp	r24, r25
    4c2a:	28 f4       	brcc	.+10     	; 0x4c36 <xTaskGenericNotify+0x28c>
    4c2c:	ef 81       	ldd	r30, Y+7	; 0x07
    4c2e:	f8 85       	ldd	r31, Y+8	; 0x08
    4c30:	86 89       	ldd	r24, Z+22	; 0x16
    4c32:	80 93 52 06 	sts	0x0652, r24
    4c36:	ef 81       	ldd	r30, Y+7	; 0x07
    4c38:	f8 85       	ldd	r31, Y+8	; 0x08
    4c3a:	86 89       	ldd	r24, Z+22	; 0x16
    4c3c:	28 2f       	mov	r18, r24
    4c3e:	30 e0       	ldi	r19, 0x00	; 0
    4c40:	c9 01       	movw	r24, r18
    4c42:	88 0f       	add	r24, r24
    4c44:	99 1f       	adc	r25, r25
    4c46:	88 0f       	add	r24, r24
    4c48:	99 1f       	adc	r25, r25
    4c4a:	88 0f       	add	r24, r24
    4c4c:	99 1f       	adc	r25, r25
    4c4e:	82 0f       	add	r24, r18
    4c50:	93 1f       	adc	r25, r19
    4c52:	fc 01       	movw	r30, r24
    4c54:	e2 5a       	subi	r30, 0xA2	; 162
    4c56:	f9 4f       	sbci	r31, 0xF9	; 249
    4c58:	81 81       	ldd	r24, Z+1	; 0x01
    4c5a:	92 81       	ldd	r25, Z+2	; 0x02
    4c5c:	9a 83       	std	Y+2, r25	; 0x02
    4c5e:	89 83       	std	Y+1, r24	; 0x01
    4c60:	ef 81       	ldd	r30, Y+7	; 0x07
    4c62:	f8 85       	ldd	r31, Y+8	; 0x08
    4c64:	89 81       	ldd	r24, Y+1	; 0x01
    4c66:	9a 81       	ldd	r25, Y+2	; 0x02
    4c68:	95 83       	std	Z+5, r25	; 0x05
    4c6a:	84 83       	std	Z+4, r24	; 0x04
    4c6c:	e9 81       	ldd	r30, Y+1	; 0x01
    4c6e:	fa 81       	ldd	r31, Y+2	; 0x02
    4c70:	84 81       	ldd	r24, Z+4	; 0x04
    4c72:	95 81       	ldd	r25, Z+5	; 0x05
    4c74:	ef 81       	ldd	r30, Y+7	; 0x07
    4c76:	f8 85       	ldd	r31, Y+8	; 0x08
    4c78:	97 83       	std	Z+7, r25	; 0x07
    4c7a:	86 83       	std	Z+6, r24	; 0x06
    4c7c:	e9 81       	ldd	r30, Y+1	; 0x01
    4c7e:	fa 81       	ldd	r31, Y+2	; 0x02
    4c80:	04 80       	ldd	r0, Z+4	; 0x04
    4c82:	f5 81       	ldd	r31, Z+5	; 0x05
    4c84:	e0 2d       	mov	r30, r0
    4c86:	8f 81       	ldd	r24, Y+7	; 0x07
    4c88:	98 85       	ldd	r25, Y+8	; 0x08
    4c8a:	02 96       	adiw	r24, 0x02	; 2
    4c8c:	93 83       	std	Z+3, r25	; 0x03
    4c8e:	82 83       	std	Z+2, r24	; 0x02
    4c90:	8f 81       	ldd	r24, Y+7	; 0x07
    4c92:	98 85       	ldd	r25, Y+8	; 0x08
    4c94:	02 96       	adiw	r24, 0x02	; 2
    4c96:	e9 81       	ldd	r30, Y+1	; 0x01
    4c98:	fa 81       	ldd	r31, Y+2	; 0x02
    4c9a:	95 83       	std	Z+5, r25	; 0x05
    4c9c:	84 83       	std	Z+4, r24	; 0x04
    4c9e:	ef 81       	ldd	r30, Y+7	; 0x07
    4ca0:	f8 85       	ldd	r31, Y+8	; 0x08
    4ca2:	86 89       	ldd	r24, Z+22	; 0x16
    4ca4:	28 2f       	mov	r18, r24
    4ca6:	30 e0       	ldi	r19, 0x00	; 0
    4ca8:	c9 01       	movw	r24, r18
    4caa:	88 0f       	add	r24, r24
    4cac:	99 1f       	adc	r25, r25
    4cae:	88 0f       	add	r24, r24
    4cb0:	99 1f       	adc	r25, r25
    4cb2:	88 0f       	add	r24, r24
    4cb4:	99 1f       	adc	r25, r25
    4cb6:	82 0f       	add	r24, r18
    4cb8:	93 1f       	adc	r25, r19
    4cba:	82 5a       	subi	r24, 0xA2	; 162
    4cbc:	99 4f       	sbci	r25, 0xF9	; 249
    4cbe:	ef 81       	ldd	r30, Y+7	; 0x07
    4cc0:	f8 85       	ldd	r31, Y+8	; 0x08
    4cc2:	93 87       	std	Z+11, r25	; 0x0b
    4cc4:	82 87       	std	Z+10, r24	; 0x0a
    4cc6:	ef 81       	ldd	r30, Y+7	; 0x07
    4cc8:	f8 85       	ldd	r31, Y+8	; 0x08
    4cca:	86 89       	ldd	r24, Z+22	; 0x16
    4ccc:	28 2f       	mov	r18, r24
    4cce:	30 e0       	ldi	r19, 0x00	; 0
    4cd0:	c9 01       	movw	r24, r18
    4cd2:	88 0f       	add	r24, r24
    4cd4:	99 1f       	adc	r25, r25
    4cd6:	88 0f       	add	r24, r24
    4cd8:	99 1f       	adc	r25, r25
    4cda:	88 0f       	add	r24, r24
    4cdc:	99 1f       	adc	r25, r25
    4cde:	82 0f       	add	r24, r18
    4ce0:	93 1f       	adc	r25, r19
    4ce2:	fc 01       	movw	r30, r24
    4ce4:	e2 5a       	subi	r30, 0xA2	; 162
    4ce6:	f9 4f       	sbci	r31, 0xF9	; 249
    4ce8:	80 81       	ld	r24, Z
    4cea:	8f 5f       	subi	r24, 0xFF	; 255
    4cec:	80 83       	st	Z, r24
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4cee:	ef 81       	ldd	r30, Y+7	; 0x07
    4cf0:	f8 85       	ldd	r31, Y+8	; 0x08
    4cf2:	96 89       	ldd	r25, Z+22	; 0x16
    4cf4:	e0 91 4c 06 	lds	r30, 0x064C
    4cf8:	f0 91 4d 06 	lds	r31, 0x064D
    4cfc:	86 89       	ldd	r24, Z+22	; 0x16
    4cfe:	89 17       	cp	r24, r25
    4d00:	10 f4       	brcc	.+4      	; 0x4d06 <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    4d02:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4d06:	0f 90       	pop	r0
    4d08:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4d0a:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    4d0c:	64 96       	adiw	r28, 0x14	; 20
    4d0e:	0f b6       	in	r0, 0x3f	; 63
    4d10:	f8 94       	cli
    4d12:	de bf       	out	0x3e, r29	; 62
    4d14:	0f be       	out	0x3f, r0	; 63
    4d16:	cd bf       	out	0x3d, r28	; 61
    4d18:	cf 91       	pop	r28
    4d1a:	df 91       	pop	r29
    4d1c:	1f 91       	pop	r17
    4d1e:	0f 91       	pop	r16
    4d20:	ff 90       	pop	r15
    4d22:	ef 90       	pop	r14
    4d24:	08 95       	ret

00004d26 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    4d26:	cf 92       	push	r12
    4d28:	df 92       	push	r13
    4d2a:	ef 92       	push	r14
    4d2c:	ff 92       	push	r15
    4d2e:	0f 93       	push	r16
    4d30:	1f 93       	push	r17
    4d32:	df 93       	push	r29
    4d34:	cf 93       	push	r28
    4d36:	cd b7       	in	r28, 0x3d	; 61
    4d38:	de b7       	in	r29, 0x3e	; 62
    4d3a:	69 97       	sbiw	r28, 0x19	; 25
    4d3c:	0f b6       	in	r0, 0x3f	; 63
    4d3e:	f8 94       	cli
    4d40:	de bf       	out	0x3e, r29	; 62
    4d42:	0f be       	out	0x3f, r0	; 63
    4d44:	cd bf       	out	0x3d, r28	; 61
    4d46:	9d 87       	std	Y+13, r25	; 0x0d
    4d48:	8c 87       	std	Y+12, r24	; 0x0c
    4d4a:	6e 87       	std	Y+14, r22	; 0x0e
    4d4c:	2f 87       	std	Y+15, r18	; 0x0f
    4d4e:	38 8b       	std	Y+16, r19	; 0x10
    4d50:	49 8b       	std	Y+17, r20	; 0x11
    4d52:	5a 8b       	std	Y+18, r21	; 0x12
    4d54:	0b 8b       	std	Y+19, r16	; 0x13
    4d56:	fd 8a       	std	Y+21, r15	; 0x15
    4d58:	ec 8a       	std	Y+20, r14	; 0x14
    4d5a:	df 8a       	std	Y+23, r13	; 0x17
    4d5c:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    4d5e:	81 e0       	ldi	r24, 0x01	; 1
    4d60:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    4d62:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d64:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d66:	9b 87       	std	Y+11, r25	; 0x0b
    4d68:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4d6a:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    4d6c:	8c 89       	ldd	r24, Y+20	; 0x14
    4d6e:	9d 89       	ldd	r25, Y+21	; 0x15
    4d70:	00 97       	sbiw	r24, 0x00	; 0
    4d72:	b9 f0       	breq	.+46     	; 0x4da2 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4d74:	8e 85       	ldd	r24, Y+14	; 0x0e
    4d76:	88 2f       	mov	r24, r24
    4d78:	90 e0       	ldi	r25, 0x00	; 0
    4d7a:	2a 85       	ldd	r18, Y+10	; 0x0a
    4d7c:	3b 85       	ldd	r19, Y+11	; 0x0b
    4d7e:	88 0f       	add	r24, r24
    4d80:	99 1f       	adc	r25, r25
    4d82:	88 0f       	add	r24, r24
    4d84:	99 1f       	adc	r25, r25
    4d86:	82 0f       	add	r24, r18
    4d88:	93 1f       	adc	r25, r19
    4d8a:	fc 01       	movw	r30, r24
    4d8c:	b1 96       	adiw	r30, 0x21	; 33
    4d8e:	80 81       	ld	r24, Z
    4d90:	91 81       	ldd	r25, Z+1	; 0x01
    4d92:	a2 81       	ldd	r26, Z+2	; 0x02
    4d94:	b3 81       	ldd	r27, Z+3	; 0x03
    4d96:	ec 89       	ldd	r30, Y+20	; 0x14
    4d98:	fd 89       	ldd	r31, Y+21	; 0x15
    4d9a:	80 83       	st	Z, r24
    4d9c:	91 83       	std	Z+1, r25	; 0x01
    4d9e:	a2 83       	std	Z+2, r26	; 0x02
    4da0:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4da2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4da4:	28 2f       	mov	r18, r24
    4da6:	30 e0       	ldi	r19, 0x00	; 0
    4da8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4daa:	9b 85       	ldd	r25, Y+11	; 0x0b
    4dac:	82 0f       	add	r24, r18
    4dae:	93 1f       	adc	r25, r19
    4db0:	fc 01       	movw	r30, r24
    4db2:	b5 96       	adiw	r30, 0x25	; 37
    4db4:	80 81       	ld	r24, Z
    4db6:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4db8:	8e 85       	ldd	r24, Y+14	; 0x0e
    4dba:	28 2f       	mov	r18, r24
    4dbc:	30 e0       	ldi	r19, 0x00	; 0
    4dbe:	8a 85       	ldd	r24, Y+10	; 0x0a
    4dc0:	9b 85       	ldd	r25, Y+11	; 0x0b
    4dc2:	82 0f       	add	r24, r18
    4dc4:	93 1f       	adc	r25, r19
    4dc6:	fc 01       	movw	r30, r24
    4dc8:	b5 96       	adiw	r30, 0x25	; 37
    4dca:	82 e0       	ldi	r24, 0x02	; 2
    4dcc:	80 83       	st	Z, r24

            switch( eAction )
    4dce:	8b 89       	ldd	r24, Y+19	; 0x13
    4dd0:	28 2f       	mov	r18, r24
    4dd2:	30 e0       	ldi	r19, 0x00	; 0
    4dd4:	39 8f       	std	Y+25, r19	; 0x19
    4dd6:	28 8f       	std	Y+24, r18	; 0x18
    4dd8:	88 8d       	ldd	r24, Y+24	; 0x18
    4dda:	99 8d       	ldd	r25, Y+25	; 0x19
    4ddc:	82 30       	cpi	r24, 0x02	; 2
    4dde:	91 05       	cpc	r25, r1
    4de0:	09 f4       	brne	.+2      	; 0x4de4 <xTaskGenericNotifyFromISR+0xbe>
    4de2:	46 c0       	rjmp	.+140    	; 0x4e70 <xTaskGenericNotifyFromISR+0x14a>
    4de4:	28 8d       	ldd	r18, Y+24	; 0x18
    4de6:	39 8d       	ldd	r19, Y+25	; 0x19
    4de8:	23 30       	cpi	r18, 0x03	; 3
    4dea:	31 05       	cpc	r19, r1
    4dec:	34 f4       	brge	.+12     	; 0x4dfa <xTaskGenericNotifyFromISR+0xd4>
    4dee:	88 8d       	ldd	r24, Y+24	; 0x18
    4df0:	99 8d       	ldd	r25, Y+25	; 0x19
    4df2:	81 30       	cpi	r24, 0x01	; 1
    4df4:	91 05       	cpc	r25, r1
    4df6:	71 f0       	breq	.+28     	; 0x4e14 <xTaskGenericNotifyFromISR+0xee>
    4df8:	93 c0       	rjmp	.+294    	; 0x4f20 <xTaskGenericNotifyFromISR+0x1fa>
    4dfa:	28 8d       	ldd	r18, Y+24	; 0x18
    4dfc:	39 8d       	ldd	r19, Y+25	; 0x19
    4dfe:	23 30       	cpi	r18, 0x03	; 3
    4e00:	31 05       	cpc	r19, r1
    4e02:	09 f4       	brne	.+2      	; 0x4e06 <xTaskGenericNotifyFromISR+0xe0>
    4e04:	5d c0       	rjmp	.+186    	; 0x4ec0 <xTaskGenericNotifyFromISR+0x19a>
    4e06:	88 8d       	ldd	r24, Y+24	; 0x18
    4e08:	99 8d       	ldd	r25, Y+25	; 0x19
    4e0a:	84 30       	cpi	r24, 0x04	; 4
    4e0c:	91 05       	cpc	r25, r1
    4e0e:	09 f4       	brne	.+2      	; 0x4e12 <xTaskGenericNotifyFromISR+0xec>
    4e10:	6d c0       	rjmp	.+218    	; 0x4eec <xTaskGenericNotifyFromISR+0x1c6>
    4e12:	86 c0       	rjmp	.+268    	; 0x4f20 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4e14:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e16:	08 2f       	mov	r16, r24
    4e18:	10 e0       	ldi	r17, 0x00	; 0
    4e1a:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e1c:	88 2f       	mov	r24, r24
    4e1e:	90 e0       	ldi	r25, 0x00	; 0
    4e20:	2a 85       	ldd	r18, Y+10	; 0x0a
    4e22:	3b 85       	ldd	r19, Y+11	; 0x0b
    4e24:	88 0f       	add	r24, r24
    4e26:	99 1f       	adc	r25, r25
    4e28:	88 0f       	add	r24, r24
    4e2a:	99 1f       	adc	r25, r25
    4e2c:	82 0f       	add	r24, r18
    4e2e:	93 1f       	adc	r25, r19
    4e30:	fc 01       	movw	r30, r24
    4e32:	b1 96       	adiw	r30, 0x21	; 33
    4e34:	20 81       	ld	r18, Z
    4e36:	31 81       	ldd	r19, Z+1	; 0x01
    4e38:	42 81       	ldd	r20, Z+2	; 0x02
    4e3a:	53 81       	ldd	r21, Z+3	; 0x03
    4e3c:	8f 85       	ldd	r24, Y+15	; 0x0f
    4e3e:	98 89       	ldd	r25, Y+16	; 0x10
    4e40:	a9 89       	ldd	r26, Y+17	; 0x11
    4e42:	ba 89       	ldd	r27, Y+18	; 0x12
    4e44:	ba 01       	movw	r22, r20
    4e46:	a9 01       	movw	r20, r18
    4e48:	48 2b       	or	r20, r24
    4e4a:	59 2b       	or	r21, r25
    4e4c:	6a 2b       	or	r22, r26
    4e4e:	7b 2b       	or	r23, r27
    4e50:	2a 85       	ldd	r18, Y+10	; 0x0a
    4e52:	3b 85       	ldd	r19, Y+11	; 0x0b
    4e54:	c8 01       	movw	r24, r16
    4e56:	88 0f       	add	r24, r24
    4e58:	99 1f       	adc	r25, r25
    4e5a:	88 0f       	add	r24, r24
    4e5c:	99 1f       	adc	r25, r25
    4e5e:	82 0f       	add	r24, r18
    4e60:	93 1f       	adc	r25, r19
    4e62:	fc 01       	movw	r30, r24
    4e64:	b1 96       	adiw	r30, 0x21	; 33
    4e66:	40 83       	st	Z, r20
    4e68:	51 83       	std	Z+1, r21	; 0x01
    4e6a:	62 83       	std	Z+2, r22	; 0x02
    4e6c:	73 83       	std	Z+3, r23	; 0x03
    4e6e:	58 c0       	rjmp	.+176    	; 0x4f20 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4e70:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e72:	08 2f       	mov	r16, r24
    4e74:	10 e0       	ldi	r17, 0x00	; 0
    4e76:	2a 85       	ldd	r18, Y+10	; 0x0a
    4e78:	3b 85       	ldd	r19, Y+11	; 0x0b
    4e7a:	c8 01       	movw	r24, r16
    4e7c:	88 0f       	add	r24, r24
    4e7e:	99 1f       	adc	r25, r25
    4e80:	88 0f       	add	r24, r24
    4e82:	99 1f       	adc	r25, r25
    4e84:	82 0f       	add	r24, r18
    4e86:	93 1f       	adc	r25, r19
    4e88:	fc 01       	movw	r30, r24
    4e8a:	b1 96       	adiw	r30, 0x21	; 33
    4e8c:	80 81       	ld	r24, Z
    4e8e:	91 81       	ldd	r25, Z+1	; 0x01
    4e90:	a2 81       	ldd	r26, Z+2	; 0x02
    4e92:	b3 81       	ldd	r27, Z+3	; 0x03
    4e94:	ac 01       	movw	r20, r24
    4e96:	bd 01       	movw	r22, r26
    4e98:	4f 5f       	subi	r20, 0xFF	; 255
    4e9a:	5f 4f       	sbci	r21, 0xFF	; 255
    4e9c:	6f 4f       	sbci	r22, 0xFF	; 255
    4e9e:	7f 4f       	sbci	r23, 0xFF	; 255
    4ea0:	2a 85       	ldd	r18, Y+10	; 0x0a
    4ea2:	3b 85       	ldd	r19, Y+11	; 0x0b
    4ea4:	c8 01       	movw	r24, r16
    4ea6:	88 0f       	add	r24, r24
    4ea8:	99 1f       	adc	r25, r25
    4eaa:	88 0f       	add	r24, r24
    4eac:	99 1f       	adc	r25, r25
    4eae:	82 0f       	add	r24, r18
    4eb0:	93 1f       	adc	r25, r19
    4eb2:	fc 01       	movw	r30, r24
    4eb4:	b1 96       	adiw	r30, 0x21	; 33
    4eb6:	40 83       	st	Z, r20
    4eb8:	51 83       	std	Z+1, r21	; 0x01
    4eba:	62 83       	std	Z+2, r22	; 0x02
    4ebc:	73 83       	std	Z+3, r23	; 0x03
    4ebe:	30 c0       	rjmp	.+96     	; 0x4f20 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4ec0:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ec2:	88 2f       	mov	r24, r24
    4ec4:	90 e0       	ldi	r25, 0x00	; 0
    4ec6:	2a 85       	ldd	r18, Y+10	; 0x0a
    4ec8:	3b 85       	ldd	r19, Y+11	; 0x0b
    4eca:	88 0f       	add	r24, r24
    4ecc:	99 1f       	adc	r25, r25
    4ece:	88 0f       	add	r24, r24
    4ed0:	99 1f       	adc	r25, r25
    4ed2:	82 0f       	add	r24, r18
    4ed4:	93 1f       	adc	r25, r19
    4ed6:	fc 01       	movw	r30, r24
    4ed8:	b1 96       	adiw	r30, 0x21	; 33
    4eda:	8f 85       	ldd	r24, Y+15	; 0x0f
    4edc:	98 89       	ldd	r25, Y+16	; 0x10
    4ede:	a9 89       	ldd	r26, Y+17	; 0x11
    4ee0:	ba 89       	ldd	r27, Y+18	; 0x12
    4ee2:	80 83       	st	Z, r24
    4ee4:	91 83       	std	Z+1, r25	; 0x01
    4ee6:	a2 83       	std	Z+2, r26	; 0x02
    4ee8:	b3 83       	std	Z+3, r27	; 0x03
    4eea:	1a c0       	rjmp	.+52     	; 0x4f20 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4eec:	89 85       	ldd	r24, Y+9	; 0x09
    4eee:	82 30       	cpi	r24, 0x02	; 2
    4ef0:	b1 f0       	breq	.+44     	; 0x4f1e <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4ef2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ef4:	88 2f       	mov	r24, r24
    4ef6:	90 e0       	ldi	r25, 0x00	; 0
    4ef8:	2a 85       	ldd	r18, Y+10	; 0x0a
    4efa:	3b 85       	ldd	r19, Y+11	; 0x0b
    4efc:	88 0f       	add	r24, r24
    4efe:	99 1f       	adc	r25, r25
    4f00:	88 0f       	add	r24, r24
    4f02:	99 1f       	adc	r25, r25
    4f04:	82 0f       	add	r24, r18
    4f06:	93 1f       	adc	r25, r19
    4f08:	fc 01       	movw	r30, r24
    4f0a:	b1 96       	adiw	r30, 0x21	; 33
    4f0c:	8f 85       	ldd	r24, Y+15	; 0x0f
    4f0e:	98 89       	ldd	r25, Y+16	; 0x10
    4f10:	a9 89       	ldd	r26, Y+17	; 0x11
    4f12:	ba 89       	ldd	r27, Y+18	; 0x12
    4f14:	80 83       	st	Z, r24
    4f16:	91 83       	std	Z+1, r25	; 0x01
    4f18:	a2 83       	std	Z+2, r26	; 0x02
    4f1a:	b3 83       	std	Z+3, r27	; 0x03
    4f1c:	01 c0       	rjmp	.+2      	; 0x4f20 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    4f1e:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4f20:	89 85       	ldd	r24, Y+9	; 0x09
    4f22:	81 30       	cpi	r24, 0x01	; 1
    4f24:	09 f0       	breq	.+2      	; 0x4f28 <xTaskGenericNotifyFromISR+0x202>
    4f26:	ee c0       	rjmp	.+476    	; 0x5104 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4f28:	80 91 5d 06 	lds	r24, 0x065D
    4f2c:	88 23       	and	r24, r24
    4f2e:	09 f0       	breq	.+2      	; 0x4f32 <xTaskGenericNotifyFromISR+0x20c>
    4f30:	a4 c0       	rjmp	.+328    	; 0x507a <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4f32:	ea 85       	ldd	r30, Y+10	; 0x0a
    4f34:	fb 85       	ldd	r31, Y+11	; 0x0b
    4f36:	82 85       	ldd	r24, Z+10	; 0x0a
    4f38:	93 85       	ldd	r25, Z+11	; 0x0b
    4f3a:	9e 83       	std	Y+6, r25	; 0x06
    4f3c:	8d 83       	std	Y+5, r24	; 0x05
    4f3e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4f40:	fb 85       	ldd	r31, Y+11	; 0x0b
    4f42:	a4 81       	ldd	r26, Z+4	; 0x04
    4f44:	b5 81       	ldd	r27, Z+5	; 0x05
    4f46:	ea 85       	ldd	r30, Y+10	; 0x0a
    4f48:	fb 85       	ldd	r31, Y+11	; 0x0b
    4f4a:	86 81       	ldd	r24, Z+6	; 0x06
    4f4c:	97 81       	ldd	r25, Z+7	; 0x07
    4f4e:	15 96       	adiw	r26, 0x05	; 5
    4f50:	9c 93       	st	X, r25
    4f52:	8e 93       	st	-X, r24
    4f54:	14 97       	sbiw	r26, 0x04	; 4
    4f56:	ea 85       	ldd	r30, Y+10	; 0x0a
    4f58:	fb 85       	ldd	r31, Y+11	; 0x0b
    4f5a:	a6 81       	ldd	r26, Z+6	; 0x06
    4f5c:	b7 81       	ldd	r27, Z+7	; 0x07
    4f5e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4f60:	fb 85       	ldd	r31, Y+11	; 0x0b
    4f62:	84 81       	ldd	r24, Z+4	; 0x04
    4f64:	95 81       	ldd	r25, Z+5	; 0x05
    4f66:	13 96       	adiw	r26, 0x03	; 3
    4f68:	9c 93       	st	X, r25
    4f6a:	8e 93       	st	-X, r24
    4f6c:	12 97       	sbiw	r26, 0x02	; 2
    4f6e:	ed 81       	ldd	r30, Y+5	; 0x05
    4f70:	fe 81       	ldd	r31, Y+6	; 0x06
    4f72:	21 81       	ldd	r18, Z+1	; 0x01
    4f74:	32 81       	ldd	r19, Z+2	; 0x02
    4f76:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f78:	9b 85       	ldd	r25, Y+11	; 0x0b
    4f7a:	02 96       	adiw	r24, 0x02	; 2
    4f7c:	28 17       	cp	r18, r24
    4f7e:	39 07       	cpc	r19, r25
    4f80:	41 f4       	brne	.+16     	; 0x4f92 <xTaskGenericNotifyFromISR+0x26c>
    4f82:	ea 85       	ldd	r30, Y+10	; 0x0a
    4f84:	fb 85       	ldd	r31, Y+11	; 0x0b
    4f86:	86 81       	ldd	r24, Z+6	; 0x06
    4f88:	97 81       	ldd	r25, Z+7	; 0x07
    4f8a:	ed 81       	ldd	r30, Y+5	; 0x05
    4f8c:	fe 81       	ldd	r31, Y+6	; 0x06
    4f8e:	92 83       	std	Z+2, r25	; 0x02
    4f90:	81 83       	std	Z+1, r24	; 0x01
    4f92:	ea 85       	ldd	r30, Y+10	; 0x0a
    4f94:	fb 85       	ldd	r31, Y+11	; 0x0b
    4f96:	13 86       	std	Z+11, r1	; 0x0b
    4f98:	12 86       	std	Z+10, r1	; 0x0a
    4f9a:	ed 81       	ldd	r30, Y+5	; 0x05
    4f9c:	fe 81       	ldd	r31, Y+6	; 0x06
    4f9e:	80 81       	ld	r24, Z
    4fa0:	81 50       	subi	r24, 0x01	; 1
    4fa2:	ed 81       	ldd	r30, Y+5	; 0x05
    4fa4:	fe 81       	ldd	r31, Y+6	; 0x06
    4fa6:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    4fa8:	ea 85       	ldd	r30, Y+10	; 0x0a
    4faa:	fb 85       	ldd	r31, Y+11	; 0x0b
    4fac:	96 89       	ldd	r25, Z+22	; 0x16
    4fae:	80 91 52 06 	lds	r24, 0x0652
    4fb2:	89 17       	cp	r24, r25
    4fb4:	28 f4       	brcc	.+10     	; 0x4fc0 <xTaskGenericNotifyFromISR+0x29a>
    4fb6:	ea 85       	ldd	r30, Y+10	; 0x0a
    4fb8:	fb 85       	ldd	r31, Y+11	; 0x0b
    4fba:	86 89       	ldd	r24, Z+22	; 0x16
    4fbc:	80 93 52 06 	sts	0x0652, r24
    4fc0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4fc2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4fc4:	86 89       	ldd	r24, Z+22	; 0x16
    4fc6:	28 2f       	mov	r18, r24
    4fc8:	30 e0       	ldi	r19, 0x00	; 0
    4fca:	c9 01       	movw	r24, r18
    4fcc:	88 0f       	add	r24, r24
    4fce:	99 1f       	adc	r25, r25
    4fd0:	88 0f       	add	r24, r24
    4fd2:	99 1f       	adc	r25, r25
    4fd4:	88 0f       	add	r24, r24
    4fd6:	99 1f       	adc	r25, r25
    4fd8:	82 0f       	add	r24, r18
    4fda:	93 1f       	adc	r25, r19
    4fdc:	fc 01       	movw	r30, r24
    4fde:	e2 5a       	subi	r30, 0xA2	; 162
    4fe0:	f9 4f       	sbci	r31, 0xF9	; 249
    4fe2:	81 81       	ldd	r24, Z+1	; 0x01
    4fe4:	92 81       	ldd	r25, Z+2	; 0x02
    4fe6:	9c 83       	std	Y+4, r25	; 0x04
    4fe8:	8b 83       	std	Y+3, r24	; 0x03
    4fea:	ea 85       	ldd	r30, Y+10	; 0x0a
    4fec:	fb 85       	ldd	r31, Y+11	; 0x0b
    4fee:	8b 81       	ldd	r24, Y+3	; 0x03
    4ff0:	9c 81       	ldd	r25, Y+4	; 0x04
    4ff2:	95 83       	std	Z+5, r25	; 0x05
    4ff4:	84 83       	std	Z+4, r24	; 0x04
    4ff6:	eb 81       	ldd	r30, Y+3	; 0x03
    4ff8:	fc 81       	ldd	r31, Y+4	; 0x04
    4ffa:	84 81       	ldd	r24, Z+4	; 0x04
    4ffc:	95 81       	ldd	r25, Z+5	; 0x05
    4ffe:	ea 85       	ldd	r30, Y+10	; 0x0a
    5000:	fb 85       	ldd	r31, Y+11	; 0x0b
    5002:	97 83       	std	Z+7, r25	; 0x07
    5004:	86 83       	std	Z+6, r24	; 0x06
    5006:	eb 81       	ldd	r30, Y+3	; 0x03
    5008:	fc 81       	ldd	r31, Y+4	; 0x04
    500a:	04 80       	ldd	r0, Z+4	; 0x04
    500c:	f5 81       	ldd	r31, Z+5	; 0x05
    500e:	e0 2d       	mov	r30, r0
    5010:	8a 85       	ldd	r24, Y+10	; 0x0a
    5012:	9b 85       	ldd	r25, Y+11	; 0x0b
    5014:	02 96       	adiw	r24, 0x02	; 2
    5016:	93 83       	std	Z+3, r25	; 0x03
    5018:	82 83       	std	Z+2, r24	; 0x02
    501a:	8a 85       	ldd	r24, Y+10	; 0x0a
    501c:	9b 85       	ldd	r25, Y+11	; 0x0b
    501e:	02 96       	adiw	r24, 0x02	; 2
    5020:	eb 81       	ldd	r30, Y+3	; 0x03
    5022:	fc 81       	ldd	r31, Y+4	; 0x04
    5024:	95 83       	std	Z+5, r25	; 0x05
    5026:	84 83       	std	Z+4, r24	; 0x04
    5028:	ea 85       	ldd	r30, Y+10	; 0x0a
    502a:	fb 85       	ldd	r31, Y+11	; 0x0b
    502c:	86 89       	ldd	r24, Z+22	; 0x16
    502e:	28 2f       	mov	r18, r24
    5030:	30 e0       	ldi	r19, 0x00	; 0
    5032:	c9 01       	movw	r24, r18
    5034:	88 0f       	add	r24, r24
    5036:	99 1f       	adc	r25, r25
    5038:	88 0f       	add	r24, r24
    503a:	99 1f       	adc	r25, r25
    503c:	88 0f       	add	r24, r24
    503e:	99 1f       	adc	r25, r25
    5040:	82 0f       	add	r24, r18
    5042:	93 1f       	adc	r25, r19
    5044:	82 5a       	subi	r24, 0xA2	; 162
    5046:	99 4f       	sbci	r25, 0xF9	; 249
    5048:	ea 85       	ldd	r30, Y+10	; 0x0a
    504a:	fb 85       	ldd	r31, Y+11	; 0x0b
    504c:	93 87       	std	Z+11, r25	; 0x0b
    504e:	82 87       	std	Z+10, r24	; 0x0a
    5050:	ea 85       	ldd	r30, Y+10	; 0x0a
    5052:	fb 85       	ldd	r31, Y+11	; 0x0b
    5054:	86 89       	ldd	r24, Z+22	; 0x16
    5056:	28 2f       	mov	r18, r24
    5058:	30 e0       	ldi	r19, 0x00	; 0
    505a:	c9 01       	movw	r24, r18
    505c:	88 0f       	add	r24, r24
    505e:	99 1f       	adc	r25, r25
    5060:	88 0f       	add	r24, r24
    5062:	99 1f       	adc	r25, r25
    5064:	88 0f       	add	r24, r24
    5066:	99 1f       	adc	r25, r25
    5068:	82 0f       	add	r24, r18
    506a:	93 1f       	adc	r25, r19
    506c:	fc 01       	movw	r30, r24
    506e:	e2 5a       	subi	r30, 0xA2	; 162
    5070:	f9 4f       	sbci	r31, 0xF9	; 249
    5072:	80 81       	ld	r24, Z
    5074:	8f 5f       	subi	r24, 0xFF	; 255
    5076:	80 83       	st	Z, r24
    5078:	30 c0       	rjmp	.+96     	; 0x50da <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    507a:	80 91 99 06 	lds	r24, 0x0699
    507e:	90 91 9a 06 	lds	r25, 0x069A
    5082:	9a 83       	std	Y+2, r25	; 0x02
    5084:	89 83       	std	Y+1, r24	; 0x01
    5086:	ea 85       	ldd	r30, Y+10	; 0x0a
    5088:	fb 85       	ldd	r31, Y+11	; 0x0b
    508a:	89 81       	ldd	r24, Y+1	; 0x01
    508c:	9a 81       	ldd	r25, Y+2	; 0x02
    508e:	97 87       	std	Z+15, r25	; 0x0f
    5090:	86 87       	std	Z+14, r24	; 0x0e
    5092:	e9 81       	ldd	r30, Y+1	; 0x01
    5094:	fa 81       	ldd	r31, Y+2	; 0x02
    5096:	84 81       	ldd	r24, Z+4	; 0x04
    5098:	95 81       	ldd	r25, Z+5	; 0x05
    509a:	ea 85       	ldd	r30, Y+10	; 0x0a
    509c:	fb 85       	ldd	r31, Y+11	; 0x0b
    509e:	91 8b       	std	Z+17, r25	; 0x11
    50a0:	80 8b       	std	Z+16, r24	; 0x10
    50a2:	e9 81       	ldd	r30, Y+1	; 0x01
    50a4:	fa 81       	ldd	r31, Y+2	; 0x02
    50a6:	04 80       	ldd	r0, Z+4	; 0x04
    50a8:	f5 81       	ldd	r31, Z+5	; 0x05
    50aa:	e0 2d       	mov	r30, r0
    50ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    50ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    50b0:	0c 96       	adiw	r24, 0x0c	; 12
    50b2:	93 83       	std	Z+3, r25	; 0x03
    50b4:	82 83       	std	Z+2, r24	; 0x02
    50b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    50b8:	9b 85       	ldd	r25, Y+11	; 0x0b
    50ba:	0c 96       	adiw	r24, 0x0c	; 12
    50bc:	e9 81       	ldd	r30, Y+1	; 0x01
    50be:	fa 81       	ldd	r31, Y+2	; 0x02
    50c0:	95 83       	std	Z+5, r25	; 0x05
    50c2:	84 83       	std	Z+4, r24	; 0x04
    50c4:	ea 85       	ldd	r30, Y+10	; 0x0a
    50c6:	fb 85       	ldd	r31, Y+11	; 0x0b
    50c8:	88 e9       	ldi	r24, 0x98	; 152
    50ca:	96 e0       	ldi	r25, 0x06	; 6
    50cc:	95 8b       	std	Z+21, r25	; 0x15
    50ce:	84 8b       	std	Z+20, r24	; 0x14
    50d0:	80 91 98 06 	lds	r24, 0x0698
    50d4:	8f 5f       	subi	r24, 0xFF	; 255
    50d6:	80 93 98 06 	sts	0x0698, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    50da:	ea 85       	ldd	r30, Y+10	; 0x0a
    50dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    50de:	96 89       	ldd	r25, Z+22	; 0x16
    50e0:	e0 91 4c 06 	lds	r30, 0x064C
    50e4:	f0 91 4d 06 	lds	r31, 0x064D
    50e8:	86 89       	ldd	r24, Z+22	; 0x16
    50ea:	89 17       	cp	r24, r25
    50ec:	58 f4       	brcc	.+22     	; 0x5104 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    50ee:	8e 89       	ldd	r24, Y+22	; 0x16
    50f0:	9f 89       	ldd	r25, Y+23	; 0x17
    50f2:	00 97       	sbiw	r24, 0x00	; 0
    50f4:	21 f0       	breq	.+8      	; 0x50fe <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    50f6:	ee 89       	ldd	r30, Y+22	; 0x16
    50f8:	ff 89       	ldd	r31, Y+23	; 0x17
    50fa:	81 e0       	ldi	r24, 0x01	; 1
    50fc:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    50fe:	81 e0       	ldi	r24, 0x01	; 1
    5100:	80 93 56 06 	sts	0x0656, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    5104:	88 85       	ldd	r24, Y+8	; 0x08
    }
    5106:	69 96       	adiw	r28, 0x19	; 25
    5108:	0f b6       	in	r0, 0x3f	; 63
    510a:	f8 94       	cli
    510c:	de bf       	out	0x3e, r29	; 62
    510e:	0f be       	out	0x3f, r0	; 63
    5110:	cd bf       	out	0x3d, r28	; 61
    5112:	cf 91       	pop	r28
    5114:	df 91       	pop	r29
    5116:	1f 91       	pop	r17
    5118:	0f 91       	pop	r16
    511a:	ff 90       	pop	r15
    511c:	ef 90       	pop	r14
    511e:	df 90       	pop	r13
    5120:	cf 90       	pop	r12
    5122:	08 95       	ret

00005124 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    5124:	0f 93       	push	r16
    5126:	1f 93       	push	r17
    5128:	df 93       	push	r29
    512a:	cf 93       	push	r28
    512c:	cd b7       	in	r28, 0x3d	; 61
    512e:	de b7       	in	r29, 0x3e	; 62
    5130:	2f 97       	sbiw	r28, 0x0f	; 15
    5132:	0f b6       	in	r0, 0x3f	; 63
    5134:	f8 94       	cli
    5136:	de bf       	out	0x3e, r29	; 62
    5138:	0f be       	out	0x3f, r0	; 63
    513a:	cd bf       	out	0x3d, r28	; 61
    513c:	9c 87       	std	Y+12, r25	; 0x0c
    513e:	8b 87       	std	Y+11, r24	; 0x0b
    5140:	6d 87       	std	Y+13, r22	; 0x0d
    5142:	5f 87       	std	Y+15, r21	; 0x0f
    5144:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    5146:	8b 85       	ldd	r24, Y+11	; 0x0b
    5148:	9c 85       	ldd	r25, Y+12	; 0x0c
    514a:	9a 87       	std	Y+10, r25	; 0x0a
    514c:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    514e:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5150:	8d 85       	ldd	r24, Y+13	; 0x0d
    5152:	28 2f       	mov	r18, r24
    5154:	30 e0       	ldi	r19, 0x00	; 0
    5156:	89 85       	ldd	r24, Y+9	; 0x09
    5158:	9a 85       	ldd	r25, Y+10	; 0x0a
    515a:	82 0f       	add	r24, r18
    515c:	93 1f       	adc	r25, r19
    515e:	fc 01       	movw	r30, r24
    5160:	b5 96       	adiw	r30, 0x25	; 37
    5162:	80 81       	ld	r24, Z
    5164:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5166:	8d 85       	ldd	r24, Y+13	; 0x0d
    5168:	28 2f       	mov	r18, r24
    516a:	30 e0       	ldi	r19, 0x00	; 0
    516c:	89 85       	ldd	r24, Y+9	; 0x09
    516e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5170:	82 0f       	add	r24, r18
    5172:	93 1f       	adc	r25, r19
    5174:	fc 01       	movw	r30, r24
    5176:	b5 96       	adiw	r30, 0x25	; 37
    5178:	82 e0       	ldi	r24, 0x02	; 2
    517a:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    517c:	8d 85       	ldd	r24, Y+13	; 0x0d
    517e:	08 2f       	mov	r16, r24
    5180:	10 e0       	ldi	r17, 0x00	; 0
    5182:	29 85       	ldd	r18, Y+9	; 0x09
    5184:	3a 85       	ldd	r19, Y+10	; 0x0a
    5186:	c8 01       	movw	r24, r16
    5188:	88 0f       	add	r24, r24
    518a:	99 1f       	adc	r25, r25
    518c:	88 0f       	add	r24, r24
    518e:	99 1f       	adc	r25, r25
    5190:	82 0f       	add	r24, r18
    5192:	93 1f       	adc	r25, r19
    5194:	fc 01       	movw	r30, r24
    5196:	b1 96       	adiw	r30, 0x21	; 33
    5198:	80 81       	ld	r24, Z
    519a:	91 81       	ldd	r25, Z+1	; 0x01
    519c:	a2 81       	ldd	r26, Z+2	; 0x02
    519e:	b3 81       	ldd	r27, Z+3	; 0x03
    51a0:	ac 01       	movw	r20, r24
    51a2:	bd 01       	movw	r22, r26
    51a4:	4f 5f       	subi	r20, 0xFF	; 255
    51a6:	5f 4f       	sbci	r21, 0xFF	; 255
    51a8:	6f 4f       	sbci	r22, 0xFF	; 255
    51aa:	7f 4f       	sbci	r23, 0xFF	; 255
    51ac:	29 85       	ldd	r18, Y+9	; 0x09
    51ae:	3a 85       	ldd	r19, Y+10	; 0x0a
    51b0:	c8 01       	movw	r24, r16
    51b2:	88 0f       	add	r24, r24
    51b4:	99 1f       	adc	r25, r25
    51b6:	88 0f       	add	r24, r24
    51b8:	99 1f       	adc	r25, r25
    51ba:	82 0f       	add	r24, r18
    51bc:	93 1f       	adc	r25, r19
    51be:	fc 01       	movw	r30, r24
    51c0:	b1 96       	adiw	r30, 0x21	; 33
    51c2:	40 83       	st	Z, r20
    51c4:	51 83       	std	Z+1, r21	; 0x01
    51c6:	62 83       	std	Z+2, r22	; 0x02
    51c8:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    51ca:	88 85       	ldd	r24, Y+8	; 0x08
    51cc:	81 30       	cpi	r24, 0x01	; 1
    51ce:	09 f0       	breq	.+2      	; 0x51d2 <vTaskGenericNotifyGiveFromISR+0xae>
    51d0:	ee c0       	rjmp	.+476    	; 0x53ae <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    51d2:	80 91 5d 06 	lds	r24, 0x065D
    51d6:	88 23       	and	r24, r24
    51d8:	09 f0       	breq	.+2      	; 0x51dc <vTaskGenericNotifyGiveFromISR+0xb8>
    51da:	a4 c0       	rjmp	.+328    	; 0x5324 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    51dc:	e9 85       	ldd	r30, Y+9	; 0x09
    51de:	fa 85       	ldd	r31, Y+10	; 0x0a
    51e0:	82 85       	ldd	r24, Z+10	; 0x0a
    51e2:	93 85       	ldd	r25, Z+11	; 0x0b
    51e4:	9e 83       	std	Y+6, r25	; 0x06
    51e6:	8d 83       	std	Y+5, r24	; 0x05
    51e8:	e9 85       	ldd	r30, Y+9	; 0x09
    51ea:	fa 85       	ldd	r31, Y+10	; 0x0a
    51ec:	a4 81       	ldd	r26, Z+4	; 0x04
    51ee:	b5 81       	ldd	r27, Z+5	; 0x05
    51f0:	e9 85       	ldd	r30, Y+9	; 0x09
    51f2:	fa 85       	ldd	r31, Y+10	; 0x0a
    51f4:	86 81       	ldd	r24, Z+6	; 0x06
    51f6:	97 81       	ldd	r25, Z+7	; 0x07
    51f8:	15 96       	adiw	r26, 0x05	; 5
    51fa:	9c 93       	st	X, r25
    51fc:	8e 93       	st	-X, r24
    51fe:	14 97       	sbiw	r26, 0x04	; 4
    5200:	e9 85       	ldd	r30, Y+9	; 0x09
    5202:	fa 85       	ldd	r31, Y+10	; 0x0a
    5204:	a6 81       	ldd	r26, Z+6	; 0x06
    5206:	b7 81       	ldd	r27, Z+7	; 0x07
    5208:	e9 85       	ldd	r30, Y+9	; 0x09
    520a:	fa 85       	ldd	r31, Y+10	; 0x0a
    520c:	84 81       	ldd	r24, Z+4	; 0x04
    520e:	95 81       	ldd	r25, Z+5	; 0x05
    5210:	13 96       	adiw	r26, 0x03	; 3
    5212:	9c 93       	st	X, r25
    5214:	8e 93       	st	-X, r24
    5216:	12 97       	sbiw	r26, 0x02	; 2
    5218:	ed 81       	ldd	r30, Y+5	; 0x05
    521a:	fe 81       	ldd	r31, Y+6	; 0x06
    521c:	21 81       	ldd	r18, Z+1	; 0x01
    521e:	32 81       	ldd	r19, Z+2	; 0x02
    5220:	89 85       	ldd	r24, Y+9	; 0x09
    5222:	9a 85       	ldd	r25, Y+10	; 0x0a
    5224:	02 96       	adiw	r24, 0x02	; 2
    5226:	28 17       	cp	r18, r24
    5228:	39 07       	cpc	r19, r25
    522a:	41 f4       	brne	.+16     	; 0x523c <vTaskGenericNotifyGiveFromISR+0x118>
    522c:	e9 85       	ldd	r30, Y+9	; 0x09
    522e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5230:	86 81       	ldd	r24, Z+6	; 0x06
    5232:	97 81       	ldd	r25, Z+7	; 0x07
    5234:	ed 81       	ldd	r30, Y+5	; 0x05
    5236:	fe 81       	ldd	r31, Y+6	; 0x06
    5238:	92 83       	std	Z+2, r25	; 0x02
    523a:	81 83       	std	Z+1, r24	; 0x01
    523c:	e9 85       	ldd	r30, Y+9	; 0x09
    523e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5240:	13 86       	std	Z+11, r1	; 0x0b
    5242:	12 86       	std	Z+10, r1	; 0x0a
    5244:	ed 81       	ldd	r30, Y+5	; 0x05
    5246:	fe 81       	ldd	r31, Y+6	; 0x06
    5248:	80 81       	ld	r24, Z
    524a:	81 50       	subi	r24, 0x01	; 1
    524c:	ed 81       	ldd	r30, Y+5	; 0x05
    524e:	fe 81       	ldd	r31, Y+6	; 0x06
    5250:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5252:	e9 85       	ldd	r30, Y+9	; 0x09
    5254:	fa 85       	ldd	r31, Y+10	; 0x0a
    5256:	96 89       	ldd	r25, Z+22	; 0x16
    5258:	80 91 52 06 	lds	r24, 0x0652
    525c:	89 17       	cp	r24, r25
    525e:	28 f4       	brcc	.+10     	; 0x526a <vTaskGenericNotifyGiveFromISR+0x146>
    5260:	e9 85       	ldd	r30, Y+9	; 0x09
    5262:	fa 85       	ldd	r31, Y+10	; 0x0a
    5264:	86 89       	ldd	r24, Z+22	; 0x16
    5266:	80 93 52 06 	sts	0x0652, r24
    526a:	e9 85       	ldd	r30, Y+9	; 0x09
    526c:	fa 85       	ldd	r31, Y+10	; 0x0a
    526e:	86 89       	ldd	r24, Z+22	; 0x16
    5270:	28 2f       	mov	r18, r24
    5272:	30 e0       	ldi	r19, 0x00	; 0
    5274:	c9 01       	movw	r24, r18
    5276:	88 0f       	add	r24, r24
    5278:	99 1f       	adc	r25, r25
    527a:	88 0f       	add	r24, r24
    527c:	99 1f       	adc	r25, r25
    527e:	88 0f       	add	r24, r24
    5280:	99 1f       	adc	r25, r25
    5282:	82 0f       	add	r24, r18
    5284:	93 1f       	adc	r25, r19
    5286:	fc 01       	movw	r30, r24
    5288:	e2 5a       	subi	r30, 0xA2	; 162
    528a:	f9 4f       	sbci	r31, 0xF9	; 249
    528c:	81 81       	ldd	r24, Z+1	; 0x01
    528e:	92 81       	ldd	r25, Z+2	; 0x02
    5290:	9c 83       	std	Y+4, r25	; 0x04
    5292:	8b 83       	std	Y+3, r24	; 0x03
    5294:	e9 85       	ldd	r30, Y+9	; 0x09
    5296:	fa 85       	ldd	r31, Y+10	; 0x0a
    5298:	8b 81       	ldd	r24, Y+3	; 0x03
    529a:	9c 81       	ldd	r25, Y+4	; 0x04
    529c:	95 83       	std	Z+5, r25	; 0x05
    529e:	84 83       	std	Z+4, r24	; 0x04
    52a0:	eb 81       	ldd	r30, Y+3	; 0x03
    52a2:	fc 81       	ldd	r31, Y+4	; 0x04
    52a4:	84 81       	ldd	r24, Z+4	; 0x04
    52a6:	95 81       	ldd	r25, Z+5	; 0x05
    52a8:	e9 85       	ldd	r30, Y+9	; 0x09
    52aa:	fa 85       	ldd	r31, Y+10	; 0x0a
    52ac:	97 83       	std	Z+7, r25	; 0x07
    52ae:	86 83       	std	Z+6, r24	; 0x06
    52b0:	eb 81       	ldd	r30, Y+3	; 0x03
    52b2:	fc 81       	ldd	r31, Y+4	; 0x04
    52b4:	04 80       	ldd	r0, Z+4	; 0x04
    52b6:	f5 81       	ldd	r31, Z+5	; 0x05
    52b8:	e0 2d       	mov	r30, r0
    52ba:	89 85       	ldd	r24, Y+9	; 0x09
    52bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    52be:	02 96       	adiw	r24, 0x02	; 2
    52c0:	93 83       	std	Z+3, r25	; 0x03
    52c2:	82 83       	std	Z+2, r24	; 0x02
    52c4:	89 85       	ldd	r24, Y+9	; 0x09
    52c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    52c8:	02 96       	adiw	r24, 0x02	; 2
    52ca:	eb 81       	ldd	r30, Y+3	; 0x03
    52cc:	fc 81       	ldd	r31, Y+4	; 0x04
    52ce:	95 83       	std	Z+5, r25	; 0x05
    52d0:	84 83       	std	Z+4, r24	; 0x04
    52d2:	e9 85       	ldd	r30, Y+9	; 0x09
    52d4:	fa 85       	ldd	r31, Y+10	; 0x0a
    52d6:	86 89       	ldd	r24, Z+22	; 0x16
    52d8:	28 2f       	mov	r18, r24
    52da:	30 e0       	ldi	r19, 0x00	; 0
    52dc:	c9 01       	movw	r24, r18
    52de:	88 0f       	add	r24, r24
    52e0:	99 1f       	adc	r25, r25
    52e2:	88 0f       	add	r24, r24
    52e4:	99 1f       	adc	r25, r25
    52e6:	88 0f       	add	r24, r24
    52e8:	99 1f       	adc	r25, r25
    52ea:	82 0f       	add	r24, r18
    52ec:	93 1f       	adc	r25, r19
    52ee:	82 5a       	subi	r24, 0xA2	; 162
    52f0:	99 4f       	sbci	r25, 0xF9	; 249
    52f2:	e9 85       	ldd	r30, Y+9	; 0x09
    52f4:	fa 85       	ldd	r31, Y+10	; 0x0a
    52f6:	93 87       	std	Z+11, r25	; 0x0b
    52f8:	82 87       	std	Z+10, r24	; 0x0a
    52fa:	e9 85       	ldd	r30, Y+9	; 0x09
    52fc:	fa 85       	ldd	r31, Y+10	; 0x0a
    52fe:	86 89       	ldd	r24, Z+22	; 0x16
    5300:	28 2f       	mov	r18, r24
    5302:	30 e0       	ldi	r19, 0x00	; 0
    5304:	c9 01       	movw	r24, r18
    5306:	88 0f       	add	r24, r24
    5308:	99 1f       	adc	r25, r25
    530a:	88 0f       	add	r24, r24
    530c:	99 1f       	adc	r25, r25
    530e:	88 0f       	add	r24, r24
    5310:	99 1f       	adc	r25, r25
    5312:	82 0f       	add	r24, r18
    5314:	93 1f       	adc	r25, r19
    5316:	fc 01       	movw	r30, r24
    5318:	e2 5a       	subi	r30, 0xA2	; 162
    531a:	f9 4f       	sbci	r31, 0xF9	; 249
    531c:	80 81       	ld	r24, Z
    531e:	8f 5f       	subi	r24, 0xFF	; 255
    5320:	80 83       	st	Z, r24
    5322:	30 c0       	rjmp	.+96     	; 0x5384 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5324:	80 91 99 06 	lds	r24, 0x0699
    5328:	90 91 9a 06 	lds	r25, 0x069A
    532c:	9a 83       	std	Y+2, r25	; 0x02
    532e:	89 83       	std	Y+1, r24	; 0x01
    5330:	e9 85       	ldd	r30, Y+9	; 0x09
    5332:	fa 85       	ldd	r31, Y+10	; 0x0a
    5334:	89 81       	ldd	r24, Y+1	; 0x01
    5336:	9a 81       	ldd	r25, Y+2	; 0x02
    5338:	97 87       	std	Z+15, r25	; 0x0f
    533a:	86 87       	std	Z+14, r24	; 0x0e
    533c:	e9 81       	ldd	r30, Y+1	; 0x01
    533e:	fa 81       	ldd	r31, Y+2	; 0x02
    5340:	84 81       	ldd	r24, Z+4	; 0x04
    5342:	95 81       	ldd	r25, Z+5	; 0x05
    5344:	e9 85       	ldd	r30, Y+9	; 0x09
    5346:	fa 85       	ldd	r31, Y+10	; 0x0a
    5348:	91 8b       	std	Z+17, r25	; 0x11
    534a:	80 8b       	std	Z+16, r24	; 0x10
    534c:	e9 81       	ldd	r30, Y+1	; 0x01
    534e:	fa 81       	ldd	r31, Y+2	; 0x02
    5350:	04 80       	ldd	r0, Z+4	; 0x04
    5352:	f5 81       	ldd	r31, Z+5	; 0x05
    5354:	e0 2d       	mov	r30, r0
    5356:	89 85       	ldd	r24, Y+9	; 0x09
    5358:	9a 85       	ldd	r25, Y+10	; 0x0a
    535a:	0c 96       	adiw	r24, 0x0c	; 12
    535c:	93 83       	std	Z+3, r25	; 0x03
    535e:	82 83       	std	Z+2, r24	; 0x02
    5360:	89 85       	ldd	r24, Y+9	; 0x09
    5362:	9a 85       	ldd	r25, Y+10	; 0x0a
    5364:	0c 96       	adiw	r24, 0x0c	; 12
    5366:	e9 81       	ldd	r30, Y+1	; 0x01
    5368:	fa 81       	ldd	r31, Y+2	; 0x02
    536a:	95 83       	std	Z+5, r25	; 0x05
    536c:	84 83       	std	Z+4, r24	; 0x04
    536e:	e9 85       	ldd	r30, Y+9	; 0x09
    5370:	fa 85       	ldd	r31, Y+10	; 0x0a
    5372:	88 e9       	ldi	r24, 0x98	; 152
    5374:	96 e0       	ldi	r25, 0x06	; 6
    5376:	95 8b       	std	Z+21, r25	; 0x15
    5378:	84 8b       	std	Z+20, r24	; 0x14
    537a:	80 91 98 06 	lds	r24, 0x0698
    537e:	8f 5f       	subi	r24, 0xFF	; 255
    5380:	80 93 98 06 	sts	0x0698, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5384:	e9 85       	ldd	r30, Y+9	; 0x09
    5386:	fa 85       	ldd	r31, Y+10	; 0x0a
    5388:	96 89       	ldd	r25, Z+22	; 0x16
    538a:	e0 91 4c 06 	lds	r30, 0x064C
    538e:	f0 91 4d 06 	lds	r31, 0x064D
    5392:	86 89       	ldd	r24, Z+22	; 0x16
    5394:	89 17       	cp	r24, r25
    5396:	58 f4       	brcc	.+22     	; 0x53ae <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5398:	8e 85       	ldd	r24, Y+14	; 0x0e
    539a:	9f 85       	ldd	r25, Y+15	; 0x0f
    539c:	00 97       	sbiw	r24, 0x00	; 0
    539e:	21 f0       	breq	.+8      	; 0x53a8 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    53a0:	ee 85       	ldd	r30, Y+14	; 0x0e
    53a2:	ff 85       	ldd	r31, Y+15	; 0x0f
    53a4:	81 e0       	ldi	r24, 0x01	; 1
    53a6:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    53a8:	81 e0       	ldi	r24, 0x01	; 1
    53aa:	80 93 56 06 	sts	0x0656, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    53ae:	2f 96       	adiw	r28, 0x0f	; 15
    53b0:	0f b6       	in	r0, 0x3f	; 63
    53b2:	f8 94       	cli
    53b4:	de bf       	out	0x3e, r29	; 62
    53b6:	0f be       	out	0x3f, r0	; 63
    53b8:	cd bf       	out	0x3d, r28	; 61
    53ba:	cf 91       	pop	r28
    53bc:	df 91       	pop	r29
    53be:	1f 91       	pop	r17
    53c0:	0f 91       	pop	r16
    53c2:	08 95       	ret

000053c4 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    53c4:	df 93       	push	r29
    53c6:	cf 93       	push	r28
    53c8:	cd b7       	in	r28, 0x3d	; 61
    53ca:	de b7       	in	r29, 0x3e	; 62
    53cc:	28 97       	sbiw	r28, 0x08	; 8
    53ce:	0f b6       	in	r0, 0x3f	; 63
    53d0:	f8 94       	cli
    53d2:	de bf       	out	0x3e, r29	; 62
    53d4:	0f be       	out	0x3f, r0	; 63
    53d6:	cd bf       	out	0x3d, r28	; 61
    53d8:	9d 83       	std	Y+5, r25	; 0x05
    53da:	8c 83       	std	Y+4, r24	; 0x04
    53dc:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    53de:	8c 81       	ldd	r24, Y+4	; 0x04
    53e0:	9d 81       	ldd	r25, Y+5	; 0x05
    53e2:	00 97       	sbiw	r24, 0x00	; 0
    53e4:	39 f4       	brne	.+14     	; 0x53f4 <xTaskGenericNotifyStateClear+0x30>
    53e6:	80 91 4c 06 	lds	r24, 0x064C
    53ea:	90 91 4d 06 	lds	r25, 0x064D
    53ee:	98 87       	std	Y+8, r25	; 0x08
    53f0:	8f 83       	std	Y+7, r24	; 0x07
    53f2:	04 c0       	rjmp	.+8      	; 0x53fc <xTaskGenericNotifyStateClear+0x38>
    53f4:	8c 81       	ldd	r24, Y+4	; 0x04
    53f6:	9d 81       	ldd	r25, Y+5	; 0x05
    53f8:	98 87       	std	Y+8, r25	; 0x08
    53fa:	8f 83       	std	Y+7, r24	; 0x07
    53fc:	8f 81       	ldd	r24, Y+7	; 0x07
    53fe:	98 85       	ldd	r25, Y+8	; 0x08
    5400:	9b 83       	std	Y+3, r25	; 0x03
    5402:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    5404:	0f b6       	in	r0, 0x3f	; 63
    5406:	f8 94       	cli
    5408:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    540a:	8e 81       	ldd	r24, Y+6	; 0x06
    540c:	28 2f       	mov	r18, r24
    540e:	30 e0       	ldi	r19, 0x00	; 0
    5410:	8a 81       	ldd	r24, Y+2	; 0x02
    5412:	9b 81       	ldd	r25, Y+3	; 0x03
    5414:	82 0f       	add	r24, r18
    5416:	93 1f       	adc	r25, r19
    5418:	fc 01       	movw	r30, r24
    541a:	b5 96       	adiw	r30, 0x25	; 37
    541c:	80 81       	ld	r24, Z
    541e:	82 30       	cpi	r24, 0x02	; 2
    5420:	69 f4       	brne	.+26     	; 0x543c <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5422:	8e 81       	ldd	r24, Y+6	; 0x06
    5424:	28 2f       	mov	r18, r24
    5426:	30 e0       	ldi	r19, 0x00	; 0
    5428:	8a 81       	ldd	r24, Y+2	; 0x02
    542a:	9b 81       	ldd	r25, Y+3	; 0x03
    542c:	82 0f       	add	r24, r18
    542e:	93 1f       	adc	r25, r19
    5430:	fc 01       	movw	r30, r24
    5432:	b5 96       	adiw	r30, 0x25	; 37
    5434:	10 82       	st	Z, r1
                xReturn = pdPASS;
    5436:	81 e0       	ldi	r24, 0x01	; 1
    5438:	89 83       	std	Y+1, r24	; 0x01
    543a:	01 c0       	rjmp	.+2      	; 0x543e <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    543c:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    543e:	0f 90       	pop	r0
    5440:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5442:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5444:	28 96       	adiw	r28, 0x08	; 8
    5446:	0f b6       	in	r0, 0x3f	; 63
    5448:	f8 94       	cli
    544a:	de bf       	out	0x3e, r29	; 62
    544c:	0f be       	out	0x3f, r0	; 63
    544e:	cd bf       	out	0x3d, r28	; 61
    5450:	cf 91       	pop	r28
    5452:	df 91       	pop	r29
    5454:	08 95       	ret

00005456 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    5456:	0f 93       	push	r16
    5458:	1f 93       	push	r17
    545a:	df 93       	push	r29
    545c:	cf 93       	push	r28
    545e:	cd b7       	in	r28, 0x3d	; 61
    5460:	de b7       	in	r29, 0x3e	; 62
    5462:	2f 97       	sbiw	r28, 0x0f	; 15
    5464:	0f b6       	in	r0, 0x3f	; 63
    5466:	f8 94       	cli
    5468:	de bf       	out	0x3e, r29	; 62
    546a:	0f be       	out	0x3f, r0	; 63
    546c:	cd bf       	out	0x3d, r28	; 61
    546e:	98 87       	std	Y+8, r25	; 0x08
    5470:	8f 83       	std	Y+7, r24	; 0x07
    5472:	69 87       	std	Y+9, r22	; 0x09
    5474:	2a 87       	std	Y+10, r18	; 0x0a
    5476:	3b 87       	std	Y+11, r19	; 0x0b
    5478:	4c 87       	std	Y+12, r20	; 0x0c
    547a:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    547c:	8f 81       	ldd	r24, Y+7	; 0x07
    547e:	98 85       	ldd	r25, Y+8	; 0x08
    5480:	00 97       	sbiw	r24, 0x00	; 0
    5482:	39 f4       	brne	.+14     	; 0x5492 <ulTaskGenericNotifyValueClear+0x3c>
    5484:	80 91 4c 06 	lds	r24, 0x064C
    5488:	90 91 4d 06 	lds	r25, 0x064D
    548c:	9f 87       	std	Y+15, r25	; 0x0f
    548e:	8e 87       	std	Y+14, r24	; 0x0e
    5490:	04 c0       	rjmp	.+8      	; 0x549a <ulTaskGenericNotifyValueClear+0x44>
    5492:	8f 81       	ldd	r24, Y+7	; 0x07
    5494:	98 85       	ldd	r25, Y+8	; 0x08
    5496:	9f 87       	std	Y+15, r25	; 0x0f
    5498:	8e 87       	std	Y+14, r24	; 0x0e
    549a:	8e 85       	ldd	r24, Y+14	; 0x0e
    549c:	9f 85       	ldd	r25, Y+15	; 0x0f
    549e:	9e 83       	std	Y+6, r25	; 0x06
    54a0:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    54a2:	0f b6       	in	r0, 0x3f	; 63
    54a4:	f8 94       	cli
    54a6:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    54a8:	89 85       	ldd	r24, Y+9	; 0x09
    54aa:	88 2f       	mov	r24, r24
    54ac:	90 e0       	ldi	r25, 0x00	; 0
    54ae:	2d 81       	ldd	r18, Y+5	; 0x05
    54b0:	3e 81       	ldd	r19, Y+6	; 0x06
    54b2:	88 0f       	add	r24, r24
    54b4:	99 1f       	adc	r25, r25
    54b6:	88 0f       	add	r24, r24
    54b8:	99 1f       	adc	r25, r25
    54ba:	82 0f       	add	r24, r18
    54bc:	93 1f       	adc	r25, r19
    54be:	fc 01       	movw	r30, r24
    54c0:	b1 96       	adiw	r30, 0x21	; 33
    54c2:	80 81       	ld	r24, Z
    54c4:	91 81       	ldd	r25, Z+1	; 0x01
    54c6:	a2 81       	ldd	r26, Z+2	; 0x02
    54c8:	b3 81       	ldd	r27, Z+3	; 0x03
    54ca:	89 83       	std	Y+1, r24	; 0x01
    54cc:	9a 83       	std	Y+2, r25	; 0x02
    54ce:	ab 83       	std	Y+3, r26	; 0x03
    54d0:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    54d2:	89 85       	ldd	r24, Y+9	; 0x09
    54d4:	08 2f       	mov	r16, r24
    54d6:	10 e0       	ldi	r17, 0x00	; 0
    54d8:	89 85       	ldd	r24, Y+9	; 0x09
    54da:	88 2f       	mov	r24, r24
    54dc:	90 e0       	ldi	r25, 0x00	; 0
    54de:	2d 81       	ldd	r18, Y+5	; 0x05
    54e0:	3e 81       	ldd	r19, Y+6	; 0x06
    54e2:	88 0f       	add	r24, r24
    54e4:	99 1f       	adc	r25, r25
    54e6:	88 0f       	add	r24, r24
    54e8:	99 1f       	adc	r25, r25
    54ea:	82 0f       	add	r24, r18
    54ec:	93 1f       	adc	r25, r19
    54ee:	fc 01       	movw	r30, r24
    54f0:	b1 96       	adiw	r30, 0x21	; 33
    54f2:	20 81       	ld	r18, Z
    54f4:	31 81       	ldd	r19, Z+1	; 0x01
    54f6:	42 81       	ldd	r20, Z+2	; 0x02
    54f8:	53 81       	ldd	r21, Z+3	; 0x03
    54fa:	8a 85       	ldd	r24, Y+10	; 0x0a
    54fc:	9b 85       	ldd	r25, Y+11	; 0x0b
    54fe:	ac 85       	ldd	r26, Y+12	; 0x0c
    5500:	bd 85       	ldd	r27, Y+13	; 0x0d
    5502:	80 95       	com	r24
    5504:	90 95       	com	r25
    5506:	a0 95       	com	r26
    5508:	b0 95       	com	r27
    550a:	ba 01       	movw	r22, r20
    550c:	a9 01       	movw	r20, r18
    550e:	48 23       	and	r20, r24
    5510:	59 23       	and	r21, r25
    5512:	6a 23       	and	r22, r26
    5514:	7b 23       	and	r23, r27
    5516:	2d 81       	ldd	r18, Y+5	; 0x05
    5518:	3e 81       	ldd	r19, Y+6	; 0x06
    551a:	c8 01       	movw	r24, r16
    551c:	88 0f       	add	r24, r24
    551e:	99 1f       	adc	r25, r25
    5520:	88 0f       	add	r24, r24
    5522:	99 1f       	adc	r25, r25
    5524:	82 0f       	add	r24, r18
    5526:	93 1f       	adc	r25, r19
    5528:	fc 01       	movw	r30, r24
    552a:	b1 96       	adiw	r30, 0x21	; 33
    552c:	40 83       	st	Z, r20
    552e:	51 83       	std	Z+1, r21	; 0x01
    5530:	62 83       	std	Z+2, r22	; 0x02
    5532:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    5534:	0f 90       	pop	r0
    5536:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5538:	89 81       	ldd	r24, Y+1	; 0x01
    553a:	9a 81       	ldd	r25, Y+2	; 0x02
    553c:	ab 81       	ldd	r26, Y+3	; 0x03
    553e:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5540:	bc 01       	movw	r22, r24
    5542:	cd 01       	movw	r24, r26
    5544:	2f 96       	adiw	r28, 0x0f	; 15
    5546:	0f b6       	in	r0, 0x3f	; 63
    5548:	f8 94       	cli
    554a:	de bf       	out	0x3e, r29	; 62
    554c:	0f be       	out	0x3f, r0	; 63
    554e:	cd bf       	out	0x3d, r28	; 61
    5550:	cf 91       	pop	r28
    5552:	df 91       	pop	r29
    5554:	1f 91       	pop	r17
    5556:	0f 91       	pop	r16
    5558:	08 95       	ret

0000555a <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    555a:	df 93       	push	r29
    555c:	cf 93       	push	r28
    555e:	cd b7       	in	r28, 0x3d	; 61
    5560:	de b7       	in	r29, 0x3e	; 62
    5562:	27 97       	sbiw	r28, 0x07	; 7
    5564:	0f b6       	in	r0, 0x3f	; 63
    5566:	f8 94       	cli
    5568:	de bf       	out	0x3e, r29	; 62
    556a:	0f be       	out	0x3f, r0	; 63
    556c:	cd bf       	out	0x3d, r28	; 61
    556e:	9e 83       	std	Y+6, r25	; 0x06
    5570:	8d 83       	std	Y+5, r24	; 0x05
    5572:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    5574:	80 91 50 06 	lds	r24, 0x0650
    5578:	90 91 51 06 	lds	r25, 0x0651
    557c:	9a 83       	std	Y+2, r25	; 0x02
    557e:	89 83       	std	Y+1, r24	; 0x01
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5580:	80 91 4c 06 	lds	r24, 0x064C
    5584:	90 91 4d 06 	lds	r25, 0x064D
    5588:	02 96       	adiw	r24, 0x02	; 2
    558a:	0e 94 cc 07 	call	0xf98	; 0xf98 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
    {
        /* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;
    558e:	29 81       	ldd	r18, Y+1	; 0x01
    5590:	3a 81       	ldd	r19, Y+2	; 0x02
    5592:	8d 81       	ldd	r24, Y+5	; 0x05
    5594:	9e 81       	ldd	r25, Y+6	; 0x06
    5596:	82 0f       	add	r24, r18
    5598:	93 1f       	adc	r25, r19
    559a:	9c 83       	std	Y+4, r25	; 0x04
    559c:	8b 83       	std	Y+3, r24	; 0x03

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    559e:	e0 91 4c 06 	lds	r30, 0x064C
    55a2:	f0 91 4d 06 	lds	r31, 0x064D
    55a6:	8b 81       	ldd	r24, Y+3	; 0x03
    55a8:	9c 81       	ldd	r25, Y+4	; 0x04
    55aa:	93 83       	std	Z+3, r25	; 0x03
    55ac:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xConstTickCount )
    55ae:	2b 81       	ldd	r18, Y+3	; 0x03
    55b0:	3c 81       	ldd	r19, Y+4	; 0x04
    55b2:	89 81       	ldd	r24, Y+1	; 0x01
    55b4:	9a 81       	ldd	r25, Y+2	; 0x02
    55b6:	28 17       	cp	r18, r24
    55b8:	39 07       	cpc	r19, r25
    55ba:	70 f4       	brcc	.+28     	; 0x55d8 <prvAddCurrentTaskToDelayedList+0x7e>
        {
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    55bc:	80 91 96 06 	lds	r24, 0x0696
    55c0:	90 91 97 06 	lds	r25, 0x0697
    55c4:	20 91 4c 06 	lds	r18, 0x064C
    55c8:	30 91 4d 06 	lds	r19, 0x064D
    55cc:	2e 5f       	subi	r18, 0xFE	; 254
    55ce:	3f 4f       	sbci	r19, 0xFF	; 255
    55d0:	b9 01       	movw	r22, r18
    55d2:	0e 94 60 07 	call	0xec0	; 0xec0 <vListInsert>
    55d6:	1e c0       	rjmp	.+60     	; 0x5614 <prvAddCurrentTaskToDelayedList+0xba>
        }
        else
        {
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    55d8:	40 91 94 06 	lds	r20, 0x0694
    55dc:	50 91 95 06 	lds	r21, 0x0695
    55e0:	80 91 4c 06 	lds	r24, 0x064C
    55e4:	90 91 4d 06 	lds	r25, 0x064D
    55e8:	9c 01       	movw	r18, r24
    55ea:	2e 5f       	subi	r18, 0xFE	; 254
    55ec:	3f 4f       	sbci	r19, 0xFF	; 255
    55ee:	ca 01       	movw	r24, r20
    55f0:	b9 01       	movw	r22, r18
    55f2:	0e 94 60 07 	call	0xec0	; 0xec0 <vListInsert>

            /* If the task entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
             * too. */
            if( xTimeToWake < xNextTaskUnblockTime )
    55f6:	20 91 59 06 	lds	r18, 0x0659
    55fa:	30 91 5a 06 	lds	r19, 0x065A
    55fe:	8b 81       	ldd	r24, Y+3	; 0x03
    5600:	9c 81       	ldd	r25, Y+4	; 0x04
    5602:	82 17       	cp	r24, r18
    5604:	93 07       	cpc	r25, r19
    5606:	30 f4       	brcc	.+12     	; 0x5614 <prvAddCurrentTaskToDelayedList+0xba>
            {
                xNextTaskUnblockTime = xTimeToWake;
    5608:	8b 81       	ldd	r24, Y+3	; 0x03
    560a:	9c 81       	ldd	r25, Y+4	; 0x04
    560c:	90 93 5a 06 	sts	0x065A, r25
    5610:	80 93 59 06 	sts	0x0659, r24

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    5614:	27 96       	adiw	r28, 0x07	; 7
    5616:	0f b6       	in	r0, 0x3f	; 63
    5618:	f8 94       	cli
    561a:	de bf       	out	0x3e, r29	; 62
    561c:	0f be       	out	0x3f, r0	; 63
    561e:	cd bf       	out	0x3d, r28	; 61
    5620:	cf 91       	pop	r28
    5622:	df 91       	pop	r29
    5624:	08 95       	ret

00005626 <main>:
 /*Create Task Handles Create */
 xTaskHandle Task1Hand = NULL;


 int main(void)
{
    5626:	ef 92       	push	r14
    5628:	ff 92       	push	r15
    562a:	0f 93       	push	r16
    562c:	df 93       	push	r29
    562e:	cf 93       	push	r28
    5630:	cd b7       	in	r28, 0x3d	; 61
    5632:	de b7       	in	r29, 0x3e	; 62
	/*initialize DIO*/
	DDRB |= 0x01;
    5634:	a7 e3       	ldi	r26, 0x37	; 55
    5636:	b0 e0       	ldi	r27, 0x00	; 0
    5638:	e7 e3       	ldi	r30, 0x37	; 55
    563a:	f0 e0       	ldi	r31, 0x00	; 0
    563c:	80 81       	ld	r24, Z
    563e:	81 60       	ori	r24, 0x01	; 1
    5640:	8c 93       	st	X, r24
	/*Create tasks*/
	xTaskCreate(LedIntro_code,(const signed char *)"Task1",85,NULL,LedOn_PRIORITY,&Task1Hand);
    5642:	8a e3       	ldi	r24, 0x3A	; 58
    5644:	9b e2       	ldi	r25, 0x2B	; 43
    5646:	25 e6       	ldi	r18, 0x65	; 101
    5648:	30 e0       	ldi	r19, 0x00	; 0
    564a:	ea ea       	ldi	r30, 0xAA	; 170
    564c:	f6 e0       	ldi	r31, 0x06	; 6
    564e:	b9 01       	movw	r22, r18
    5650:	45 e5       	ldi	r20, 0x55	; 85
    5652:	50 e0       	ldi	r21, 0x00	; 0
    5654:	20 e0       	ldi	r18, 0x00	; 0
    5656:	30 e0       	ldi	r19, 0x00	; 0
    5658:	02 e0       	ldi	r16, 0x02	; 2
    565a:	7f 01       	movw	r14, r30
    565c:	0e 94 9b 17 	call	0x2f36	; 0x2f36 <xTaskCreate>

	/*start Scheduler */
	vTaskStartScheduler();
    5660:	0e 94 97 1a 	call	0x352e	; 0x352e <vTaskStartScheduler>

	/*Never Enter Here */
	return 0;
    5664:	80 e0       	ldi	r24, 0x00	; 0
    5666:	90 e0       	ldi	r25, 0x00	; 0
}
    5668:	cf 91       	pop	r28
    566a:	df 91       	pop	r29
    566c:	0f 91       	pop	r16
    566e:	ff 90       	pop	r15
    5670:	ef 90       	pop	r14
    5672:	08 95       	ret

00005674 <LedIntro_code>:

/*Task1 Code */
 void LedIntro_code(void*pvParamter)
{
    5674:	df 93       	push	r29
    5676:	cf 93       	push	r28
    5678:	00 d0       	rcall	.+0      	; 0x567a <LedIntro_code+0x6>
    567a:	cd b7       	in	r28, 0x3d	; 61
    567c:	de b7       	in	r29, 0x3e	; 62
    567e:	9a 83       	std	Y+2, r25	; 0x02
    5680:	89 83       	std	Y+1, r24	; 0x01
	for (;;)
	{

		/*Toggle Led */
		PORTB |= 0x01;
    5682:	a8 e3       	ldi	r26, 0x38	; 56
    5684:	b0 e0       	ldi	r27, 0x00	; 0
    5686:	e8 e3       	ldi	r30, 0x38	; 56
    5688:	f0 e0       	ldi	r31, 0x00	; 0
    568a:	80 81       	ld	r24, Z
    568c:	81 60       	ori	r24, 0x01	; 1
    568e:	8c 93       	st	X, r24

		/*Send Task in Blocked Queue for 2000 Ticks */
		vTaskDelay(2000);
    5690:	80 ed       	ldi	r24, 0xD0	; 208
    5692:	97 e0       	ldi	r25, 0x07	; 7
    5694:	0e 94 75 1a 	call	0x34ea	; 0x34ea <vTaskDelay>

		/*Toggle Led */
		PORTB &= 0xFE;
    5698:	a8 e3       	ldi	r26, 0x38	; 56
    569a:	b0 e0       	ldi	r27, 0x00	; 0
    569c:	e8 e3       	ldi	r30, 0x38	; 56
    569e:	f0 e0       	ldi	r31, 0x00	; 0
    56a0:	80 81       	ld	r24, Z
    56a2:	8e 7f       	andi	r24, 0xFE	; 254
    56a4:	8c 93       	st	X, r24

		/*Send Task in Blocked Queue for 2000 Ticks */
		vTaskDelay(2000);
    56a6:	80 ed       	ldi	r24, 0xD0	; 208
    56a8:	97 e0       	ldi	r25, 0x07	; 7
    56aa:	0e 94 75 1a 	call	0x34ea	; 0x34ea <vTaskDelay>
    56ae:	e9 cf       	rjmp	.-46     	; 0x5682 <LedIntro_code+0xe>

000056b0 <__udivmodhi4>:
    56b0:	aa 1b       	sub	r26, r26
    56b2:	bb 1b       	sub	r27, r27
    56b4:	51 e1       	ldi	r21, 0x11	; 17
    56b6:	07 c0       	rjmp	.+14     	; 0x56c6 <__udivmodhi4_ep>

000056b8 <__udivmodhi4_loop>:
    56b8:	aa 1f       	adc	r26, r26
    56ba:	bb 1f       	adc	r27, r27
    56bc:	a6 17       	cp	r26, r22
    56be:	b7 07       	cpc	r27, r23
    56c0:	10 f0       	brcs	.+4      	; 0x56c6 <__udivmodhi4_ep>
    56c2:	a6 1b       	sub	r26, r22
    56c4:	b7 0b       	sbc	r27, r23

000056c6 <__udivmodhi4_ep>:
    56c6:	88 1f       	adc	r24, r24
    56c8:	99 1f       	adc	r25, r25
    56ca:	5a 95       	dec	r21
    56cc:	a9 f7       	brne	.-22     	; 0x56b8 <__udivmodhi4_loop>
    56ce:	80 95       	com	r24
    56d0:	90 95       	com	r25
    56d2:	bc 01       	movw	r22, r24
    56d4:	cd 01       	movw	r24, r26
    56d6:	08 95       	ret

000056d8 <memcpy>:
    56d8:	fb 01       	movw	r30, r22
    56da:	dc 01       	movw	r26, r24
    56dc:	02 c0       	rjmp	.+4      	; 0x56e2 <memcpy+0xa>
    56de:	01 90       	ld	r0, Z+
    56e0:	0d 92       	st	X+, r0
    56e2:	41 50       	subi	r20, 0x01	; 1
    56e4:	50 40       	sbci	r21, 0x00	; 0
    56e6:	d8 f7       	brcc	.-10     	; 0x56de <memcpy+0x6>
    56e8:	08 95       	ret

000056ea <memset>:
    56ea:	dc 01       	movw	r26, r24
    56ec:	01 c0       	rjmp	.+2      	; 0x56f0 <memset+0x6>
    56ee:	6d 93       	st	X+, r22
    56f0:	41 50       	subi	r20, 0x01	; 1
    56f2:	50 40       	sbci	r21, 0x00	; 0
    56f4:	e0 f7       	brcc	.-8      	; 0x56ee <memset+0x4>
    56f6:	08 95       	ret

000056f8 <_exit>:
    56f8:	f8 94       	cli

000056fa <__stop_program>:
    56fa:	ff cf       	rjmp	.-2      	; 0x56fa <__stop_program>
